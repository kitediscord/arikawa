// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: discord/guild.go

package discord

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Ban) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Ban) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(j.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(j.Reason))
		buf.WriteByte(',')
	}
	buf.WriteString(`"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtBanbase = iota
	ffjtBannosuchkey

	ffjtBanReason

	ffjtBanUser
)

var ffjKeyBanReason = []byte("reason")

var ffjKeyBanUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Ban) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Ban) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtBanbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtBannosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffjKeyBanReason, kn) {
						currentKey = ffjtBanReason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyBanUser, kn) {
						currentKey = ffjtBanUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyBanUser, kn) {
					currentKey = ffjtBanUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBanReason, kn) {
					currentKey = ffjtBanReason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtBannosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtBanReason:
					goto handle_Reason

				case ffjtBanUser:
					goto handle_User

				case ffjtBannosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Reason:

	/* handler: j.Reason type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Reason = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ClientStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ClientStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Desktop) != 0 {
		buf.WriteString(`"desktop":`)
		fflib.WriteJsonString(buf, string(j.Desktop))
		buf.WriteByte(',')
	}
	if len(j.Mobile) != 0 {
		buf.WriteString(`"mobile":`)
		fflib.WriteJsonString(buf, string(j.Mobile))
		buf.WriteByte(',')
	}
	if len(j.Web) != 0 {
		buf.WriteString(`"web":`)
		fflib.WriteJsonString(buf, string(j.Web))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtClientStatusbase = iota
	ffjtClientStatusnosuchkey

	ffjtClientStatusDesktop

	ffjtClientStatusMobile

	ffjtClientStatusWeb
)

var ffjKeyClientStatusDesktop = []byte("desktop")

var ffjKeyClientStatusMobile = []byte("mobile")

var ffjKeyClientStatusWeb = []byte("web")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ClientStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ClientStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtClientStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtClientStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyClientStatusDesktop, kn) {
						currentKey = ffjtClientStatusDesktop
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyClientStatusMobile, kn) {
						currentKey = ffjtClientStatusMobile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyClientStatusWeb, kn) {
						currentKey = ffjtClientStatusWeb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyClientStatusWeb, kn) {
					currentKey = ffjtClientStatusWeb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyClientStatusMobile, kn) {
					currentKey = ffjtClientStatusMobile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClientStatusDesktop, kn) {
					currentKey = ffjtClientStatusDesktop
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtClientStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtClientStatusDesktop:
					goto handle_Desktop

				case ffjtClientStatusMobile:
					goto handle_Mobile

				case ffjtClientStatusWeb:
					goto handle_Web

				case ffjtClientStatusnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desktop:

	/* handler: j.Desktop type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desktop = Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mobile:

	/* handler: j.Mobile type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mobile = Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Web:

	/* handler: j.Web type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Web = Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Guild) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Guild) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"icon":`)
	fflib.WriteJsonString(buf, string(j.Icon))
	buf.WriteByte(',')
	if len(j.Splash) != 0 {
		buf.WriteString(`"splash":`)
		fflib.WriteJsonString(buf, string(j.Splash))
		buf.WriteByte(',')
	}
	if len(j.DiscoverySplash) != 0 {
		buf.WriteString(`"discovery_splash":`)
		fflib.WriteJsonString(buf, string(j.DiscoverySplash))
		buf.WriteByte(',')
	}
	if j.Owner != false {
		if j.Owner {
			buf.WriteString(`"owner":true`)
		} else {
			buf.WriteString(`"owner":false`)
		}
		buf.WriteByte(',')
	}
	if j.Widget != false {
		if j.Widget {
			buf.WriteString(`"widget_enabled":true`)
		} else {
			buf.WriteString(`"widget_enabled":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"system_channel_flags":`)
	fflib.FormatBits2(buf, uint64(j.SystemChannelFlags), 10, false)
	buf.WriteString(`,"verification_level":`)

	{

		obj, err = j.Verification.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"default_message_notifications":`)

	{

		obj, err = j.Notification.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"explicit_content_filter":`)

	{

		obj, err = j.ExplicitFilter.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"premium_tier":`)
	fflib.FormatBits2(buf, uint64(j.NitroBoost), 10, false)
	buf.WriteString(`,"mfa_level":`)
	fflib.FormatBits2(buf, uint64(j.MFA), 10, false)
	buf.WriteString(`,"owner_id":`)

	{

		obj, err = j.OwnerID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.WidgetChannelID != 0 {
		buf.WriteString(`"widget_channel_id":`)

		{

			obj, err = j.WidgetChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.SystemChannelID != 0 {
		buf.WriteString(`"system_channel_id":`)

		{

			obj, err = j.SystemChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Permissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.Permissions), 10, false)
		buf.WriteString(`",`)
	}
	buf.WriteString(`"region":`)
	fflib.WriteJsonString(buf, string(j.VoiceRegion))
	buf.WriteByte(',')
	if j.AFKChannelID != 0 {
		buf.WriteString(`"afk_channel_id":`)

		{

			obj, err = j.AFKChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"afk_timeout":`)

	{

		obj, err = j.AFKTimeout.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"roles":`)
	if j.Roles != nil {
		buf.WriteString(`[`)
		for i, v := range j.Roles {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"emojis":`)
	if j.Emojis != nil {
		buf.WriteString(`[`)
		for i, v := range j.Emojis {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Struct fall back. type=discord.Emoji kind=struct */
			err = buf.Encode(&v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"features":`)
	if j.Features != nil {
		buf.WriteString(`[`)
		for i, v := range j.Features {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"rules_channel_id":`)

	{

		obj, err = j.RulesChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.MaxPresences != 0 {
		buf.WriteString(`"max_presences":`)
		fflib.FormatBits2(buf, uint64(j.MaxPresences), 10, false)
		buf.WriteByte(',')
	}
	if j.MaxMembers != 0 {
		buf.WriteString(`"max_members":`)
		fflib.FormatBits2(buf, uint64(j.MaxMembers), 10, false)
		buf.WriteByte(',')
	}
	if len(j.VanityURLCode) != 0 {
		buf.WriteString(`"vanity_url_code":`)
		fflib.WriteJsonString(buf, string(j.VanityURLCode))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Banner) != 0 {
		buf.WriteString(`"banner":`)
		fflib.WriteJsonString(buf, string(j.Banner))
		buf.WriteByte(',')
	}
	if j.NitroBoosters != 0 {
		buf.WriteString(`"premium_subscription_count":`)
		fflib.FormatBits2(buf, uint64(j.NitroBoosters), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"preferred_locale":`)
	fflib.WriteJsonString(buf, string(j.PreferredLocale))
	buf.WriteString(`,"public_updates_channel_id":`)

	{

		obj, err = j.PublicUpdatesChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.MaxVideoChannelUsers != 0 {
		buf.WriteString(`"max_video_channel_users":`)
		fflib.FormatBits2(buf, uint64(j.MaxVideoChannelUsers), 10, false)
		buf.WriteByte(',')
	}
	if j.ApproximateMembers != 0 {
		buf.WriteString(`"approximate_member_count":`)
		fflib.FormatBits2(buf, uint64(j.ApproximateMembers), 10, false)
		buf.WriteByte(',')
	}
	if j.ApproximatePresences != 0 {
		buf.WriteString(`"approximate_presence_count":`)
		fflib.FormatBits2(buf, uint64(j.ApproximatePresences), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"nsfw_level":`)
	fflib.FormatBits2(buf, uint64(j.NSFWLevel), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildbase = iota
	ffjtGuildnosuchkey

	ffjtGuildID

	ffjtGuildName

	ffjtGuildIcon

	ffjtGuildSplash

	ffjtGuildDiscoverySplash

	ffjtGuildOwner

	ffjtGuildWidget

	ffjtGuildSystemChannelFlags

	ffjtGuildVerification

	ffjtGuildNotification

	ffjtGuildExplicitFilter

	ffjtGuildNitroBoost

	ffjtGuildMFA

	ffjtGuildOwnerID

	ffjtGuildWidgetChannelID

	ffjtGuildSystemChannelID

	ffjtGuildPermissions

	ffjtGuildVoiceRegion

	ffjtGuildAFKChannelID

	ffjtGuildAFKTimeout

	ffjtGuildRoles

	ffjtGuildEmojis

	ffjtGuildFeatures

	ffjtGuildAppID

	ffjtGuildRulesChannelID

	ffjtGuildMaxPresences

	ffjtGuildMaxMembers

	ffjtGuildVanityURLCode

	ffjtGuildDescription

	ffjtGuildBanner

	ffjtGuildNitroBoosters

	ffjtGuildPreferredLocale

	ffjtGuildPublicUpdatesChannelID

	ffjtGuildMaxVideoChannelUsers

	ffjtGuildApproximateMembers

	ffjtGuildApproximatePresences

	ffjtGuildNSFWLevel
)

var ffjKeyGuildID = []byte("id")

var ffjKeyGuildName = []byte("name")

var ffjKeyGuildIcon = []byte("icon")

var ffjKeyGuildSplash = []byte("splash")

var ffjKeyGuildDiscoverySplash = []byte("discovery_splash")

var ffjKeyGuildOwner = []byte("owner")

var ffjKeyGuildWidget = []byte("widget_enabled")

var ffjKeyGuildSystemChannelFlags = []byte("system_channel_flags")

var ffjKeyGuildVerification = []byte("verification_level")

var ffjKeyGuildNotification = []byte("default_message_notifications")

var ffjKeyGuildExplicitFilter = []byte("explicit_content_filter")

var ffjKeyGuildNitroBoost = []byte("premium_tier")

var ffjKeyGuildMFA = []byte("mfa_level")

var ffjKeyGuildOwnerID = []byte("owner_id")

var ffjKeyGuildWidgetChannelID = []byte("widget_channel_id")

var ffjKeyGuildSystemChannelID = []byte("system_channel_id")

var ffjKeyGuildPermissions = []byte("permissions")

var ffjKeyGuildVoiceRegion = []byte("region")

var ffjKeyGuildAFKChannelID = []byte("afk_channel_id")

var ffjKeyGuildAFKTimeout = []byte("afk_timeout")

var ffjKeyGuildRoles = []byte("roles")

var ffjKeyGuildEmojis = []byte("emojis")

var ffjKeyGuildFeatures = []byte("features")

var ffjKeyGuildAppID = []byte("application_id")

var ffjKeyGuildRulesChannelID = []byte("rules_channel_id")

var ffjKeyGuildMaxPresences = []byte("max_presences")

var ffjKeyGuildMaxMembers = []byte("max_members")

var ffjKeyGuildVanityURLCode = []byte("vanity_url_code")

var ffjKeyGuildDescription = []byte("description")

var ffjKeyGuildBanner = []byte("banner")

var ffjKeyGuildNitroBoosters = []byte("premium_subscription_count")

var ffjKeyGuildPreferredLocale = []byte("preferred_locale")

var ffjKeyGuildPublicUpdatesChannelID = []byte("public_updates_channel_id")

var ffjKeyGuildMaxVideoChannelUsers = []byte("max_video_channel_users")

var ffjKeyGuildApproximateMembers = []byte("approximate_member_count")

var ffjKeyGuildApproximatePresences = []byte("approximate_presence_count")

var ffjKeyGuildNSFWLevel = []byte("nsfw_level")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Guild) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Guild) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildAFKChannelID, kn) {
						currentKey = ffjtGuildAFKChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildAFKTimeout, kn) {
						currentKey = ffjtGuildAFKTimeout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildAppID, kn) {
						currentKey = ffjtGuildAppID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildApproximateMembers, kn) {
						currentKey = ffjtGuildApproximateMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildApproximatePresences, kn) {
						currentKey = ffjtGuildApproximatePresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyGuildBanner, kn) {
						currentKey = ffjtGuildBanner
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildDiscoverySplash, kn) {
						currentKey = ffjtGuildDiscoverySplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildNotification, kn) {
						currentKey = ffjtGuildNotification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildDescription, kn) {
						currentKey = ffjtGuildDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildExplicitFilter, kn) {
						currentKey = ffjtGuildExplicitFilter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildEmojis, kn) {
						currentKey = ffjtGuildEmojis
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyGuildFeatures, kn) {
						currentKey = ffjtGuildFeatures
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildID, kn) {
						currentKey = ffjtGuildID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildIcon, kn) {
						currentKey = ffjtGuildIcon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildMFA, kn) {
						currentKey = ffjtGuildMFA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMaxPresences, kn) {
						currentKey = ffjtGuildMaxPresences
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMaxMembers, kn) {
						currentKey = ffjtGuildMaxMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMaxVideoChannelUsers, kn) {
						currentKey = ffjtGuildMaxVideoChannelUsers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildName, kn) {
						currentKey = ffjtGuildName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildNSFWLevel, kn) {
						currentKey = ffjtGuildNSFWLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyGuildOwner, kn) {
						currentKey = ffjtGuildOwner
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildOwnerID, kn) {
						currentKey = ffjtGuildOwnerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildNitroBoost, kn) {
						currentKey = ffjtGuildNitroBoost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildPermissions, kn) {
						currentKey = ffjtGuildPermissions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildNitroBoosters, kn) {
						currentKey = ffjtGuildNitroBoosters
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildPreferredLocale, kn) {
						currentKey = ffjtGuildPreferredLocale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildPublicUpdatesChannelID, kn) {
						currentKey = ffjtGuildPublicUpdatesChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildVoiceRegion, kn) {
						currentKey = ffjtGuildVoiceRegion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildRoles, kn) {
						currentKey = ffjtGuildRoles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildRulesChannelID, kn) {
						currentKey = ffjtGuildRulesChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildSplash, kn) {
						currentKey = ffjtGuildSplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildSystemChannelFlags, kn) {
						currentKey = ffjtGuildSystemChannelFlags
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildSystemChannelID, kn) {
						currentKey = ffjtGuildSystemChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyGuildVerification, kn) {
						currentKey = ffjtGuildVerification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildVanityURLCode, kn) {
						currentKey = ffjtGuildVanityURLCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyGuildWidget, kn) {
						currentKey = ffjtGuildWidget
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildWidgetChannelID, kn) {
						currentKey = ffjtGuildWidgetChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildNSFWLevel, kn) {
					currentKey = ffjtGuildNSFWLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildApproximatePresences, kn) {
					currentKey = ffjtGuildApproximatePresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildApproximateMembers, kn) {
					currentKey = ffjtGuildApproximateMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMaxVideoChannelUsers, kn) {
					currentKey = ffjtGuildMaxVideoChannelUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPublicUpdatesChannelID, kn) {
					currentKey = ffjtGuildPublicUpdatesChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildPreferredLocale, kn) {
					currentKey = ffjtGuildPreferredLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildNitroBoosters, kn) {
					currentKey = ffjtGuildNitroBoosters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildBanner, kn) {
					currentKey = ffjtGuildBanner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildDescription, kn) {
					currentKey = ffjtGuildDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildVanityURLCode, kn) {
					currentKey = ffjtGuildVanityURLCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMaxMembers, kn) {
					currentKey = ffjtGuildMaxMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMaxPresences, kn) {
					currentKey = ffjtGuildMaxPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildRulesChannelID, kn) {
					currentKey = ffjtGuildRulesChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildAppID, kn) {
					currentKey = ffjtGuildAppID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildFeatures, kn) {
					currentKey = ffjtGuildFeatures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildEmojis, kn) {
					currentKey = ffjtGuildEmojis
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildRoles, kn) {
					currentKey = ffjtGuildRoles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildAFKTimeout, kn) {
					currentKey = ffjtGuildAFKTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildAFKChannelID, kn) {
					currentKey = ffjtGuildAFKChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildVoiceRegion, kn) {
					currentKey = ffjtGuildVoiceRegion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPermissions, kn) {
					currentKey = ffjtGuildPermissions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildSystemChannelID, kn) {
					currentKey = ffjtGuildSystemChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildWidgetChannelID, kn) {
					currentKey = ffjtGuildWidgetChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildOwnerID, kn) {
					currentKey = ffjtGuildOwnerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMFA, kn) {
					currentKey = ffjtGuildMFA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildNitroBoost, kn) {
					currentKey = ffjtGuildNitroBoost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildExplicitFilter, kn) {
					currentKey = ffjtGuildExplicitFilter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildNotification, kn) {
					currentKey = ffjtGuildNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildVerification, kn) {
					currentKey = ffjtGuildVerification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildSystemChannelFlags, kn) {
					currentKey = ffjtGuildSystemChannelFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildWidget, kn) {
					currentKey = ffjtGuildWidget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildOwner, kn) {
					currentKey = ffjtGuildOwner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildDiscoverySplash, kn) {
					currentKey = ffjtGuildDiscoverySplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildSplash, kn) {
					currentKey = ffjtGuildSplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildIcon, kn) {
					currentKey = ffjtGuildIcon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildName, kn) {
					currentKey = ffjtGuildName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildID, kn) {
					currentKey = ffjtGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildID:
					goto handle_ID

				case ffjtGuildName:
					goto handle_Name

				case ffjtGuildIcon:
					goto handle_Icon

				case ffjtGuildSplash:
					goto handle_Splash

				case ffjtGuildDiscoverySplash:
					goto handle_DiscoverySplash

				case ffjtGuildOwner:
					goto handle_Owner

				case ffjtGuildWidget:
					goto handle_Widget

				case ffjtGuildSystemChannelFlags:
					goto handle_SystemChannelFlags

				case ffjtGuildVerification:
					goto handle_Verification

				case ffjtGuildNotification:
					goto handle_Notification

				case ffjtGuildExplicitFilter:
					goto handle_ExplicitFilter

				case ffjtGuildNitroBoost:
					goto handle_NitroBoost

				case ffjtGuildMFA:
					goto handle_MFA

				case ffjtGuildOwnerID:
					goto handle_OwnerID

				case ffjtGuildWidgetChannelID:
					goto handle_WidgetChannelID

				case ffjtGuildSystemChannelID:
					goto handle_SystemChannelID

				case ffjtGuildPermissions:
					goto handle_Permissions

				case ffjtGuildVoiceRegion:
					goto handle_VoiceRegion

				case ffjtGuildAFKChannelID:
					goto handle_AFKChannelID

				case ffjtGuildAFKTimeout:
					goto handle_AFKTimeout

				case ffjtGuildRoles:
					goto handle_Roles

				case ffjtGuildEmojis:
					goto handle_Emojis

				case ffjtGuildFeatures:
					goto handle_Features

				case ffjtGuildAppID:
					goto handle_AppID

				case ffjtGuildRulesChannelID:
					goto handle_RulesChannelID

				case ffjtGuildMaxPresences:
					goto handle_MaxPresences

				case ffjtGuildMaxMembers:
					goto handle_MaxMembers

				case ffjtGuildVanityURLCode:
					goto handle_VanityURLCode

				case ffjtGuildDescription:
					goto handle_Description

				case ffjtGuildBanner:
					goto handle_Banner

				case ffjtGuildNitroBoosters:
					goto handle_NitroBoosters

				case ffjtGuildPreferredLocale:
					goto handle_PreferredLocale

				case ffjtGuildPublicUpdatesChannelID:
					goto handle_PublicUpdatesChannelID

				case ffjtGuildMaxVideoChannelUsers:
					goto handle_MaxVideoChannelUsers

				case ffjtGuildApproximateMembers:
					goto handle_ApproximateMembers

				case ffjtGuildApproximatePresences:
					goto handle_ApproximatePresences

				case ffjtGuildNSFWLevel:
					goto handle_NSFWLevel

				case ffjtGuildnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icon:

	/* handler: j.Icon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Icon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Splash:

	/* handler: j.Splash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Splash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiscoverySplash:

	/* handler: j.DiscoverySplash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DiscoverySplash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Owner:

	/* handler: j.Owner type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Owner = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Owner = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Widget:

	/* handler: j.Widget type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Widget = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Widget = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemChannelFlags:

	/* handler: j.SystemChannelFlags type=discord.SystemChannelFlags kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for SystemChannelFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SystemChannelFlags = SystemChannelFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Verification:

	/* handler: j.Verification type=discord.Verification kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Verification.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notification:

	/* handler: j.Notification type=discord.Notification kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Notification.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExplicitFilter:

	/* handler: j.ExplicitFilter type=discord.ExplicitFilter kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ExplicitFilter.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NitroBoost:

	/* handler: j.NitroBoost type=discord.NitroBoost kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NitroBoost", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NitroBoost = NitroBoost(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MFA:

	/* handler: j.MFA type=discord.MFALevel kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MFALevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MFA = MFALevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerID:

	/* handler: j.OwnerID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.OwnerID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WidgetChannelID:

	/* handler: j.WidgetChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WidgetChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemChannelID:

	/* handler: j.SystemChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.SystemChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Permissions:

	/* handler: j.Permissions type=discord.Permissions kind=uint64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Permissions", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Permissions = Permissions(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceRegion:

	/* handler: j.VoiceRegion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VoiceRegion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFKChannelID:

	/* handler: j.AFKChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AFKChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFKTimeout:

	/* handler: j.AFKTimeout type=discord.Seconds kind=int quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AFKTimeout.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Roles:

	/* handler: j.Roles type=[]discord.Role kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Roles = nil
		} else {

			j.Roles = []Role{}

			wantVal := true

			for {

				var tmpJRoles Role

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoles type=discord.Role kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJRoles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Roles = append(j.Roles, tmpJRoles)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emojis:

	/* handler: j.Emojis type=[]discord.Emoji kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Emojis = nil
		} else {

			j.Emojis = []Emoji{}

			wantVal := true

			for {

				var tmpJEmojis Emoji

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmojis type=discord.Emoji kind=struct quoted=false*/

				{
					/* Falling back. type=discord.Emoji kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJEmojis)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Emojis = append(j.Emojis, tmpJEmojis)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Features:

	/* handler: j.Features type=[]discord.GuildFeature kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Features = nil
		} else {

			j.Features = []GuildFeature{}

			wantVal := true

			for {

				var tmpJFeatures GuildFeature

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFeatures type=discord.GuildFeature kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for GuildFeature", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJFeatures = GuildFeature(string(outBuf))

					}
				}

				j.Features = append(j.Features, tmpJFeatures)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppID:

	/* handler: j.AppID type=discord.AppID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AppID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RulesChannelID:

	/* handler: j.RulesChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.RulesChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxPresences:

	/* handler: j.MaxPresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxPresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxMembers:

	/* handler: j.MaxMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VanityURLCode:

	/* handler: j.VanityURLCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VanityURLCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Banner:

	/* handler: j.Banner type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Banner = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NitroBoosters:

	/* handler: j.NitroBoosters type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NitroBoosters = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreferredLocale:

	/* handler: j.PreferredLocale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PreferredLocale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PublicUpdatesChannelID:

	/* handler: j.PublicUpdatesChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.PublicUpdatesChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxVideoChannelUsers:

	/* handler: j.MaxVideoChannelUsers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxVideoChannelUsers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximateMembers:

	/* handler: j.ApproximateMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximateMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximatePresences:

	/* handler: j.ApproximatePresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximatePresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NSFWLevel:

	/* handler: j.NSFWLevel type=discord.NSFWLevel kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NSFWLevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NSFWLevel = NSFWLevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildPreview) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildPreview) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"icon":`)
	fflib.WriteJsonString(buf, string(j.Icon))
	buf.WriteString(`,"splash":`)
	fflib.WriteJsonString(buf, string(j.Splash))
	buf.WriteString(`,"discovery_splash":`)
	fflib.WriteJsonString(buf, string(j.DiscoverySplash))
	buf.WriteString(`,"emojis":`)
	if j.Emojis != nil {
		buf.WriteString(`[`)
		for i, v := range j.Emojis {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Struct fall back. type=discord.Emoji kind=struct */
			err = buf.Encode(&v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"guild_features":`)
	if j.Features != nil {
		buf.WriteString(`[`)
		for i, v := range j.Features {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"approximate_member_count":`)
	fflib.FormatBits2(buf, uint64(j.ApproximateMembers), 10, false)
	buf.WriteString(`,"approximate_presence_count":`)
	fflib.FormatBits2(buf, uint64(j.ApproximatePresences), 10, false)
	buf.WriteByte(',')
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildPreviewbase = iota
	ffjtGuildPreviewnosuchkey

	ffjtGuildPreviewID

	ffjtGuildPreviewName

	ffjtGuildPreviewIcon

	ffjtGuildPreviewSplash

	ffjtGuildPreviewDiscoverySplash

	ffjtGuildPreviewEmojis

	ffjtGuildPreviewFeatures

	ffjtGuildPreviewApproximateMembers

	ffjtGuildPreviewApproximatePresences

	ffjtGuildPreviewDescription
)

var ffjKeyGuildPreviewID = []byte("id")

var ffjKeyGuildPreviewName = []byte("name")

var ffjKeyGuildPreviewIcon = []byte("icon")

var ffjKeyGuildPreviewSplash = []byte("splash")

var ffjKeyGuildPreviewDiscoverySplash = []byte("discovery_splash")

var ffjKeyGuildPreviewEmojis = []byte("emojis")

var ffjKeyGuildPreviewFeatures = []byte("guild_features")

var ffjKeyGuildPreviewApproximateMembers = []byte("approximate_member_count")

var ffjKeyGuildPreviewApproximatePresences = []byte("approximate_presence_count")

var ffjKeyGuildPreviewDescription = []byte("description")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildPreview) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildPreview) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildPreviewbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildPreviewnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildPreviewApproximateMembers, kn) {
						currentKey = ffjtGuildPreviewApproximateMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildPreviewApproximatePresences, kn) {
						currentKey = ffjtGuildPreviewApproximatePresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildPreviewDiscoverySplash, kn) {
						currentKey = ffjtGuildPreviewDiscoverySplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildPreviewDescription, kn) {
						currentKey = ffjtGuildPreviewDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildPreviewEmojis, kn) {
						currentKey = ffjtGuildPreviewEmojis
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildPreviewFeatures, kn) {
						currentKey = ffjtGuildPreviewFeatures
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildPreviewID, kn) {
						currentKey = ffjtGuildPreviewID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildPreviewIcon, kn) {
						currentKey = ffjtGuildPreviewIcon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildPreviewName, kn) {
						currentKey = ffjtGuildPreviewName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildPreviewSplash, kn) {
						currentKey = ffjtGuildPreviewSplash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildPreviewDescription, kn) {
					currentKey = ffjtGuildPreviewDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPreviewApproximatePresences, kn) {
					currentKey = ffjtGuildPreviewApproximatePresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildPreviewApproximateMembers, kn) {
					currentKey = ffjtGuildPreviewApproximateMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPreviewFeatures, kn) {
					currentKey = ffjtGuildPreviewFeatures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPreviewEmojis, kn) {
					currentKey = ffjtGuildPreviewEmojis
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPreviewDiscoverySplash, kn) {
					currentKey = ffjtGuildPreviewDiscoverySplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildPreviewSplash, kn) {
					currentKey = ffjtGuildPreviewSplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildPreviewIcon, kn) {
					currentKey = ffjtGuildPreviewIcon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildPreviewName, kn) {
					currentKey = ffjtGuildPreviewName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildPreviewID, kn) {
					currentKey = ffjtGuildPreviewID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildPreviewnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildPreviewID:
					goto handle_ID

				case ffjtGuildPreviewName:
					goto handle_Name

				case ffjtGuildPreviewIcon:
					goto handle_Icon

				case ffjtGuildPreviewSplash:
					goto handle_Splash

				case ffjtGuildPreviewDiscoverySplash:
					goto handle_DiscoverySplash

				case ffjtGuildPreviewEmojis:
					goto handle_Emojis

				case ffjtGuildPreviewFeatures:
					goto handle_Features

				case ffjtGuildPreviewApproximateMembers:
					goto handle_ApproximateMembers

				case ffjtGuildPreviewApproximatePresences:
					goto handle_ApproximatePresences

				case ffjtGuildPreviewDescription:
					goto handle_Description

				case ffjtGuildPreviewnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icon:

	/* handler: j.Icon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Icon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Splash:

	/* handler: j.Splash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Splash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiscoverySplash:

	/* handler: j.DiscoverySplash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DiscoverySplash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emojis:

	/* handler: j.Emojis type=[]discord.Emoji kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Emojis = nil
		} else {

			j.Emojis = []Emoji{}

			wantVal := true

			for {

				var tmpJEmojis Emoji

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmojis type=discord.Emoji kind=struct quoted=false*/

				{
					/* Falling back. type=discord.Emoji kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJEmojis)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Emojis = append(j.Emojis, tmpJEmojis)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Features:

	/* handler: j.Features type=[]discord.GuildFeature kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Features = nil
		} else {

			j.Features = []GuildFeature{}

			wantVal := true

			for {

				var tmpJFeatures GuildFeature

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFeatures type=discord.GuildFeature kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for GuildFeature", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJFeatures = GuildFeature(string(outBuf))

					}
				}

				j.Features = append(j.Features, tmpJFeatures)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximateMembers:

	/* handler: j.ApproximateMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximateMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximatePresences:

	/* handler: j.ApproximatePresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximatePresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildWidget) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildWidget) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"instant_invite":`)
	fflib.WriteJsonString(buf, string(j.InviteURL))
	buf.WriteString(`,"channels":`)
	if j.Channels != nil {
		buf.WriteString(`[`)
		for i, v := range j.Channels {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Struct fall back. type=discord.Channel kind=struct */
			err = buf.Encode(&v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"members":`)
	if j.Members != nil {
		buf.WriteString(`[`)
		for i, v := range j.Members {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"presence_count":`)
	fflib.FormatBits2(buf, uint64(j.PresenceCount), 10, j.PresenceCount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildWidgetbase = iota
	ffjtGuildWidgetnosuchkey

	ffjtGuildWidgetID

	ffjtGuildWidgetName

	ffjtGuildWidgetInviteURL

	ffjtGuildWidgetChannels

	ffjtGuildWidgetMembers

	ffjtGuildWidgetPresenceCount
)

var ffjKeyGuildWidgetID = []byte("id")

var ffjKeyGuildWidgetName = []byte("name")

var ffjKeyGuildWidgetInviteURL = []byte("instant_invite")

var ffjKeyGuildWidgetChannels = []byte("channels")

var ffjKeyGuildWidgetMembers = []byte("members")

var ffjKeyGuildWidgetPresenceCount = []byte("presence_count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildWidget) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildWidget) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildWidgetbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildWidgetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildWidgetChannels, kn) {
						currentKey = ffjtGuildWidgetChannels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildWidgetID, kn) {
						currentKey = ffjtGuildWidgetID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildWidgetInviteURL, kn) {
						currentKey = ffjtGuildWidgetInviteURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildWidgetMembers, kn) {
						currentKey = ffjtGuildWidgetMembers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildWidgetName, kn) {
						currentKey = ffjtGuildWidgetName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildWidgetPresenceCount, kn) {
						currentKey = ffjtGuildWidgetPresenceCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildWidgetPresenceCount, kn) {
					currentKey = ffjtGuildWidgetPresenceCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildWidgetMembers, kn) {
					currentKey = ffjtGuildWidgetMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildWidgetChannels, kn) {
					currentKey = ffjtGuildWidgetChannels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildWidgetInviteURL, kn) {
					currentKey = ffjtGuildWidgetInviteURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildWidgetName, kn) {
					currentKey = ffjtGuildWidgetName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildWidgetID, kn) {
					currentKey = ffjtGuildWidgetID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildWidgetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildWidgetID:
					goto handle_ID

				case ffjtGuildWidgetName:
					goto handle_Name

				case ffjtGuildWidgetInviteURL:
					goto handle_InviteURL

				case ffjtGuildWidgetChannels:
					goto handle_Channels

				case ffjtGuildWidgetMembers:
					goto handle_Members

				case ffjtGuildWidgetPresenceCount:
					goto handle_PresenceCount

				case ffjtGuildWidgetnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InviteURL:

	/* handler: j.InviteURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InviteURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Channels:

	/* handler: j.Channels type=[]discord.Channel kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Channels = nil
		} else {

			j.Channels = []Channel{}

			wantVal := true

			for {

				var tmpJChannels Channel

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChannels type=discord.Channel kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJChannels.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Channels = append(j.Channels, tmpJChannels)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Members:

	/* handler: j.Members type=[]discord.User kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Members = nil
		} else {

			j.Members = []User{}

			wantVal := true

			for {

				var tmpJMembers User

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMembers type=discord.User kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Members = append(j.Members, tmpJMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PresenceCount:

	/* handler: j.PresenceCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PresenceCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildWidgetSettings) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildWidgetSettings) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Enabled {
		buf.WriteString(`{ "enabled":true`)
	} else {
		buf.WriteString(`{ "enabled":false`)
	}
	buf.WriteByte(',')
	if j.ChannelID != 0 {
		buf.WriteString(`"channel_id":`)

		{

			obj, err = j.ChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildWidgetSettingsbase = iota
	ffjtGuildWidgetSettingsnosuchkey

	ffjtGuildWidgetSettingsEnabled

	ffjtGuildWidgetSettingsChannelID
)

var ffjKeyGuildWidgetSettingsEnabled = []byte("enabled")

var ffjKeyGuildWidgetSettingsChannelID = []byte("channel_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildWidgetSettings) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildWidgetSettings) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildWidgetSettingsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildWidgetSettingsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildWidgetSettingsChannelID, kn) {
						currentKey = ffjtGuildWidgetSettingsChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildWidgetSettingsEnabled, kn) {
						currentKey = ffjtGuildWidgetSettingsEnabled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyGuildWidgetSettingsChannelID, kn) {
					currentKey = ffjtGuildWidgetSettingsChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildWidgetSettingsEnabled, kn) {
					currentKey = ffjtGuildWidgetSettingsEnabled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildWidgetSettingsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildWidgetSettingsEnabled:
					goto handle_Enabled

				case ffjtGuildWidgetSettingsChannelID:
					goto handle_ChannelID

				case ffjtGuildWidgetSettingsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Enabled:

	/* handler: j.Enabled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Enabled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Enabled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Integration) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Integration) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	if j.Enabled {
		buf.WriteString(`,"enabled":true`)
	} else {
		buf.WriteString(`,"enabled":false`)
	}
	buf.WriteByte(',')
	if j.Syncing != false {
		if j.Syncing {
			buf.WriteString(`"syncing":true`)
		} else {
			buf.WriteString(`"syncing":false`)
		}
		buf.WriteByte(',')
	}
	if j.RoleID != 0 {
		buf.WriteString(`"role_id":`)

		{

			obj, err = j.RoleID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.EnableEmoticons != false {
		if j.EnableEmoticons {
			buf.WriteString(`"enable_emoticons":true`)
		} else {
			buf.WriteString(`"enable_emoticons":false`)
		}
		buf.WriteByte(',')
	}
	if j.ExpireBehavior != 0 {
		buf.WriteString(`"expire_behavior":`)
		fflib.FormatBits2(buf, uint64(j.ExpireBehavior), 10, false)
		buf.WriteByte(',')
	}
	if j.ExpireGracePeriod != 0 {
		buf.WriteString(`"expire_grace_period":`)
		fflib.FormatBits2(buf, uint64(j.ExpireGracePeriod), 10, j.ExpireGracePeriod < 0)
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"account":`)

	{

		err = j.Account.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"synced_at":`)

		{

			obj, err = j.SyncedAt.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.SubscriberCount != 0 {
		buf.WriteString(`"subscriber_count":`)
		fflib.FormatBits2(buf, uint64(j.SubscriberCount), 10, j.SubscriberCount < 0)
		buf.WriteByte(',')
	}
	if j.Revoked != false {
		if j.Revoked {
			buf.WriteString(`"revoked":true`)
		} else {
			buf.WriteString(`"revoked":false`)
		}
		buf.WriteByte(',')
	}
	if j.Application != nil {
		if true {
			buf.WriteString(`"application":`)

			{

				err = j.Application.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtIntegrationbase = iota
	ffjtIntegrationnosuchkey

	ffjtIntegrationID

	ffjtIntegrationName

	ffjtIntegrationType

	ffjtIntegrationEnabled

	ffjtIntegrationSyncing

	ffjtIntegrationRoleID

	ffjtIntegrationEnableEmoticons

	ffjtIntegrationExpireBehavior

	ffjtIntegrationExpireGracePeriod

	ffjtIntegrationUser

	ffjtIntegrationAccount

	ffjtIntegrationSyncedAt

	ffjtIntegrationSubscriberCount

	ffjtIntegrationRevoked

	ffjtIntegrationApplication
)

var ffjKeyIntegrationID = []byte("id")

var ffjKeyIntegrationName = []byte("name")

var ffjKeyIntegrationType = []byte("type")

var ffjKeyIntegrationEnabled = []byte("enabled")

var ffjKeyIntegrationSyncing = []byte("syncing")

var ffjKeyIntegrationRoleID = []byte("role_id")

var ffjKeyIntegrationEnableEmoticons = []byte("enable_emoticons")

var ffjKeyIntegrationExpireBehavior = []byte("expire_behavior")

var ffjKeyIntegrationExpireGracePeriod = []byte("expire_grace_period")

var ffjKeyIntegrationUser = []byte("user")

var ffjKeyIntegrationAccount = []byte("account")

var ffjKeyIntegrationSyncedAt = []byte("synced_at")

var ffjKeyIntegrationSubscriberCount = []byte("subscriber_count")

var ffjKeyIntegrationRevoked = []byte("revoked")

var ffjKeyIntegrationApplication = []byte("application")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Integration) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Integration) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtIntegrationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtIntegrationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyIntegrationAccount, kn) {
						currentKey = ffjtIntegrationAccount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationApplication, kn) {
						currentKey = ffjtIntegrationApplication
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyIntegrationEnabled, kn) {
						currentKey = ffjtIntegrationEnabled
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationEnableEmoticons, kn) {
						currentKey = ffjtIntegrationEnableEmoticons
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationExpireBehavior, kn) {
						currentKey = ffjtIntegrationExpireBehavior
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationExpireGracePeriod, kn) {
						currentKey = ffjtIntegrationExpireGracePeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyIntegrationID, kn) {
						currentKey = ffjtIntegrationID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyIntegrationName, kn) {
						currentKey = ffjtIntegrationName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyIntegrationRoleID, kn) {
						currentKey = ffjtIntegrationRoleID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationRevoked, kn) {
						currentKey = ffjtIntegrationRevoked
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyIntegrationSyncing, kn) {
						currentKey = ffjtIntegrationSyncing
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationSyncedAt, kn) {
						currentKey = ffjtIntegrationSyncedAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationSubscriberCount, kn) {
						currentKey = ffjtIntegrationSubscriberCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyIntegrationType, kn) {
						currentKey = ffjtIntegrationType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyIntegrationUser, kn) {
						currentKey = ffjtIntegrationUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationApplication, kn) {
					currentKey = ffjtIntegrationApplication
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationRevoked, kn) {
					currentKey = ffjtIntegrationRevoked
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationSubscriberCount, kn) {
					currentKey = ffjtIntegrationSubscriberCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationSyncedAt, kn) {
					currentKey = ffjtIntegrationSyncedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationAccount, kn) {
					currentKey = ffjtIntegrationAccount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationUser, kn) {
					currentKey = ffjtIntegrationUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIntegrationExpireGracePeriod, kn) {
					currentKey = ffjtIntegrationExpireGracePeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIntegrationExpireBehavior, kn) {
					currentKey = ffjtIntegrationExpireBehavior
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationEnableEmoticons, kn) {
					currentKey = ffjtIntegrationEnableEmoticons
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIntegrationRoleID, kn) {
					currentKey = ffjtIntegrationRoleID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationSyncing, kn) {
					currentKey = ffjtIntegrationSyncing
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationEnabled, kn) {
					currentKey = ffjtIntegrationEnabled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationType, kn) {
					currentKey = ffjtIntegrationType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationName, kn) {
					currentKey = ffjtIntegrationName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationID, kn) {
					currentKey = ffjtIntegrationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtIntegrationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtIntegrationID:
					goto handle_ID

				case ffjtIntegrationName:
					goto handle_Name

				case ffjtIntegrationType:
					goto handle_Type

				case ffjtIntegrationEnabled:
					goto handle_Enabled

				case ffjtIntegrationSyncing:
					goto handle_Syncing

				case ffjtIntegrationRoleID:
					goto handle_RoleID

				case ffjtIntegrationEnableEmoticons:
					goto handle_EnableEmoticons

				case ffjtIntegrationExpireBehavior:
					goto handle_ExpireBehavior

				case ffjtIntegrationExpireGracePeriod:
					goto handle_ExpireGracePeriod

				case ffjtIntegrationUser:
					goto handle_User

				case ffjtIntegrationAccount:
					goto handle_Account

				case ffjtIntegrationSyncedAt:
					goto handle_SyncedAt

				case ffjtIntegrationSubscriberCount:
					goto handle_SubscriberCount

				case ffjtIntegrationRevoked:
					goto handle_Revoked

				case ffjtIntegrationApplication:
					goto handle_Application

				case ffjtIntegrationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.IntegrationID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=discord.Service kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Service", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = Service(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Enabled:

	/* handler: j.Enabled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Enabled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Enabled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Syncing:

	/* handler: j.Syncing type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Syncing = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Syncing = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RoleID:

	/* handler: j.RoleID type=discord.RoleID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.RoleID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EnableEmoticons:

	/* handler: j.EnableEmoticons type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.EnableEmoticons = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.EnableEmoticons = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpireBehavior:

	/* handler: j.ExpireBehavior type=discord.ExpireBehavior kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ExpireBehavior", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExpireBehavior = ExpireBehavior(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpireGracePeriod:

	/* handler: j.ExpireGracePeriod type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExpireGracePeriod = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Account:

	/* handler: j.Account type=discord.IntegrationAccount kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Account.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SyncedAt:

	/* handler: j.SyncedAt type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.SyncedAt.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubscriberCount:

	/* handler: j.SubscriberCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SubscriberCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Revoked:

	/* handler: j.Revoked type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Revoked = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Revoked = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Application:

	/* handler: j.Application type=discord.IntegrationApplication kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Application = nil

		} else {

			if j.Application == nil {
				j.Application = new(IntegrationApplication)
			}

			err = j.Application.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *IntegrationAccount) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *IntegrationAccount) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtIntegrationAccountbase = iota
	ffjtIntegrationAccountnosuchkey

	ffjtIntegrationAccountID

	ffjtIntegrationAccountName
)

var ffjKeyIntegrationAccountID = []byte("id")

var ffjKeyIntegrationAccountName = []byte("name")

// UnmarshalJSON umarshall json - template of ffjson
func (j *IntegrationAccount) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *IntegrationAccount) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtIntegrationAccountbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtIntegrationAccountnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyIntegrationAccountID, kn) {
						currentKey = ffjtIntegrationAccountID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyIntegrationAccountName, kn) {
						currentKey = ffjtIntegrationAccountName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationAccountName, kn) {
					currentKey = ffjtIntegrationAccountName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationAccountID, kn) {
					currentKey = ffjtIntegrationAccountID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtIntegrationAccountnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtIntegrationAccountID:
					goto handle_ID

				case ffjtIntegrationAccountName:
					goto handle_Name

				case ffjtIntegrationAccountnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *IntegrationApplication) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *IntegrationApplication) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	if j.Icon != nil {
		buf.WriteString(`,"icon":`)
		fflib.WriteJsonString(buf, string(*j.Icon))
	} else {
		buf.WriteString(`,"icon":null`)
	}
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"summary":`)
	fflib.WriteJsonString(buf, string(j.Summary))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"bot":`)

		{

			err = j.Bot.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtIntegrationApplicationbase = iota
	ffjtIntegrationApplicationnosuchkey

	ffjtIntegrationApplicationID

	ffjtIntegrationApplicationName

	ffjtIntegrationApplicationIcon

	ffjtIntegrationApplicationDescription

	ffjtIntegrationApplicationSummary

	ffjtIntegrationApplicationBot
)

var ffjKeyIntegrationApplicationID = []byte("id")

var ffjKeyIntegrationApplicationName = []byte("name")

var ffjKeyIntegrationApplicationIcon = []byte("icon")

var ffjKeyIntegrationApplicationDescription = []byte("description")

var ffjKeyIntegrationApplicationSummary = []byte("summary")

var ffjKeyIntegrationApplicationBot = []byte("bot")

// UnmarshalJSON umarshall json - template of ffjson
func (j *IntegrationApplication) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *IntegrationApplication) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtIntegrationApplicationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtIntegrationApplicationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyIntegrationApplicationBot, kn) {
						currentKey = ffjtIntegrationApplicationBot
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyIntegrationApplicationDescription, kn) {
						currentKey = ffjtIntegrationApplicationDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyIntegrationApplicationID, kn) {
						currentKey = ffjtIntegrationApplicationID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIntegrationApplicationIcon, kn) {
						currentKey = ffjtIntegrationApplicationIcon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyIntegrationApplicationName, kn) {
						currentKey = ffjtIntegrationApplicationName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyIntegrationApplicationSummary, kn) {
						currentKey = ffjtIntegrationApplicationSummary
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationApplicationBot, kn) {
					currentKey = ffjtIntegrationApplicationBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationApplicationSummary, kn) {
					currentKey = ffjtIntegrationApplicationSummary
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIntegrationApplicationDescription, kn) {
					currentKey = ffjtIntegrationApplicationDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationApplicationIcon, kn) {
					currentKey = ffjtIntegrationApplicationIcon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationApplicationName, kn) {
					currentKey = ffjtIntegrationApplicationName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIntegrationApplicationID, kn) {
					currentKey = ffjtIntegrationApplicationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtIntegrationApplicationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtIntegrationApplicationID:
					goto handle_ID

				case ffjtIntegrationApplicationName:
					goto handle_Name

				case ffjtIntegrationApplicationIcon:
					goto handle_Icon

				case ffjtIntegrationApplicationDescription:
					goto handle_Description

				case ffjtIntegrationApplicationSummary:
					goto handle_Summary

				case ffjtIntegrationApplicationBot:
					goto handle_Bot

				case ffjtIntegrationApplicationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.IntegrationID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icon:

	/* handler: j.Icon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Icon = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Icon = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Summary:

	/* handler: j.Summary type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Summary = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bot:

	/* handler: j.Bot type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Bot.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Member) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Member) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if len(j.Nick) != 0 {
		buf.WriteString(`"nick":`)
		fflib.WriteJsonString(buf, string(j.Nick))
		buf.WriteByte(',')
	}
	buf.WriteString(`"roles":`)
	if j.RoleIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.RoleIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.Avatar) != 0 {
		buf.WriteString(`"avatar":`)
		fflib.WriteJsonString(buf, string(j.Avatar))
		buf.WriteByte(',')
	}
	buf.WriteString(`"joined_at":`)

	{

		obj, err = j.Joined.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"premium_since":`)

		{

			obj, err = j.BoostedSince.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"communication_disabled_until":`)

	{

		obj, err = j.CommunicationDisabledUntil.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Deaf {
		buf.WriteString(`,"deaf":true`)
	} else {
		buf.WriteString(`,"deaf":false`)
	}
	if j.Mute {
		buf.WriteString(`,"mute":true`)
	} else {
		buf.WriteString(`,"mute":false`)
	}
	buf.WriteString(`,"flags":`)
	fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
	if j.IsPending {
		buf.WriteString(`,"pending":true`)
	} else {
		buf.WriteString(`,"pending":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMemberbase = iota
	ffjtMembernosuchkey

	ffjtMemberUser

	ffjtMemberNick

	ffjtMemberRoleIDs

	ffjtMemberAvatar

	ffjtMemberJoined

	ffjtMemberBoostedSince

	ffjtMemberCommunicationDisabledUntil

	ffjtMemberDeaf

	ffjtMemberMute

	ffjtMemberFlags

	ffjtMemberIsPending
)

var ffjKeyMemberUser = []byte("user")

var ffjKeyMemberNick = []byte("nick")

var ffjKeyMemberRoleIDs = []byte("roles")

var ffjKeyMemberAvatar = []byte("avatar")

var ffjKeyMemberJoined = []byte("joined_at")

var ffjKeyMemberBoostedSince = []byte("premium_since")

var ffjKeyMemberCommunicationDisabledUntil = []byte("communication_disabled_until")

var ffjKeyMemberDeaf = []byte("deaf")

var ffjKeyMemberMute = []byte("mute")

var ffjKeyMemberFlags = []byte("flags")

var ffjKeyMemberIsPending = []byte("pending")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Member) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Member) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMemberAvatar, kn) {
						currentKey = ffjtMemberAvatar
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMemberCommunicationDisabledUntil, kn) {
						currentKey = ffjtMemberCommunicationDisabledUntil
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyMemberDeaf, kn) {
						currentKey = ffjtMemberDeaf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMemberFlags, kn) {
						currentKey = ffjtMemberFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffjKeyMemberJoined, kn) {
						currentKey = ffjtMemberJoined
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMemberMute, kn) {
						currentKey = ffjtMemberMute
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMemberNick, kn) {
						currentKey = ffjtMemberNick
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMemberBoostedSince, kn) {
						currentKey = ffjtMemberBoostedSince
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMemberIsPending, kn) {
						currentKey = ffjtMemberIsPending
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyMemberRoleIDs, kn) {
						currentKey = ffjtMemberRoleIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMemberUser, kn) {
						currentKey = ffjtMemberUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyMemberIsPending, kn) {
					currentKey = ffjtMemberIsPending
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMemberFlags, kn) {
					currentKey = ffjtMemberFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMemberMute, kn) {
					currentKey = ffjtMemberMute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMemberDeaf, kn) {
					currentKey = ffjtMemberDeaf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMemberCommunicationDisabledUntil, kn) {
					currentKey = ffjtMemberCommunicationDisabledUntil
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMemberBoostedSince, kn) {
					currentKey = ffjtMemberBoostedSince
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMemberJoined, kn) {
					currentKey = ffjtMemberJoined
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMemberAvatar, kn) {
					currentKey = ffjtMemberAvatar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMemberRoleIDs, kn) {
					currentKey = ffjtMemberRoleIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMemberNick, kn) {
					currentKey = ffjtMemberNick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMemberUser, kn) {
					currentKey = ffjtMemberUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMemberUser:
					goto handle_User

				case ffjtMemberNick:
					goto handle_Nick

				case ffjtMemberRoleIDs:
					goto handle_RoleIDs

				case ffjtMemberAvatar:
					goto handle_Avatar

				case ffjtMemberJoined:
					goto handle_Joined

				case ffjtMemberBoostedSince:
					goto handle_BoostedSince

				case ffjtMemberCommunicationDisabledUntil:
					goto handle_CommunicationDisabledUntil

				case ffjtMemberDeaf:
					goto handle_Deaf

				case ffjtMemberMute:
					goto handle_Mute

				case ffjtMemberFlags:
					goto handle_Flags

				case ffjtMemberIsPending:
					goto handle_IsPending

				case ffjtMembernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nick:

	/* handler: j.Nick type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nick = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RoleIDs:

	/* handler: j.RoleIDs type=[]discord.RoleID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RoleIDs = nil
		} else {

			j.RoleIDs = []RoleID{}

			wantVal := true

			for {

				var tmpJRoleIDs RoleID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoleIDs type=discord.RoleID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRoleIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RoleIDs = append(j.RoleIDs, tmpJRoleIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Avatar:

	/* handler: j.Avatar type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Avatar = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Joined:

	/* handler: j.Joined type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Joined.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BoostedSince:

	/* handler: j.BoostedSince type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BoostedSince.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommunicationDisabledUntil:

	/* handler: j.CommunicationDisabledUntil type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommunicationDisabledUntil.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deaf:

	/* handler: j.Deaf type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Deaf = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Deaf = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mute:

	/* handler: j.Mute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flags:

	/* handler: j.Flags type=discord.MemberFlags kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MemberFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Flags = MemberFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPending:

	/* handler: j.IsPending type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsPending = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsPending = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Presence) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Presence) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteString(`,"activities":`)
	if j.Activities != nil {
		buf.WriteString(`[`)
		for i, v := range j.Activities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"client_status":`)

	{

		err = j.ClientStatus.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPresencebase = iota
	ffjtPresencenosuchkey

	ffjtPresenceUser

	ffjtPresenceGuildID

	ffjtPresenceStatus

	ffjtPresenceActivities

	ffjtPresenceClientStatus
)

var ffjKeyPresenceUser = []byte("user")

var ffjKeyPresenceGuildID = []byte("guild_id")

var ffjKeyPresenceStatus = []byte("status")

var ffjKeyPresenceActivities = []byte("activities")

var ffjKeyPresenceClientStatus = []byte("client_status")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Presence) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Presence) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPresencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPresencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyPresenceActivities, kn) {
						currentKey = ffjtPresenceActivities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPresenceClientStatus, kn) {
						currentKey = ffjtPresenceClientStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyPresenceGuildID, kn) {
						currentKey = ffjtPresenceGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPresenceStatus, kn) {
						currentKey = ffjtPresenceStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyPresenceUser, kn) {
						currentKey = ffjtPresenceUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPresenceClientStatus, kn) {
					currentKey = ffjtPresenceClientStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPresenceActivities, kn) {
					currentKey = ffjtPresenceActivities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPresenceStatus, kn) {
					currentKey = ffjtPresenceStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPresenceGuildID, kn) {
					currentKey = ffjtPresenceGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPresenceUser, kn) {
					currentKey = ffjtPresenceUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPresencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPresenceUser:
					goto handle_User

				case ffjtPresenceGuildID:
					goto handle_GuildID

				case ffjtPresenceStatus:
					goto handle_Status

				case ffjtPresenceActivities:
					goto handle_Activities

				case ffjtPresenceClientStatus:
					goto handle_ClientStatus

				case ffjtPresencenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activities:

	/* handler: j.Activities type=[]discord.Activity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Activities = nil
		} else {

			j.Activities = []Activity{}

			wantVal := true

			for {

				var tmpJActivities Activity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActivities type=discord.Activity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJActivities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Activities = append(j.Activities, tmpJActivities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClientStatus:

	/* handler: j.ClientStatus type=discord.ClientStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.ClientStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Role) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Role) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"permissions":"`)
	fflib.FormatBits2(buf, uint64(j.Permissions), 10, false)
	buf.WriteString(`","position":`)
	fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
	buf.WriteString(`,"color":`)

	{

		obj, err = j.Color.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Hoist {
		buf.WriteString(`,"hoist":true`)
	} else {
		buf.WriteString(`,"hoist":false`)
	}
	if j.Managed {
		buf.WriteString(`,"managed":true`)
	} else {
		buf.WriteString(`,"managed":false`)
	}
	if j.Mentionable {
		buf.WriteString(`,"mentionable":true`)
	} else {
		buf.WriteString(`,"mentionable":false`)
	}
	buf.WriteByte(',')
	if len(j.Icon) != 0 {
		buf.WriteString(`"icon":`)
		fflib.WriteJsonString(buf, string(j.Icon))
		buf.WriteByte(',')
	}
	if len(j.UnicodeEmoji) != 0 {
		buf.WriteString(`"unicode_emoji":`)
		fflib.WriteJsonString(buf, string(j.UnicodeEmoji))
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"tags":`)

		{

			err = j.Tags.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtRolebase = iota
	ffjtRolenosuchkey

	ffjtRoleID

	ffjtRoleName

	ffjtRolePermissions

	ffjtRolePosition

	ffjtRoleColor

	ffjtRoleHoist

	ffjtRoleManaged

	ffjtRoleMentionable

	ffjtRoleIcon

	ffjtRoleUnicodeEmoji

	ffjtRoleTags
)

var ffjKeyRoleID = []byte("id")

var ffjKeyRoleName = []byte("name")

var ffjKeyRolePermissions = []byte("permissions")

var ffjKeyRolePosition = []byte("position")

var ffjKeyRoleColor = []byte("color")

var ffjKeyRoleHoist = []byte("hoist")

var ffjKeyRoleManaged = []byte("managed")

var ffjKeyRoleMentionable = []byte("mentionable")

var ffjKeyRoleIcon = []byte("icon")

var ffjKeyRoleUnicodeEmoji = []byte("unicode_emoji")

var ffjKeyRoleTags = []byte("tags")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Role) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Role) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtRolebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtRolenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyRoleColor, kn) {
						currentKey = ffjtRoleColor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyRoleHoist, kn) {
						currentKey = ffjtRoleHoist
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyRoleID, kn) {
						currentKey = ffjtRoleID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRoleIcon, kn) {
						currentKey = ffjtRoleIcon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyRoleManaged, kn) {
						currentKey = ffjtRoleManaged
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRoleMentionable, kn) {
						currentKey = ffjtRoleMentionable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyRoleName, kn) {
						currentKey = ffjtRoleName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyRolePermissions, kn) {
						currentKey = ffjtRolePermissions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRolePosition, kn) {
						currentKey = ffjtRolePosition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyRoleTags, kn) {
						currentKey = ffjtRoleTags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyRoleUnicodeEmoji, kn) {
						currentKey = ffjtRoleUnicodeEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyRoleTags, kn) {
					currentKey = ffjtRoleTags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRoleUnicodeEmoji, kn) {
					currentKey = ffjtRoleUnicodeEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRoleIcon, kn) {
					currentKey = ffjtRoleIcon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRoleMentionable, kn) {
					currentKey = ffjtRoleMentionable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRoleManaged, kn) {
					currentKey = ffjtRoleManaged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRoleHoist, kn) {
					currentKey = ffjtRoleHoist
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRoleColor, kn) {
					currentKey = ffjtRoleColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRolePosition, kn) {
					currentKey = ffjtRolePosition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRolePermissions, kn) {
					currentKey = ffjtRolePermissions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRoleName, kn) {
					currentKey = ffjtRoleName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRoleID, kn) {
					currentKey = ffjtRoleID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtRolenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtRoleID:
					goto handle_ID

				case ffjtRoleName:
					goto handle_Name

				case ffjtRolePermissions:
					goto handle_Permissions

				case ffjtRolePosition:
					goto handle_Position

				case ffjtRoleColor:
					goto handle_Color

				case ffjtRoleHoist:
					goto handle_Hoist

				case ffjtRoleManaged:
					goto handle_Managed

				case ffjtRoleMentionable:
					goto handle_Mentionable

				case ffjtRoleIcon:
					goto handle_Icon

				case ffjtRoleUnicodeEmoji:
					goto handle_UnicodeEmoji

				case ffjtRoleTags:
					goto handle_Tags

				case ffjtRolenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.RoleID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Permissions:

	/* handler: j.Permissions type=discord.Permissions kind=uint64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Permissions", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Permissions = Permissions(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Position:

	/* handler: j.Position type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Position = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Color:

	/* handler: j.Color type=discord.Color kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Color.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hoist:

	/* handler: j.Hoist type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Hoist = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Hoist = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Managed:

	/* handler: j.Managed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Managed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Managed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mentionable:

	/* handler: j.Mentionable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mentionable = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mentionable = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icon:

	/* handler: j.Icon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Icon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnicodeEmoji:

	/* handler: j.UnicodeEmoji type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UnicodeEmoji = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tags:

	/* handler: j.Tags type=discord.RoleTags kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Tags.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *RoleTags) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *RoleTags) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.BotID != 0 {
		buf.WriteString(`"bot_id":`)

		{

			obj, err = j.BotID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.IntegrationID != 0 {
		buf.WriteString(`"integration_id":`)

		{

			obj, err = j.IntegrationID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.PremiumSubscriber != false {
		if j.PremiumSubscriber {
			buf.WriteString(`"premium_subscriber":true`)
		} else {
			buf.WriteString(`"premium_subscriber":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtRoleTagsbase = iota
	ffjtRoleTagsnosuchkey

	ffjtRoleTagsBotID

	ffjtRoleTagsIntegrationID

	ffjtRoleTagsPremiumSubscriber
)

var ffjKeyRoleTagsBotID = []byte("bot_id")

var ffjKeyRoleTagsIntegrationID = []byte("integration_id")

var ffjKeyRoleTagsPremiumSubscriber = []byte("premium_subscriber")

// UnmarshalJSON umarshall json - template of ffjson
func (j *RoleTags) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *RoleTags) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtRoleTagsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtRoleTagsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyRoleTagsBotID, kn) {
						currentKey = ffjtRoleTagsBotID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyRoleTagsIntegrationID, kn) {
						currentKey = ffjtRoleTagsIntegrationID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyRoleTagsPremiumSubscriber, kn) {
						currentKey = ffjtRoleTagsPremiumSubscriber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyRoleTagsPremiumSubscriber, kn) {
					currentKey = ffjtRoleTagsPremiumSubscriber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRoleTagsIntegrationID, kn) {
					currentKey = ffjtRoleTagsIntegrationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRoleTagsBotID, kn) {
					currentKey = ffjtRoleTagsBotID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtRoleTagsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtRoleTagsBotID:
					goto handle_BotID

				case ffjtRoleTagsIntegrationID:
					goto handle_IntegrationID

				case ffjtRoleTagsPremiumSubscriber:
					goto handle_PremiumSubscriber

				case ffjtRoleTagsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_BotID:

	/* handler: j.BotID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BotID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IntegrationID:

	/* handler: j.IntegrationID type=discord.IntegrationID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.IntegrationID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PremiumSubscriber:

	/* handler: j.PremiumSubscriber type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.PremiumSubscriber = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.PremiumSubscriber = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
