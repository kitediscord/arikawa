// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: gateway/events.go

package gateway

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kitediscord/arikawa/v3/discord"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *ChannelCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChannelCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Type != 0 {
		buf.WriteString(`"type":`)
		fflib.FormatBits2(buf, uint64(j.Type), 10, false)
		buf.WriteByte(',')
	}
	if j.NSFW != false {
		if j.NSFW {
			buf.WriteString(`"nsfw":true`)
		} else {
			buf.WriteString(`"nsfw":false`)
		}
		buf.WriteByte(',')
	}
	if j.Position != 0 {
		buf.WriteString(`"position":`)
		fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
		buf.WriteByte(',')
	}
	if len(j.Overwrites) != 0 {
		buf.WriteString(`"permission_overwrites":`)
		if j.Overwrites != nil {
			buf.WriteString(`[`)
			for i, v := range j.Overwrites {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Topic) != 0 {
		buf.WriteString(`"topic":`)
		fflib.WriteJsonString(buf, string(j.Topic))
		buf.WriteByte(',')
	}
	if j.LastMessageID != 0 {
		buf.WriteString(`"last_message_id":`)

		{

			obj, err = j.LastMessageID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.VoiceBitrate != 0 {
		buf.WriteString(`"bitrate":`)
		fflib.FormatBits2(buf, uint64(j.VoiceBitrate), 10, false)
		buf.WriteByte(',')
	}
	if j.VoiceUserLimit != 0 {
		buf.WriteString(`"user_limit":`)
		fflib.FormatBits2(buf, uint64(j.VoiceUserLimit), 10, false)
		buf.WriteByte(',')
	}
	if j.Flags != 0 {
		buf.WriteString(`"flags":`)
		fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
		buf.WriteByte(',')
	}
	if j.UserRateLimit != 0 {
		buf.WriteString(`"rate_limit_per_user":`)

		{

			obj, err = j.UserRateLimit.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.DMRecipients) != 0 {
		buf.WriteString(`"recipients":`)
		if j.DMRecipients != nil {
			buf.WriteString(`[`)
			for i, v := range j.DMRecipients {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Icon) != 0 {
		buf.WriteString(`"icon":`)
		fflib.WriteJsonString(buf, string(j.Icon))
		buf.WriteByte(',')
	}
	if j.OwnerID != 0 {
		buf.WriteString(`"owner_id":`)

		{

			obj, err = j.OwnerID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ParentID != 0 {
		buf.WriteString(`"parent_id":`)

		{

			obj, err = j.ParentID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"last_pin_timestamp":`)

		{

			obj, err = j.LastPinTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.RTCRegionID) != 0 {
		buf.WriteString(`"rtc_region":`)
		fflib.WriteJsonString(buf, string(j.RTCRegionID))
		buf.WriteByte(',')
	}
	if j.VideoQualityMode != 0 {
		buf.WriteString(`"video_quality_mode":`)
		fflib.FormatBits2(buf, uint64(j.VideoQualityMode), 10, false)
		buf.WriteByte(',')
	}
	if j.MessageCount != 0 {
		buf.WriteString(`"message_count":`)
		fflib.FormatBits2(buf, uint64(j.MessageCount), 10, j.MessageCount < 0)
		buf.WriteByte(',')
	}
	if j.MemberCount != 0 {
		buf.WriteString(`"member_count":`)
		fflib.FormatBits2(buf, uint64(j.MemberCount), 10, j.MemberCount < 0)
		buf.WriteByte(',')
	}
	if j.ThreadMetadata != nil {
		if true {
			buf.WriteString(`"thread_metadata":`)

			{

				err = j.ThreadMetadata.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ThreadMember != nil {
		if true {
			buf.WriteString(`"thread_member":`)

			{

				err = j.ThreadMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultAutoArchiveDuration != 0 {
		buf.WriteString(`"default_auto_archive_duration":`)
		fflib.FormatBits2(buf, uint64(j.DefaultAutoArchiveDuration), 10, j.DefaultAutoArchiveDuration < 0)
		buf.WriteByte(',')
	}
	if j.SelfPermissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.SelfPermissions), 10, false)
		buf.WriteString(`",`)
	}
	if len(j.AvailableTags) != 0 {
		buf.WriteString(`"available_tags":`)
		if j.AvailableTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AvailableTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AppliedTags) != 0 {
		buf.WriteString(`"applied_tags":`)
		if j.AppliedTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AppliedTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DefaultReactionEmoji != nil {
		if true {
			buf.WriteString(`"default_reaction_emoji":`)

			{

				err = j.DefaultReactionEmoji.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultThreadRateLimitPerUser != 0 {
		buf.WriteString(`"default_thread_rate_limit_per_user":`)
		fflib.FormatBits2(buf, uint64(j.DefaultThreadRateLimitPerUser), 10, j.DefaultThreadRateLimitPerUser < 0)
		buf.WriteByte(',')
	}
	if j.DefaultSoftOrder != nil {
		if true {
			buf.WriteString(`"default_sort_order":`)
			fflib.FormatBits2(buf, uint64(*j.DefaultSoftOrder), 10, false)
			buf.WriteByte(',')
		}
	}
	if j.DefaultForumLayout != 0 {
		buf.WriteString(`"default_forum_layout":`)
		fflib.FormatBits2(buf, uint64(j.DefaultForumLayout), 10, false)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChannelDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChannelDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Type != 0 {
		buf.WriteString(`"type":`)
		fflib.FormatBits2(buf, uint64(j.Type), 10, false)
		buf.WriteByte(',')
	}
	if j.NSFW != false {
		if j.NSFW {
			buf.WriteString(`"nsfw":true`)
		} else {
			buf.WriteString(`"nsfw":false`)
		}
		buf.WriteByte(',')
	}
	if j.Position != 0 {
		buf.WriteString(`"position":`)
		fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
		buf.WriteByte(',')
	}
	if len(j.Overwrites) != 0 {
		buf.WriteString(`"permission_overwrites":`)
		if j.Overwrites != nil {
			buf.WriteString(`[`)
			for i, v := range j.Overwrites {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Topic) != 0 {
		buf.WriteString(`"topic":`)
		fflib.WriteJsonString(buf, string(j.Topic))
		buf.WriteByte(',')
	}
	if j.LastMessageID != 0 {
		buf.WriteString(`"last_message_id":`)

		{

			obj, err = j.LastMessageID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.VoiceBitrate != 0 {
		buf.WriteString(`"bitrate":`)
		fflib.FormatBits2(buf, uint64(j.VoiceBitrate), 10, false)
		buf.WriteByte(',')
	}
	if j.VoiceUserLimit != 0 {
		buf.WriteString(`"user_limit":`)
		fflib.FormatBits2(buf, uint64(j.VoiceUserLimit), 10, false)
		buf.WriteByte(',')
	}
	if j.Flags != 0 {
		buf.WriteString(`"flags":`)
		fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
		buf.WriteByte(',')
	}
	if j.UserRateLimit != 0 {
		buf.WriteString(`"rate_limit_per_user":`)

		{

			obj, err = j.UserRateLimit.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.DMRecipients) != 0 {
		buf.WriteString(`"recipients":`)
		if j.DMRecipients != nil {
			buf.WriteString(`[`)
			for i, v := range j.DMRecipients {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Icon) != 0 {
		buf.WriteString(`"icon":`)
		fflib.WriteJsonString(buf, string(j.Icon))
		buf.WriteByte(',')
	}
	if j.OwnerID != 0 {
		buf.WriteString(`"owner_id":`)

		{

			obj, err = j.OwnerID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ParentID != 0 {
		buf.WriteString(`"parent_id":`)

		{

			obj, err = j.ParentID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"last_pin_timestamp":`)

		{

			obj, err = j.LastPinTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.RTCRegionID) != 0 {
		buf.WriteString(`"rtc_region":`)
		fflib.WriteJsonString(buf, string(j.RTCRegionID))
		buf.WriteByte(',')
	}
	if j.VideoQualityMode != 0 {
		buf.WriteString(`"video_quality_mode":`)
		fflib.FormatBits2(buf, uint64(j.VideoQualityMode), 10, false)
		buf.WriteByte(',')
	}
	if j.MessageCount != 0 {
		buf.WriteString(`"message_count":`)
		fflib.FormatBits2(buf, uint64(j.MessageCount), 10, j.MessageCount < 0)
		buf.WriteByte(',')
	}
	if j.MemberCount != 0 {
		buf.WriteString(`"member_count":`)
		fflib.FormatBits2(buf, uint64(j.MemberCount), 10, j.MemberCount < 0)
		buf.WriteByte(',')
	}
	if j.ThreadMetadata != nil {
		if true {
			buf.WriteString(`"thread_metadata":`)

			{

				err = j.ThreadMetadata.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ThreadMember != nil {
		if true {
			buf.WriteString(`"thread_member":`)

			{

				err = j.ThreadMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultAutoArchiveDuration != 0 {
		buf.WriteString(`"default_auto_archive_duration":`)
		fflib.FormatBits2(buf, uint64(j.DefaultAutoArchiveDuration), 10, j.DefaultAutoArchiveDuration < 0)
		buf.WriteByte(',')
	}
	if j.SelfPermissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.SelfPermissions), 10, false)
		buf.WriteString(`",`)
	}
	if len(j.AvailableTags) != 0 {
		buf.WriteString(`"available_tags":`)
		if j.AvailableTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AvailableTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AppliedTags) != 0 {
		buf.WriteString(`"applied_tags":`)
		if j.AppliedTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AppliedTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DefaultReactionEmoji != nil {
		if true {
			buf.WriteString(`"default_reaction_emoji":`)

			{

				err = j.DefaultReactionEmoji.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultThreadRateLimitPerUser != 0 {
		buf.WriteString(`"default_thread_rate_limit_per_user":`)
		fflib.FormatBits2(buf, uint64(j.DefaultThreadRateLimitPerUser), 10, j.DefaultThreadRateLimitPerUser < 0)
		buf.WriteByte(',')
	}
	if j.DefaultSoftOrder != nil {
		if true {
			buf.WriteString(`"default_sort_order":`)
			fflib.FormatBits2(buf, uint64(*j.DefaultSoftOrder), 10, false)
			buf.WriteByte(',')
		}
	}
	if j.DefaultForumLayout != 0 {
		buf.WriteString(`"default_forum_layout":`)
		fflib.FormatBits2(buf, uint64(j.DefaultForumLayout), 10, false)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChannelPinsUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChannelPinsUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ChannelID != 0 {
		buf.WriteString(`"channel_id":`)

		{

			obj, err = j.ChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"timestamp":`)

		{

			obj, err = j.LastPin.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChannelPinsUpdateEventbase = iota
	ffjtChannelPinsUpdateEventnosuchkey

	ffjtChannelPinsUpdateEventGuildID

	ffjtChannelPinsUpdateEventChannelID

	ffjtChannelPinsUpdateEventLastPin
)

var ffjKeyChannelPinsUpdateEventGuildID = []byte("guild_id")

var ffjKeyChannelPinsUpdateEventChannelID = []byte("channel_id")

var ffjKeyChannelPinsUpdateEventLastPin = []byte("timestamp")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChannelPinsUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChannelPinsUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChannelPinsUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChannelPinsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChannelPinsUpdateEventChannelID, kn) {
						currentKey = ffjtChannelPinsUpdateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyChannelPinsUpdateEventGuildID, kn) {
						currentKey = ffjtChannelPinsUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChannelPinsUpdateEventLastPin, kn) {
						currentKey = ffjtChannelPinsUpdateEventLastPin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChannelPinsUpdateEventLastPin, kn) {
					currentKey = ffjtChannelPinsUpdateEventLastPin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChannelPinsUpdateEventChannelID, kn) {
					currentKey = ffjtChannelPinsUpdateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChannelPinsUpdateEventGuildID, kn) {
					currentKey = ffjtChannelPinsUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChannelPinsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChannelPinsUpdateEventGuildID:
					goto handle_GuildID

				case ffjtChannelPinsUpdateEventChannelID:
					goto handle_ChannelID

				case ffjtChannelPinsUpdateEventLastPin:
					goto handle_LastPin

				case ffjtChannelPinsUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastPin:

	/* handler: j.LastPin type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LastPin.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChannelUnreadUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChannelUnreadUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"ChannelUnreadUpdates":`)
	if j.ChannelUnreadUpdates != nil {
		buf.WriteString(`[`)
		for i, v := range j.ChannelUnreadUpdates {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { ID discord.ChannelID "json:\"id\""; LastMessageID discord.MessageID "json:\"last_message_id\"" } kind=struct */
			buf.WriteString(`{ "id":`)

			{

				obj, err = v.ID.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteString(`,"last_message_id":`)

			{

				obj, err = v.LastMessageID.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChannelUnreadUpdateEventbase = iota
	ffjtChannelUnreadUpdateEventnosuchkey

	ffjtChannelUnreadUpdateEventGuildID

	ffjtChannelUnreadUpdateEventChannelUnreadUpdates
)

var ffjKeyChannelUnreadUpdateEventGuildID = []byte("guild_id")

var ffjKeyChannelUnreadUpdateEventChannelUnreadUpdates = []byte("ChannelUnreadUpdates")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChannelUnreadUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChannelUnreadUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChannelUnreadUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChannelUnreadUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyChannelUnreadUpdateEventChannelUnreadUpdates, kn) {
						currentKey = ffjtChannelUnreadUpdateEventChannelUnreadUpdates
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyChannelUnreadUpdateEventGuildID, kn) {
						currentKey = ffjtChannelUnreadUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChannelUnreadUpdateEventChannelUnreadUpdates, kn) {
					currentKey = ffjtChannelUnreadUpdateEventChannelUnreadUpdates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChannelUnreadUpdateEventGuildID, kn) {
					currentKey = ffjtChannelUnreadUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChannelUnreadUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChannelUnreadUpdateEventGuildID:
					goto handle_GuildID

				case ffjtChannelUnreadUpdateEventChannelUnreadUpdates:
					goto handle_ChannelUnreadUpdates

				case ffjtChannelUnreadUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelUnreadUpdates:

	/* handler: j.ChannelUnreadUpdates type=[]struct { ID discord.ChannelID "json:\"id\""; LastMessageID discord.MessageID "json:\"last_message_id\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { ID discord.ChannelID "json:\"id\""; LastMessageID discord.MessageID "json:\"last_message_id\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ChannelUnreadUpdates)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChannelUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChannelUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Type != 0 {
		buf.WriteString(`"type":`)
		fflib.FormatBits2(buf, uint64(j.Type), 10, false)
		buf.WriteByte(',')
	}
	if j.NSFW != false {
		if j.NSFW {
			buf.WriteString(`"nsfw":true`)
		} else {
			buf.WriteString(`"nsfw":false`)
		}
		buf.WriteByte(',')
	}
	if j.Position != 0 {
		buf.WriteString(`"position":`)
		fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
		buf.WriteByte(',')
	}
	if len(j.Overwrites) != 0 {
		buf.WriteString(`"permission_overwrites":`)
		if j.Overwrites != nil {
			buf.WriteString(`[`)
			for i, v := range j.Overwrites {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Topic) != 0 {
		buf.WriteString(`"topic":`)
		fflib.WriteJsonString(buf, string(j.Topic))
		buf.WriteByte(',')
	}
	if j.LastMessageID != 0 {
		buf.WriteString(`"last_message_id":`)

		{

			obj, err = j.LastMessageID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.VoiceBitrate != 0 {
		buf.WriteString(`"bitrate":`)
		fflib.FormatBits2(buf, uint64(j.VoiceBitrate), 10, false)
		buf.WriteByte(',')
	}
	if j.VoiceUserLimit != 0 {
		buf.WriteString(`"user_limit":`)
		fflib.FormatBits2(buf, uint64(j.VoiceUserLimit), 10, false)
		buf.WriteByte(',')
	}
	if j.Flags != 0 {
		buf.WriteString(`"flags":`)
		fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
		buf.WriteByte(',')
	}
	if j.UserRateLimit != 0 {
		buf.WriteString(`"rate_limit_per_user":`)

		{

			obj, err = j.UserRateLimit.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.DMRecipients) != 0 {
		buf.WriteString(`"recipients":`)
		if j.DMRecipients != nil {
			buf.WriteString(`[`)
			for i, v := range j.DMRecipients {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Icon) != 0 {
		buf.WriteString(`"icon":`)
		fflib.WriteJsonString(buf, string(j.Icon))
		buf.WriteByte(',')
	}
	if j.OwnerID != 0 {
		buf.WriteString(`"owner_id":`)

		{

			obj, err = j.OwnerID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ParentID != 0 {
		buf.WriteString(`"parent_id":`)

		{

			obj, err = j.ParentID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"last_pin_timestamp":`)

		{

			obj, err = j.LastPinTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.RTCRegionID) != 0 {
		buf.WriteString(`"rtc_region":`)
		fflib.WriteJsonString(buf, string(j.RTCRegionID))
		buf.WriteByte(',')
	}
	if j.VideoQualityMode != 0 {
		buf.WriteString(`"video_quality_mode":`)
		fflib.FormatBits2(buf, uint64(j.VideoQualityMode), 10, false)
		buf.WriteByte(',')
	}
	if j.MessageCount != 0 {
		buf.WriteString(`"message_count":`)
		fflib.FormatBits2(buf, uint64(j.MessageCount), 10, j.MessageCount < 0)
		buf.WriteByte(',')
	}
	if j.MemberCount != 0 {
		buf.WriteString(`"member_count":`)
		fflib.FormatBits2(buf, uint64(j.MemberCount), 10, j.MemberCount < 0)
		buf.WriteByte(',')
	}
	if j.ThreadMetadata != nil {
		if true {
			buf.WriteString(`"thread_metadata":`)

			{

				err = j.ThreadMetadata.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ThreadMember != nil {
		if true {
			buf.WriteString(`"thread_member":`)

			{

				err = j.ThreadMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultAutoArchiveDuration != 0 {
		buf.WriteString(`"default_auto_archive_duration":`)
		fflib.FormatBits2(buf, uint64(j.DefaultAutoArchiveDuration), 10, j.DefaultAutoArchiveDuration < 0)
		buf.WriteByte(',')
	}
	if j.SelfPermissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.SelfPermissions), 10, false)
		buf.WriteString(`",`)
	}
	if len(j.AvailableTags) != 0 {
		buf.WriteString(`"available_tags":`)
		if j.AvailableTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AvailableTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AppliedTags) != 0 {
		buf.WriteString(`"applied_tags":`)
		if j.AppliedTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AppliedTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DefaultReactionEmoji != nil {
		if true {
			buf.WriteString(`"default_reaction_emoji":`)

			{

				err = j.DefaultReactionEmoji.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultThreadRateLimitPerUser != 0 {
		buf.WriteString(`"default_thread_rate_limit_per_user":`)
		fflib.FormatBits2(buf, uint64(j.DefaultThreadRateLimitPerUser), 10, j.DefaultThreadRateLimitPerUser < 0)
		buf.WriteByte(',')
	}
	if j.DefaultSoftOrder != nil {
		if true {
			buf.WriteString(`"default_sort_order":`)
			fflib.FormatBits2(buf, uint64(*j.DefaultSoftOrder), 10, false)
			buf.WriteByte(',')
		}
	}
	if j.DefaultForumLayout != 0 {
		buf.WriteString(`"default_forum_layout":`)
		fflib.FormatBits2(buf, uint64(j.DefaultForumLayout), 10, false)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ConversationSummary) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ConversationSummary) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Unsafe {
		buf.WriteString(`{"unsafe":true`)
	} else {
		buf.WriteString(`{"unsafe":false`)
	}
	buf.WriteString(`,"topic":`)
	fflib.WriteJsonString(buf, string(j.Topic))
	buf.WriteString(`,"summ_short":`)
	fflib.WriteJsonString(buf, string(j.ShortSummary))
	buf.WriteString(`,"people":`)
	if j.People != nil {
		buf.WriteString(`[`)
		for i, v := range j.People {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"start_id":`)

	{

		obj, err = j.StartID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"end_id":`)

	{

		obj, err = j.EndID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"message_ids":`)
	if j.MessageIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.MessageIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"count":`)
	fflib.FormatBits2(buf, uint64(j.Count), 10, j.Count < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtConversationSummarybase = iota
	ffjtConversationSummarynosuchkey

	ffjtConversationSummaryUnsafe

	ffjtConversationSummaryTopic

	ffjtConversationSummaryShortSummary

	ffjtConversationSummaryPeople

	ffjtConversationSummaryStartID

	ffjtConversationSummaryEndID

	ffjtConversationSummaryMessageIDs

	ffjtConversationSummaryID

	ffjtConversationSummaryCount
)

var ffjKeyConversationSummaryUnsafe = []byte("unsafe")

var ffjKeyConversationSummaryTopic = []byte("topic")

var ffjKeyConversationSummaryShortSummary = []byte("summ_short")

var ffjKeyConversationSummaryPeople = []byte("people")

var ffjKeyConversationSummaryStartID = []byte("start_id")

var ffjKeyConversationSummaryEndID = []byte("end_id")

var ffjKeyConversationSummaryMessageIDs = []byte("message_ids")

var ffjKeyConversationSummaryID = []byte("id")

var ffjKeyConversationSummaryCount = []byte("count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ConversationSummary) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ConversationSummary) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtConversationSummarybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtConversationSummarynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyConversationSummaryCount, kn) {
						currentKey = ffjtConversationSummaryCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyConversationSummaryEndID, kn) {
						currentKey = ffjtConversationSummaryEndID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyConversationSummaryID, kn) {
						currentKey = ffjtConversationSummaryID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyConversationSummaryMessageIDs, kn) {
						currentKey = ffjtConversationSummaryMessageIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyConversationSummaryPeople, kn) {
						currentKey = ffjtConversationSummaryPeople
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyConversationSummaryShortSummary, kn) {
						currentKey = ffjtConversationSummaryShortSummary
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyConversationSummaryStartID, kn) {
						currentKey = ffjtConversationSummaryStartID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyConversationSummaryTopic, kn) {
						currentKey = ffjtConversationSummaryTopic
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyConversationSummaryUnsafe, kn) {
						currentKey = ffjtConversationSummaryUnsafe
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyConversationSummaryCount, kn) {
					currentKey = ffjtConversationSummaryCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyConversationSummaryID, kn) {
					currentKey = ffjtConversationSummaryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyConversationSummaryMessageIDs, kn) {
					currentKey = ffjtConversationSummaryMessageIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyConversationSummaryEndID, kn) {
					currentKey = ffjtConversationSummaryEndID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyConversationSummaryStartID, kn) {
					currentKey = ffjtConversationSummaryStartID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyConversationSummaryPeople, kn) {
					currentKey = ffjtConversationSummaryPeople
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyConversationSummaryShortSummary, kn) {
					currentKey = ffjtConversationSummaryShortSummary
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyConversationSummaryTopic, kn) {
					currentKey = ffjtConversationSummaryTopic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyConversationSummaryUnsafe, kn) {
					currentKey = ffjtConversationSummaryUnsafe
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtConversationSummarynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtConversationSummaryUnsafe:
					goto handle_Unsafe

				case ffjtConversationSummaryTopic:
					goto handle_Topic

				case ffjtConversationSummaryShortSummary:
					goto handle_ShortSummary

				case ffjtConversationSummaryPeople:
					goto handle_People

				case ffjtConversationSummaryStartID:
					goto handle_StartID

				case ffjtConversationSummaryEndID:
					goto handle_EndID

				case ffjtConversationSummaryMessageIDs:
					goto handle_MessageIDs

				case ffjtConversationSummaryID:
					goto handle_ID

				case ffjtConversationSummaryCount:
					goto handle_Count

				case ffjtConversationSummarynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Unsafe:

	/* handler: j.Unsafe type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Unsafe = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Unsafe = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Topic:

	/* handler: j.Topic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Topic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortSummary:

	/* handler: j.ShortSummary type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShortSummary = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_People:

	/* handler: j.People type=[]discord.UserID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.People = nil
		} else {

			j.People = []discord.UserID{}

			wantVal := true

			for {

				var tmpJPeople discord.UserID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPeople type=discord.UserID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJPeople.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.People = append(j.People, tmpJPeople)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartID:

	/* handler: j.StartID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndID:

	/* handler: j.EndID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EndID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageIDs:

	/* handler: j.MessageIDs type=[]discord.MessageID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.MessageIDs = nil
		} else {

			j.MessageIDs = []discord.MessageID{}

			wantVal := true

			for {

				var tmpJMessageIDs discord.MessageID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMessageIDs type=discord.MessageID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJMessageIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.MessageIDs = append(j.MessageIDs, tmpJMessageIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=discord.Snowflake kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Count:

	/* handler: j.Count type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Count = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ConversationSummaryUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ConversationSummaryUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"summaries":`)
	if j.Summaries != nil {
		buf.WriteString(`[`)
		for i, v := range j.Summaries {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtConversationSummaryUpdateEventbase = iota
	ffjtConversationSummaryUpdateEventnosuchkey

	ffjtConversationSummaryUpdateEventChannelID

	ffjtConversationSummaryUpdateEventGuildID

	ffjtConversationSummaryUpdateEventSummaries
)

var ffjKeyConversationSummaryUpdateEventChannelID = []byte("channel_id")

var ffjKeyConversationSummaryUpdateEventGuildID = []byte("guild_id")

var ffjKeyConversationSummaryUpdateEventSummaries = []byte("summaries")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ConversationSummaryUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ConversationSummaryUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtConversationSummaryUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtConversationSummaryUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyConversationSummaryUpdateEventChannelID, kn) {
						currentKey = ffjtConversationSummaryUpdateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyConversationSummaryUpdateEventGuildID, kn) {
						currentKey = ffjtConversationSummaryUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyConversationSummaryUpdateEventSummaries, kn) {
						currentKey = ffjtConversationSummaryUpdateEventSummaries
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyConversationSummaryUpdateEventSummaries, kn) {
					currentKey = ffjtConversationSummaryUpdateEventSummaries
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyConversationSummaryUpdateEventGuildID, kn) {
					currentKey = ffjtConversationSummaryUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyConversationSummaryUpdateEventChannelID, kn) {
					currentKey = ffjtConversationSummaryUpdateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtConversationSummaryUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtConversationSummaryUpdateEventChannelID:
					goto handle_ChannelID

				case ffjtConversationSummaryUpdateEventGuildID:
					goto handle_GuildID

				case ffjtConversationSummaryUpdateEventSummaries:
					goto handle_Summaries

				case ffjtConversationSummaryUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Summaries:

	/* handler: j.Summaries type=[]gateway.ConversationSummary kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Summaries = nil
		} else {

			j.Summaries = []ConversationSummary{}

			wantVal := true

			for {

				var tmpJSummaries ConversationSummary

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSummaries type=gateway.ConversationSummary kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJSummaries.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Summaries = append(j.Summaries, tmpJSummaries)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CustomUserStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CustomUserStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"expires_at":`)

		{

			obj, err = j.ExpiresAt.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"emoji_id":"`)

	{

		obj, err = j.EmojiID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`","emoji_name":`)
	fflib.WriteJsonString(buf, string(j.EmojiName))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCustomUserStatusbase = iota
	ffjtCustomUserStatusnosuchkey

	ffjtCustomUserStatusText

	ffjtCustomUserStatusExpiresAt

	ffjtCustomUserStatusEmojiID

	ffjtCustomUserStatusEmojiName
)

var ffjKeyCustomUserStatusText = []byte("text")

var ffjKeyCustomUserStatusExpiresAt = []byte("expires_at")

var ffjKeyCustomUserStatusEmojiID = []byte("emoji_id")

var ffjKeyCustomUserStatusEmojiName = []byte("emoji_name")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CustomUserStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CustomUserStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCustomUserStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCustomUserStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyCustomUserStatusExpiresAt, kn) {
						currentKey = ffjtCustomUserStatusExpiresAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCustomUserStatusEmojiID, kn) {
						currentKey = ffjtCustomUserStatusEmojiID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCustomUserStatusEmojiName, kn) {
						currentKey = ffjtCustomUserStatusEmojiName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyCustomUserStatusText, kn) {
						currentKey = ffjtCustomUserStatusText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyCustomUserStatusEmojiName, kn) {
					currentKey = ffjtCustomUserStatusEmojiName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCustomUserStatusEmojiID, kn) {
					currentKey = ffjtCustomUserStatusEmojiID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCustomUserStatusExpiresAt, kn) {
					currentKey = ffjtCustomUserStatusExpiresAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCustomUserStatusText, kn) {
					currentKey = ffjtCustomUserStatusText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCustomUserStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCustomUserStatusText:
					goto handle_Text

				case ffjtCustomUserStatusExpiresAt:
					goto handle_ExpiresAt

				case ffjtCustomUserStatusEmojiID:
					goto handle_EmojiID

				case ffjtCustomUserStatusEmojiName:
					goto handle_EmojiName

				case ffjtCustomUserStatusnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpiresAt:

	/* handler: j.ExpiresAt type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ExpiresAt.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmojiID:

	/* handler: j.EmojiID type=discord.EmojiID kind=uint64 quoted=true*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EmojiID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmojiName:

	/* handler: j.EmojiName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.EmojiName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FriendSourceFlags) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FriendSourceFlags) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.All != false {
		if j.All {
			buf.WriteString(`"all":true`)
		} else {
			buf.WriteString(`"all":false`)
		}
		buf.WriteByte(',')
	}
	if j.MutualGuilds != false {
		if j.MutualGuilds {
			buf.WriteString(`"mutual_guilds":true`)
		} else {
			buf.WriteString(`"mutual_guilds":false`)
		}
		buf.WriteByte(',')
	}
	if j.MutualFriends != false {
		if j.MutualFriends {
			buf.WriteString(`"mutual_friends":true`)
		} else {
			buf.WriteString(`"mutual_friends":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFriendSourceFlagsbase = iota
	ffjtFriendSourceFlagsnosuchkey

	ffjtFriendSourceFlagsAll

	ffjtFriendSourceFlagsMutualGuilds

	ffjtFriendSourceFlagsMutualFriends
)

var ffjKeyFriendSourceFlagsAll = []byte("all")

var ffjKeyFriendSourceFlagsMutualGuilds = []byte("mutual_guilds")

var ffjKeyFriendSourceFlagsMutualFriends = []byte("mutual_friends")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FriendSourceFlags) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FriendSourceFlags) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFriendSourceFlagsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFriendSourceFlagsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyFriendSourceFlagsAll, kn) {
						currentKey = ffjtFriendSourceFlagsAll
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyFriendSourceFlagsMutualGuilds, kn) {
						currentKey = ffjtFriendSourceFlagsMutualGuilds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFriendSourceFlagsMutualFriends, kn) {
						currentKey = ffjtFriendSourceFlagsMutualFriends
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFriendSourceFlagsMutualFriends, kn) {
					currentKey = ffjtFriendSourceFlagsMutualFriends
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFriendSourceFlagsMutualGuilds, kn) {
					currentKey = ffjtFriendSourceFlagsMutualGuilds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFriendSourceFlagsAll, kn) {
					currentKey = ffjtFriendSourceFlagsAll
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFriendSourceFlagsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFriendSourceFlagsAll:
					goto handle_All

				case ffjtFriendSourceFlagsMutualGuilds:
					goto handle_MutualGuilds

				case ffjtFriendSourceFlagsMutualFriends:
					goto handle_MutualFriends

				case ffjtFriendSourceFlagsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_All:

	/* handler: j.All type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.All = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.All = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MutualGuilds:

	/* handler: j.MutualGuilds type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MutualGuilds = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MutualGuilds = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MutualFriends:

	/* handler: j.MutualFriends type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MutualFriends = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MutualFriends = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildAuditLogEntryCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildAuditLogEntryCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"target_id":`)

	{

		obj, err = j.TargetID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if len(j.Changes) != 0 {
		buf.WriteString(`"changes":`)
		if j.Changes != nil {
			buf.WriteString(`[`)
			for i, v := range j.Changes {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Struct fall back. type=discord.AuditLogChange kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"action_type":`)
	fflib.FormatBits2(buf, uint64(j.ActionType), 10, false)
	buf.WriteByte(',')
	if true {
		/* Struct fall back. type=discord.AuditEntryInfo kind=struct */
		buf.WriteString(`"options":`)
		err = buf.Encode(&j.Options)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(j.Reason))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildAuditLogEntryCreateEventbase = iota
	ffjtGuildAuditLogEntryCreateEventnosuchkey

	ffjtGuildAuditLogEntryCreateEventID

	ffjtGuildAuditLogEntryCreateEventTargetID

	ffjtGuildAuditLogEntryCreateEventChanges

	ffjtGuildAuditLogEntryCreateEventUserID

	ffjtGuildAuditLogEntryCreateEventActionType

	ffjtGuildAuditLogEntryCreateEventOptions

	ffjtGuildAuditLogEntryCreateEventReason
)

var ffjKeyGuildAuditLogEntryCreateEventID = []byte("id")

var ffjKeyGuildAuditLogEntryCreateEventTargetID = []byte("target_id")

var ffjKeyGuildAuditLogEntryCreateEventChanges = []byte("changes")

var ffjKeyGuildAuditLogEntryCreateEventUserID = []byte("user_id")

var ffjKeyGuildAuditLogEntryCreateEventActionType = []byte("action_type")

var ffjKeyGuildAuditLogEntryCreateEventOptions = []byte("options")

var ffjKeyGuildAuditLogEntryCreateEventReason = []byte("reason")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildAuditLogEntryCreateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildAuditLogEntryCreateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildAuditLogEntryCreateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildAuditLogEntryCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventActionType, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventActionType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventChanges, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventChanges
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventID, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventOptions, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventOptions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventReason, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventReason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventTargetID, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventTargetID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildAuditLogEntryCreateEventUserID, kn) {
						currentKey = ffjtGuildAuditLogEntryCreateEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildAuditLogEntryCreateEventReason, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventReason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildAuditLogEntryCreateEventOptions, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventOptions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildAuditLogEntryCreateEventActionType, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventActionType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildAuditLogEntryCreateEventUserID, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildAuditLogEntryCreateEventChanges, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventChanges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildAuditLogEntryCreateEventTargetID, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventTargetID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildAuditLogEntryCreateEventID, kn) {
					currentKey = ffjtGuildAuditLogEntryCreateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildAuditLogEntryCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildAuditLogEntryCreateEventID:
					goto handle_ID

				case ffjtGuildAuditLogEntryCreateEventTargetID:
					goto handle_TargetID

				case ffjtGuildAuditLogEntryCreateEventChanges:
					goto handle_Changes

				case ffjtGuildAuditLogEntryCreateEventUserID:
					goto handle_UserID

				case ffjtGuildAuditLogEntryCreateEventActionType:
					goto handle_ActionType

				case ffjtGuildAuditLogEntryCreateEventOptions:
					goto handle_Options

				case ffjtGuildAuditLogEntryCreateEventReason:
					goto handle_Reason

				case ffjtGuildAuditLogEntryCreateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.AuditLogEntryID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetID:

	/* handler: j.TargetID type=discord.Snowflake kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.TargetID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Changes:

	/* handler: j.Changes type=[]discord.AuditLogChange kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Changes = nil
		} else {

			j.Changes = []discord.AuditLogChange{}

			wantVal := true

			for {

				var tmpJChanges discord.AuditLogChange

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChanges type=discord.AuditLogChange kind=struct quoted=false*/

				{
					/* Falling back. type=discord.AuditLogChange kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJChanges)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Changes = append(j.Changes, tmpJChanges)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActionType:

	/* handler: j.ActionType type=discord.AuditLogEvent kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for AuditLogEvent", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ActionType = discord.AuditLogEvent(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Options:

	/* handler: j.Options type=discord.AuditEntryInfo kind=struct quoted=false*/

	{
		/* Falling back. type=discord.AuditEntryInfo kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Options)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: j.Reason type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Reason = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildBanAddEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildBanAddEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildBanAddEventbase = iota
	ffjtGuildBanAddEventnosuchkey

	ffjtGuildBanAddEventGuildID

	ffjtGuildBanAddEventUser
)

var ffjKeyGuildBanAddEventGuildID = []byte("guild_id")

var ffjKeyGuildBanAddEventUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildBanAddEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildBanAddEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildBanAddEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildBanAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildBanAddEventGuildID, kn) {
						currentKey = ffjtGuildBanAddEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildBanAddEventUser, kn) {
						currentKey = ffjtGuildBanAddEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildBanAddEventUser, kn) {
					currentKey = ffjtGuildBanAddEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildBanAddEventGuildID, kn) {
					currentKey = ffjtGuildBanAddEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildBanAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildBanAddEventGuildID:
					goto handle_GuildID

				case ffjtGuildBanAddEventUser:
					goto handle_User

				case ffjtGuildBanAddEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildBanRemoveEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildBanRemoveEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildBanRemoveEventbase = iota
	ffjtGuildBanRemoveEventnosuchkey

	ffjtGuildBanRemoveEventGuildID

	ffjtGuildBanRemoveEventUser
)

var ffjKeyGuildBanRemoveEventGuildID = []byte("guild_id")

var ffjKeyGuildBanRemoveEventUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildBanRemoveEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildBanRemoveEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildBanRemoveEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildBanRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildBanRemoveEventGuildID, kn) {
						currentKey = ffjtGuildBanRemoveEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildBanRemoveEventUser, kn) {
						currentKey = ffjtGuildBanRemoveEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildBanRemoveEventUser, kn) {
					currentKey = ffjtGuildBanRemoveEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildBanRemoveEventGuildID, kn) {
					currentKey = ffjtGuildBanRemoveEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildBanRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildBanRemoveEventGuildID:
					goto handle_GuildID

				case ffjtGuildBanRemoveEventUser:
					goto handle_User

				case ffjtGuildBanRemoveEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if true {
		buf.WriteString(`"joined_at":`)

		{

			obj, err = j.Joined.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Large != false {
		if j.Large {
			buf.WriteString(`"large":true`)
		} else {
			buf.WriteString(`"large":false`)
		}
		buf.WriteByte(',')
	}
	if j.Unavailable != false {
		if j.Unavailable {
			buf.WriteString(`"unavailable":true`)
		} else {
			buf.WriteString(`"unavailable":false`)
		}
		buf.WriteByte(',')
	}
	if j.MemberCount != 0 {
		buf.WriteString(`"member_count":`)
		fflib.FormatBits2(buf, uint64(j.MemberCount), 10, false)
		buf.WriteByte(',')
	}
	if len(j.VoiceStates) != 0 {
		buf.WriteString(`"voice_states":`)
		if j.VoiceStates != nil {
			buf.WriteString(`[`)
			for i, v := range j.VoiceStates {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Struct fall back. type=discord.VoiceState kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Members) != 0 {
		buf.WriteString(`"members":`)
		if j.Members != nil {
			buf.WriteString(`[`)
			for i, v := range j.Members {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Channels) != 0 {
		buf.WriteString(`"channels":`)
		if j.Channels != nil {
			buf.WriteString(`[`)
			for i, v := range j.Channels {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Threads) != 0 {
		buf.WriteString(`"threads":`)
		if j.Threads != nil {
			buf.WriteString(`[`)
			for i, v := range j.Threads {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Presences) != 0 {
		buf.WriteString(`"presences":`)
		if j.Presences != nil {
			buf.WriteString(`[`)
			for i, v := range j.Presences {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"icon":`)
	fflib.WriteJsonString(buf, string(j.Icon))
	buf.WriteByte(',')
	if len(j.Splash) != 0 {
		buf.WriteString(`"splash":`)
		fflib.WriteJsonString(buf, string(j.Splash))
		buf.WriteByte(',')
	}
	if len(j.DiscoverySplash) != 0 {
		buf.WriteString(`"discovery_splash":`)
		fflib.WriteJsonString(buf, string(j.DiscoverySplash))
		buf.WriteByte(',')
	}
	if j.Owner != false {
		if j.Owner {
			buf.WriteString(`"owner":true`)
		} else {
			buf.WriteString(`"owner":false`)
		}
		buf.WriteByte(',')
	}
	if j.Widget != false {
		if j.Widget {
			buf.WriteString(`"widget_enabled":true`)
		} else {
			buf.WriteString(`"widget_enabled":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"system_channel_flags":`)
	fflib.FormatBits2(buf, uint64(j.SystemChannelFlags), 10, false)
	buf.WriteString(`,"verification_level":`)

	{

		obj, err = j.Verification.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"default_message_notifications":`)

	{

		obj, err = j.Notification.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"explicit_content_filter":`)

	{

		obj, err = j.ExplicitFilter.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"premium_tier":`)
	fflib.FormatBits2(buf, uint64(j.NitroBoost), 10, false)
	buf.WriteString(`,"mfa_level":`)
	fflib.FormatBits2(buf, uint64(j.MFA), 10, false)
	buf.WriteString(`,"owner_id":`)

	{

		obj, err = j.OwnerID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.WidgetChannelID != 0 {
		buf.WriteString(`"widget_channel_id":`)

		{

			obj, err = j.WidgetChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.SystemChannelID != 0 {
		buf.WriteString(`"system_channel_id":`)

		{

			obj, err = j.SystemChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Permissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.Permissions), 10, false)
		buf.WriteString(`",`)
	}
	buf.WriteString(`"region":`)
	fflib.WriteJsonString(buf, string(j.VoiceRegion))
	buf.WriteByte(',')
	if j.AFKChannelID != 0 {
		buf.WriteString(`"afk_channel_id":`)

		{

			obj, err = j.AFKChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"afk_timeout":`)

	{

		obj, err = j.AFKTimeout.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"roles":`)
	if j.Roles != nil {
		buf.WriteString(`[`)
		for i, v := range j.Roles {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"emojis":`)
	if j.Emojis != nil {
		buf.WriteString(`[`)
		for i, v := range j.Emojis {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"features":`)
	if j.Features != nil {
		buf.WriteString(`[`)
		for i, v := range j.Features {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"rules_channel_id":`)

	{

		obj, err = j.RulesChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.MaxPresences != 0 {
		buf.WriteString(`"max_presences":`)
		fflib.FormatBits2(buf, uint64(j.MaxPresences), 10, false)
		buf.WriteByte(',')
	}
	if j.MaxMembers != 0 {
		buf.WriteString(`"max_members":`)
		fflib.FormatBits2(buf, uint64(j.MaxMembers), 10, false)
		buf.WriteByte(',')
	}
	if len(j.VanityURLCode) != 0 {
		buf.WriteString(`"vanity_url_code":`)
		fflib.WriteJsonString(buf, string(j.VanityURLCode))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Banner) != 0 {
		buf.WriteString(`"banner":`)
		fflib.WriteJsonString(buf, string(j.Banner))
		buf.WriteByte(',')
	}
	if j.NitroBoosters != 0 {
		buf.WriteString(`"premium_subscription_count":`)
		fflib.FormatBits2(buf, uint64(j.NitroBoosters), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"preferred_locale":`)
	fflib.WriteJsonString(buf, string(j.PreferredLocale))
	buf.WriteString(`,"public_updates_channel_id":`)

	{

		obj, err = j.PublicUpdatesChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.MaxVideoChannelUsers != 0 {
		buf.WriteString(`"max_video_channel_users":`)
		fflib.FormatBits2(buf, uint64(j.MaxVideoChannelUsers), 10, false)
		buf.WriteByte(',')
	}
	if j.ApproximateMembers != 0 {
		buf.WriteString(`"approximate_member_count":`)
		fflib.FormatBits2(buf, uint64(j.ApproximateMembers), 10, false)
		buf.WriteByte(',')
	}
	if j.ApproximatePresences != 0 {
		buf.WriteString(`"approximate_presence_count":`)
		fflib.FormatBits2(buf, uint64(j.ApproximatePresences), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"nsfw_level":`)
	fflib.FormatBits2(buf, uint64(j.NSFWLevel), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildCreateEventbase = iota
	ffjtGuildCreateEventnosuchkey

	ffjtGuildCreateEventJoined

	ffjtGuildCreateEventLarge

	ffjtGuildCreateEventUnavailable

	ffjtGuildCreateEventMemberCount

	ffjtGuildCreateEventVoiceStates

	ffjtGuildCreateEventMembers

	ffjtGuildCreateEventChannels

	ffjtGuildCreateEventThreads

	ffjtGuildCreateEventPresences

	ffjtGuildCreateEventID

	ffjtGuildCreateEventName

	ffjtGuildCreateEventIcon

	ffjtGuildCreateEventSplash

	ffjtGuildCreateEventDiscoverySplash

	ffjtGuildCreateEventOwner

	ffjtGuildCreateEventWidget

	ffjtGuildCreateEventSystemChannelFlags

	ffjtGuildCreateEventVerification

	ffjtGuildCreateEventNotification

	ffjtGuildCreateEventExplicitFilter

	ffjtGuildCreateEventNitroBoost

	ffjtGuildCreateEventMFA

	ffjtGuildCreateEventOwnerID

	ffjtGuildCreateEventWidgetChannelID

	ffjtGuildCreateEventSystemChannelID

	ffjtGuildCreateEventPermissions

	ffjtGuildCreateEventVoiceRegion

	ffjtGuildCreateEventAFKChannelID

	ffjtGuildCreateEventAFKTimeout

	ffjtGuildCreateEventRoles

	ffjtGuildCreateEventEmojis

	ffjtGuildCreateEventFeatures

	ffjtGuildCreateEventAppID

	ffjtGuildCreateEventRulesChannelID

	ffjtGuildCreateEventMaxPresences

	ffjtGuildCreateEventMaxMembers

	ffjtGuildCreateEventVanityURLCode

	ffjtGuildCreateEventDescription

	ffjtGuildCreateEventBanner

	ffjtGuildCreateEventNitroBoosters

	ffjtGuildCreateEventPreferredLocale

	ffjtGuildCreateEventPublicUpdatesChannelID

	ffjtGuildCreateEventMaxVideoChannelUsers

	ffjtGuildCreateEventApproximateMembers

	ffjtGuildCreateEventApproximatePresences

	ffjtGuildCreateEventNSFWLevel
)

var ffjKeyGuildCreateEventJoined = []byte("joined_at")

var ffjKeyGuildCreateEventLarge = []byte("large")

var ffjKeyGuildCreateEventUnavailable = []byte("unavailable")

var ffjKeyGuildCreateEventMemberCount = []byte("member_count")

var ffjKeyGuildCreateEventVoiceStates = []byte("voice_states")

var ffjKeyGuildCreateEventMembers = []byte("members")

var ffjKeyGuildCreateEventChannels = []byte("channels")

var ffjKeyGuildCreateEventThreads = []byte("threads")

var ffjKeyGuildCreateEventPresences = []byte("presences")

var ffjKeyGuildCreateEventID = []byte("id")

var ffjKeyGuildCreateEventName = []byte("name")

var ffjKeyGuildCreateEventIcon = []byte("icon")

var ffjKeyGuildCreateEventSplash = []byte("splash")

var ffjKeyGuildCreateEventDiscoverySplash = []byte("discovery_splash")

var ffjKeyGuildCreateEventOwner = []byte("owner")

var ffjKeyGuildCreateEventWidget = []byte("widget_enabled")

var ffjKeyGuildCreateEventSystemChannelFlags = []byte("system_channel_flags")

var ffjKeyGuildCreateEventVerification = []byte("verification_level")

var ffjKeyGuildCreateEventNotification = []byte("default_message_notifications")

var ffjKeyGuildCreateEventExplicitFilter = []byte("explicit_content_filter")

var ffjKeyGuildCreateEventNitroBoost = []byte("premium_tier")

var ffjKeyGuildCreateEventMFA = []byte("mfa_level")

var ffjKeyGuildCreateEventOwnerID = []byte("owner_id")

var ffjKeyGuildCreateEventWidgetChannelID = []byte("widget_channel_id")

var ffjKeyGuildCreateEventSystemChannelID = []byte("system_channel_id")

var ffjKeyGuildCreateEventPermissions = []byte("permissions")

var ffjKeyGuildCreateEventVoiceRegion = []byte("region")

var ffjKeyGuildCreateEventAFKChannelID = []byte("afk_channel_id")

var ffjKeyGuildCreateEventAFKTimeout = []byte("afk_timeout")

var ffjKeyGuildCreateEventRoles = []byte("roles")

var ffjKeyGuildCreateEventEmojis = []byte("emojis")

var ffjKeyGuildCreateEventFeatures = []byte("features")

var ffjKeyGuildCreateEventAppID = []byte("application_id")

var ffjKeyGuildCreateEventRulesChannelID = []byte("rules_channel_id")

var ffjKeyGuildCreateEventMaxPresences = []byte("max_presences")

var ffjKeyGuildCreateEventMaxMembers = []byte("max_members")

var ffjKeyGuildCreateEventVanityURLCode = []byte("vanity_url_code")

var ffjKeyGuildCreateEventDescription = []byte("description")

var ffjKeyGuildCreateEventBanner = []byte("banner")

var ffjKeyGuildCreateEventNitroBoosters = []byte("premium_subscription_count")

var ffjKeyGuildCreateEventPreferredLocale = []byte("preferred_locale")

var ffjKeyGuildCreateEventPublicUpdatesChannelID = []byte("public_updates_channel_id")

var ffjKeyGuildCreateEventMaxVideoChannelUsers = []byte("max_video_channel_users")

var ffjKeyGuildCreateEventApproximateMembers = []byte("approximate_member_count")

var ffjKeyGuildCreateEventApproximatePresences = []byte("approximate_presence_count")

var ffjKeyGuildCreateEventNSFWLevel = []byte("nsfw_level")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildCreateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildCreateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildCreateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildCreateEventAFKChannelID, kn) {
						currentKey = ffjtGuildCreateEventAFKChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventAFKTimeout, kn) {
						currentKey = ffjtGuildCreateEventAFKTimeout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventAppID, kn) {
						currentKey = ffjtGuildCreateEventAppID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventApproximateMembers, kn) {
						currentKey = ffjtGuildCreateEventApproximateMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventApproximatePresences, kn) {
						currentKey = ffjtGuildCreateEventApproximatePresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyGuildCreateEventBanner, kn) {
						currentKey = ffjtGuildCreateEventBanner
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyGuildCreateEventChannels, kn) {
						currentKey = ffjtGuildCreateEventChannels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildCreateEventDiscoverySplash, kn) {
						currentKey = ffjtGuildCreateEventDiscoverySplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventNotification, kn) {
						currentKey = ffjtGuildCreateEventNotification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventDescription, kn) {
						currentKey = ffjtGuildCreateEventDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildCreateEventExplicitFilter, kn) {
						currentKey = ffjtGuildCreateEventExplicitFilter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventEmojis, kn) {
						currentKey = ffjtGuildCreateEventEmojis
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyGuildCreateEventFeatures, kn) {
						currentKey = ffjtGuildCreateEventFeatures
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildCreateEventID, kn) {
						currentKey = ffjtGuildCreateEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventIcon, kn) {
						currentKey = ffjtGuildCreateEventIcon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffjKeyGuildCreateEventJoined, kn) {
						currentKey = ffjtGuildCreateEventJoined
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyGuildCreateEventLarge, kn) {
						currentKey = ffjtGuildCreateEventLarge
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildCreateEventMemberCount, kn) {
						currentKey = ffjtGuildCreateEventMemberCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventMembers, kn) {
						currentKey = ffjtGuildCreateEventMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventMFA, kn) {
						currentKey = ffjtGuildCreateEventMFA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventMaxPresences, kn) {
						currentKey = ffjtGuildCreateEventMaxPresences
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventMaxMembers, kn) {
						currentKey = ffjtGuildCreateEventMaxMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventMaxVideoChannelUsers, kn) {
						currentKey = ffjtGuildCreateEventMaxVideoChannelUsers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildCreateEventName, kn) {
						currentKey = ffjtGuildCreateEventName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventNSFWLevel, kn) {
						currentKey = ffjtGuildCreateEventNSFWLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyGuildCreateEventOwner, kn) {
						currentKey = ffjtGuildCreateEventOwner
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventOwnerID, kn) {
						currentKey = ffjtGuildCreateEventOwnerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildCreateEventPresences, kn) {
						currentKey = ffjtGuildCreateEventPresences
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventNitroBoost, kn) {
						currentKey = ffjtGuildCreateEventNitroBoost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventPermissions, kn) {
						currentKey = ffjtGuildCreateEventPermissions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventNitroBoosters, kn) {
						currentKey = ffjtGuildCreateEventNitroBoosters
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventPreferredLocale, kn) {
						currentKey = ffjtGuildCreateEventPreferredLocale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventPublicUpdatesChannelID, kn) {
						currentKey = ffjtGuildCreateEventPublicUpdatesChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildCreateEventVoiceRegion, kn) {
						currentKey = ffjtGuildCreateEventVoiceRegion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventRoles, kn) {
						currentKey = ffjtGuildCreateEventRoles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventRulesChannelID, kn) {
						currentKey = ffjtGuildCreateEventRulesChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildCreateEventSplash, kn) {
						currentKey = ffjtGuildCreateEventSplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventSystemChannelFlags, kn) {
						currentKey = ffjtGuildCreateEventSystemChannelFlags
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventSystemChannelID, kn) {
						currentKey = ffjtGuildCreateEventSystemChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyGuildCreateEventThreads, kn) {
						currentKey = ffjtGuildCreateEventThreads
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildCreateEventUnavailable, kn) {
						currentKey = ffjtGuildCreateEventUnavailable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyGuildCreateEventVoiceStates, kn) {
						currentKey = ffjtGuildCreateEventVoiceStates
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventVerification, kn) {
						currentKey = ffjtGuildCreateEventVerification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventVanityURLCode, kn) {
						currentKey = ffjtGuildCreateEventVanityURLCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyGuildCreateEventWidget, kn) {
						currentKey = ffjtGuildCreateEventWidget
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildCreateEventWidgetChannelID, kn) {
						currentKey = ffjtGuildCreateEventWidgetChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventNSFWLevel, kn) {
					currentKey = ffjtGuildCreateEventNSFWLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventApproximatePresences, kn) {
					currentKey = ffjtGuildCreateEventApproximatePresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventApproximateMembers, kn) {
					currentKey = ffjtGuildCreateEventApproximateMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventMaxVideoChannelUsers, kn) {
					currentKey = ffjtGuildCreateEventMaxVideoChannelUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventPublicUpdatesChannelID, kn) {
					currentKey = ffjtGuildCreateEventPublicUpdatesChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventPreferredLocale, kn) {
					currentKey = ffjtGuildCreateEventPreferredLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventNitroBoosters, kn) {
					currentKey = ffjtGuildCreateEventNitroBoosters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventBanner, kn) {
					currentKey = ffjtGuildCreateEventBanner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventDescription, kn) {
					currentKey = ffjtGuildCreateEventDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventVanityURLCode, kn) {
					currentKey = ffjtGuildCreateEventVanityURLCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventMaxMembers, kn) {
					currentKey = ffjtGuildCreateEventMaxMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventMaxPresences, kn) {
					currentKey = ffjtGuildCreateEventMaxPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventRulesChannelID, kn) {
					currentKey = ffjtGuildCreateEventRulesChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventAppID, kn) {
					currentKey = ffjtGuildCreateEventAppID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventFeatures, kn) {
					currentKey = ffjtGuildCreateEventFeatures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventEmojis, kn) {
					currentKey = ffjtGuildCreateEventEmojis
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventRoles, kn) {
					currentKey = ffjtGuildCreateEventRoles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventAFKTimeout, kn) {
					currentKey = ffjtGuildCreateEventAFKTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventAFKChannelID, kn) {
					currentKey = ffjtGuildCreateEventAFKChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventVoiceRegion, kn) {
					currentKey = ffjtGuildCreateEventVoiceRegion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventPermissions, kn) {
					currentKey = ffjtGuildCreateEventPermissions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventSystemChannelID, kn) {
					currentKey = ffjtGuildCreateEventSystemChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventWidgetChannelID, kn) {
					currentKey = ffjtGuildCreateEventWidgetChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventOwnerID, kn) {
					currentKey = ffjtGuildCreateEventOwnerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventMFA, kn) {
					currentKey = ffjtGuildCreateEventMFA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventNitroBoost, kn) {
					currentKey = ffjtGuildCreateEventNitroBoost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventExplicitFilter, kn) {
					currentKey = ffjtGuildCreateEventExplicitFilter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventNotification, kn) {
					currentKey = ffjtGuildCreateEventNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventVerification, kn) {
					currentKey = ffjtGuildCreateEventVerification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventSystemChannelFlags, kn) {
					currentKey = ffjtGuildCreateEventSystemChannelFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventWidget, kn) {
					currentKey = ffjtGuildCreateEventWidget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventOwner, kn) {
					currentKey = ffjtGuildCreateEventOwner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventDiscoverySplash, kn) {
					currentKey = ffjtGuildCreateEventDiscoverySplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventSplash, kn) {
					currentKey = ffjtGuildCreateEventSplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventIcon, kn) {
					currentKey = ffjtGuildCreateEventIcon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventName, kn) {
					currentKey = ffjtGuildCreateEventName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventID, kn) {
					currentKey = ffjtGuildCreateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventPresences, kn) {
					currentKey = ffjtGuildCreateEventPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventThreads, kn) {
					currentKey = ffjtGuildCreateEventThreads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventChannels, kn) {
					currentKey = ffjtGuildCreateEventChannels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventMembers, kn) {
					currentKey = ffjtGuildCreateEventMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildCreateEventVoiceStates, kn) {
					currentKey = ffjtGuildCreateEventVoiceStates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventMemberCount, kn) {
					currentKey = ffjtGuildCreateEventMemberCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventUnavailable, kn) {
					currentKey = ffjtGuildCreateEventUnavailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildCreateEventLarge, kn) {
					currentKey = ffjtGuildCreateEventLarge
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildCreateEventJoined, kn) {
					currentKey = ffjtGuildCreateEventJoined
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildCreateEventJoined:
					goto handle_Joined

				case ffjtGuildCreateEventLarge:
					goto handle_Large

				case ffjtGuildCreateEventUnavailable:
					goto handle_Unavailable

				case ffjtGuildCreateEventMemberCount:
					goto handle_MemberCount

				case ffjtGuildCreateEventVoiceStates:
					goto handle_VoiceStates

				case ffjtGuildCreateEventMembers:
					goto handle_Members

				case ffjtGuildCreateEventChannels:
					goto handle_Channels

				case ffjtGuildCreateEventThreads:
					goto handle_Threads

				case ffjtGuildCreateEventPresences:
					goto handle_Presences

				case ffjtGuildCreateEventID:
					goto handle_ID

				case ffjtGuildCreateEventName:
					goto handle_Name

				case ffjtGuildCreateEventIcon:
					goto handle_Icon

				case ffjtGuildCreateEventSplash:
					goto handle_Splash

				case ffjtGuildCreateEventDiscoverySplash:
					goto handle_DiscoverySplash

				case ffjtGuildCreateEventOwner:
					goto handle_Owner

				case ffjtGuildCreateEventWidget:
					goto handle_Widget

				case ffjtGuildCreateEventSystemChannelFlags:
					goto handle_SystemChannelFlags

				case ffjtGuildCreateEventVerification:
					goto handle_Verification

				case ffjtGuildCreateEventNotification:
					goto handle_Notification

				case ffjtGuildCreateEventExplicitFilter:
					goto handle_ExplicitFilter

				case ffjtGuildCreateEventNitroBoost:
					goto handle_NitroBoost

				case ffjtGuildCreateEventMFA:
					goto handle_MFA

				case ffjtGuildCreateEventOwnerID:
					goto handle_OwnerID

				case ffjtGuildCreateEventWidgetChannelID:
					goto handle_WidgetChannelID

				case ffjtGuildCreateEventSystemChannelID:
					goto handle_SystemChannelID

				case ffjtGuildCreateEventPermissions:
					goto handle_Permissions

				case ffjtGuildCreateEventVoiceRegion:
					goto handle_VoiceRegion

				case ffjtGuildCreateEventAFKChannelID:
					goto handle_AFKChannelID

				case ffjtGuildCreateEventAFKTimeout:
					goto handle_AFKTimeout

				case ffjtGuildCreateEventRoles:
					goto handle_Roles

				case ffjtGuildCreateEventEmojis:
					goto handle_Emojis

				case ffjtGuildCreateEventFeatures:
					goto handle_Features

				case ffjtGuildCreateEventAppID:
					goto handle_AppID

				case ffjtGuildCreateEventRulesChannelID:
					goto handle_RulesChannelID

				case ffjtGuildCreateEventMaxPresences:
					goto handle_MaxPresences

				case ffjtGuildCreateEventMaxMembers:
					goto handle_MaxMembers

				case ffjtGuildCreateEventVanityURLCode:
					goto handle_VanityURLCode

				case ffjtGuildCreateEventDescription:
					goto handle_Description

				case ffjtGuildCreateEventBanner:
					goto handle_Banner

				case ffjtGuildCreateEventNitroBoosters:
					goto handle_NitroBoosters

				case ffjtGuildCreateEventPreferredLocale:
					goto handle_PreferredLocale

				case ffjtGuildCreateEventPublicUpdatesChannelID:
					goto handle_PublicUpdatesChannelID

				case ffjtGuildCreateEventMaxVideoChannelUsers:
					goto handle_MaxVideoChannelUsers

				case ffjtGuildCreateEventApproximateMembers:
					goto handle_ApproximateMembers

				case ffjtGuildCreateEventApproximatePresences:
					goto handle_ApproximatePresences

				case ffjtGuildCreateEventNSFWLevel:
					goto handle_NSFWLevel

				case ffjtGuildCreateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Joined:

	/* handler: j.Joined type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Joined.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Large:

	/* handler: j.Large type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Large = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Large = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailable:

	/* handler: j.Unavailable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Unavailable = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Unavailable = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemberCount:

	/* handler: j.MemberCount type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MemberCount = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceStates:

	/* handler: j.VoiceStates type=[]discord.VoiceState kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.VoiceStates = nil
		} else {

			j.VoiceStates = []discord.VoiceState{}

			wantVal := true

			for {

				var tmpJVoiceStates discord.VoiceState

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJVoiceStates type=discord.VoiceState kind=struct quoted=false*/

				{
					/* Falling back. type=discord.VoiceState kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJVoiceStates)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.VoiceStates = append(j.VoiceStates, tmpJVoiceStates)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Members:

	/* handler: j.Members type=[]discord.Member kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Members = nil
		} else {

			j.Members = []discord.Member{}

			wantVal := true

			for {

				var tmpJMembers discord.Member

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMembers type=discord.Member kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Members = append(j.Members, tmpJMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Channels:

	/* handler: j.Channels type=[]discord.Channel kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Channels = nil
		} else {

			j.Channels = []discord.Channel{}

			wantVal := true

			for {

				var tmpJChannels discord.Channel

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChannels type=discord.Channel kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJChannels.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Channels = append(j.Channels, tmpJChannels)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Threads:

	/* handler: j.Threads type=[]discord.Channel kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Threads = nil
		} else {

			j.Threads = []discord.Channel{}

			wantVal := true

			for {

				var tmpJThreads discord.Channel

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJThreads type=discord.Channel kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJThreads.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Threads = append(j.Threads, tmpJThreads)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Presences:

	/* handler: j.Presences type=[]discord.Presence kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Presences = nil
		} else {

			j.Presences = []discord.Presence{}

			wantVal := true

			for {

				var tmpJPresences discord.Presence

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPresences type=discord.Presence kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPresences.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Presences = append(j.Presences, tmpJPresences)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icon:

	/* handler: j.Icon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Icon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Splash:

	/* handler: j.Splash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Splash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiscoverySplash:

	/* handler: j.DiscoverySplash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DiscoverySplash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Owner:

	/* handler: j.Owner type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Owner = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Owner = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Widget:

	/* handler: j.Widget type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Widget = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Widget = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemChannelFlags:

	/* handler: j.SystemChannelFlags type=discord.SystemChannelFlags kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for SystemChannelFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SystemChannelFlags = discord.SystemChannelFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Verification:

	/* handler: j.Verification type=discord.Verification kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Verification.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notification:

	/* handler: j.Notification type=discord.Notification kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Notification.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExplicitFilter:

	/* handler: j.ExplicitFilter type=discord.ExplicitFilter kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ExplicitFilter.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NitroBoost:

	/* handler: j.NitroBoost type=discord.NitroBoost kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NitroBoost", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NitroBoost = discord.NitroBoost(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MFA:

	/* handler: j.MFA type=discord.MFALevel kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MFALevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MFA = discord.MFALevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerID:

	/* handler: j.OwnerID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.OwnerID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WidgetChannelID:

	/* handler: j.WidgetChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WidgetChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemChannelID:

	/* handler: j.SystemChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.SystemChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Permissions:

	/* handler: j.Permissions type=discord.Permissions kind=uint64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Permissions", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Permissions = discord.Permissions(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceRegion:

	/* handler: j.VoiceRegion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VoiceRegion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFKChannelID:

	/* handler: j.AFKChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AFKChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFKTimeout:

	/* handler: j.AFKTimeout type=discord.Seconds kind=int quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AFKTimeout.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Roles:

	/* handler: j.Roles type=[]discord.Role kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Roles = nil
		} else {

			j.Roles = []discord.Role{}

			wantVal := true

			for {

				var tmpJRoles discord.Role

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoles type=discord.Role kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJRoles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Roles = append(j.Roles, tmpJRoles)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emojis:

	/* handler: j.Emojis type=[]discord.Emoji kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Emojis = nil
		} else {

			j.Emojis = []discord.Emoji{}

			wantVal := true

			for {

				var tmpJEmojis discord.Emoji

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmojis type=discord.Emoji kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJEmojis.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Emojis = append(j.Emojis, tmpJEmojis)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Features:

	/* handler: j.Features type=[]discord.GuildFeature kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Features = nil
		} else {

			j.Features = []discord.GuildFeature{}

			wantVal := true

			for {

				var tmpJFeatures discord.GuildFeature

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFeatures type=discord.GuildFeature kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for GuildFeature", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJFeatures = discord.GuildFeature(string(outBuf))

					}
				}

				j.Features = append(j.Features, tmpJFeatures)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppID:

	/* handler: j.AppID type=discord.AppID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AppID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RulesChannelID:

	/* handler: j.RulesChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.RulesChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxPresences:

	/* handler: j.MaxPresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxPresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxMembers:

	/* handler: j.MaxMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VanityURLCode:

	/* handler: j.VanityURLCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VanityURLCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Banner:

	/* handler: j.Banner type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Banner = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NitroBoosters:

	/* handler: j.NitroBoosters type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NitroBoosters = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreferredLocale:

	/* handler: j.PreferredLocale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PreferredLocale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PublicUpdatesChannelID:

	/* handler: j.PublicUpdatesChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.PublicUpdatesChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxVideoChannelUsers:

	/* handler: j.MaxVideoChannelUsers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxVideoChannelUsers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximateMembers:

	/* handler: j.ApproximateMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximateMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximatePresences:

	/* handler: j.ApproximatePresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximatePresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NSFWLevel:

	/* handler: j.NSFWLevel type=discord.NSFWLevel kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NSFWLevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NSFWLevel = discord.NSFWLevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Unavailable {
		buf.WriteString(`,"unavailable":true`)
	} else {
		buf.WriteString(`,"unavailable":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildDeleteEventbase = iota
	ffjtGuildDeleteEventnosuchkey

	ffjtGuildDeleteEventID

	ffjtGuildDeleteEventUnavailable
)

var ffjKeyGuildDeleteEventID = []byte("id")

var ffjKeyGuildDeleteEventUnavailable = []byte("unavailable")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildDeleteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildDeleteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildDeleteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyGuildDeleteEventID, kn) {
						currentKey = ffjtGuildDeleteEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildDeleteEventUnavailable, kn) {
						currentKey = ffjtGuildDeleteEventUnavailable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildDeleteEventUnavailable, kn) {
					currentKey = ffjtGuildDeleteEventUnavailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildDeleteEventID, kn) {
					currentKey = ffjtGuildDeleteEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildDeleteEventID:
					goto handle_ID

				case ffjtGuildDeleteEventUnavailable:
					goto handle_Unavailable

				case ffjtGuildDeleteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailable:

	/* handler: j.Unavailable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Unavailable = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Unavailable = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildEmojisUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildEmojisUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"emojis":`)
	if j.Emojis != nil {
		buf.WriteString(`[`)
		for i, v := range j.Emojis {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildEmojisUpdateEventbase = iota
	ffjtGuildEmojisUpdateEventnosuchkey

	ffjtGuildEmojisUpdateEventGuildID

	ffjtGuildEmojisUpdateEventEmojis
)

var ffjKeyGuildEmojisUpdateEventGuildID = []byte("guild_id")

var ffjKeyGuildEmojisUpdateEventEmojis = []byte("emojis")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildEmojisUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildEmojisUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildEmojisUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildEmojisUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyGuildEmojisUpdateEventEmojis, kn) {
						currentKey = ffjtGuildEmojisUpdateEventEmojis
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildEmojisUpdateEventGuildID, kn) {
						currentKey = ffjtGuildEmojisUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildEmojisUpdateEventEmojis, kn) {
					currentKey = ffjtGuildEmojisUpdateEventEmojis
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildEmojisUpdateEventGuildID, kn) {
					currentKey = ffjtGuildEmojisUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildEmojisUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildEmojisUpdateEventGuildID:
					goto handle_GuildID

				case ffjtGuildEmojisUpdateEventEmojis:
					goto handle_Emojis

				case ffjtGuildEmojisUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emojis:

	/* handler: j.Emojis type=[]discord.Emoji kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Emojis = nil
		} else {

			j.Emojis = []discord.Emoji{}

			wantVal := true

			for {

				var tmpJEmojis discord.Emoji

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmojis type=discord.Emoji kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJEmojis.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Emojis = append(j.Emojis, tmpJEmojis)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildFolder) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildFolder) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_ids":`)
	if j.GuildIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.GuildIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"color":`)

	{

		obj, err = j.Color.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildFolderbase = iota
	ffjtGuildFoldernosuchkey

	ffjtGuildFolderName

	ffjtGuildFolderID

	ffjtGuildFolderGuildIDs

	ffjtGuildFolderColor
)

var ffjKeyGuildFolderName = []byte("name")

var ffjKeyGuildFolderID = []byte("id")

var ffjKeyGuildFolderGuildIDs = []byte("guild_ids")

var ffjKeyGuildFolderColor = []byte("color")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildFolder) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildFolder) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildFolderbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildFoldernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildFolderColor, kn) {
						currentKey = ffjtGuildFolderColor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildFolderGuildIDs, kn) {
						currentKey = ffjtGuildFolderGuildIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildFolderID, kn) {
						currentKey = ffjtGuildFolderID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildFolderName, kn) {
						currentKey = ffjtGuildFolderName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildFolderColor, kn) {
					currentKey = ffjtGuildFolderColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildFolderGuildIDs, kn) {
					currentKey = ffjtGuildFolderGuildIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildFolderID, kn) {
					currentKey = ffjtGuildFolderID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildFolderName, kn) {
					currentKey = ffjtGuildFolderName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildFoldernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildFolderName:
					goto handle_Name

				case ffjtGuildFolderID:
					goto handle_ID

				case ffjtGuildFolderGuildIDs:
					goto handle_GuildIDs

				case ffjtGuildFolderColor:
					goto handle_Color

				case ffjtGuildFoldernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=gateway.GuildFolderID kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildIDs:

	/* handler: j.GuildIDs type=[]discord.GuildID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GuildIDs = nil
		} else {

			j.GuildIDs = []discord.GuildID{}

			wantVal := true

			for {

				var tmpJGuildIDs discord.GuildID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuildIDs type=discord.GuildID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJGuildIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.GuildIDs = append(j.GuildIDs, tmpJGuildIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Color:

	/* handler: j.Color type=discord.Color kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Color.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildIntegrationsUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildIntegrationsUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildIntegrationsUpdateEventbase = iota
	ffjtGuildIntegrationsUpdateEventnosuchkey

	ffjtGuildIntegrationsUpdateEventGuildID
)

var ffjKeyGuildIntegrationsUpdateEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildIntegrationsUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildIntegrationsUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildIntegrationsUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildIntegrationsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildIntegrationsUpdateEventGuildID, kn) {
						currentKey = ffjtGuildIntegrationsUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyGuildIntegrationsUpdateEventGuildID, kn) {
					currentKey = ffjtGuildIntegrationsUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildIntegrationsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildIntegrationsUpdateEventGuildID:
					goto handle_GuildID

				case ffjtGuildIntegrationsUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberAddEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberAddEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if len(j.Nick) != 0 {
		buf.WriteString(`"nick":`)
		fflib.WriteJsonString(buf, string(j.Nick))
		buf.WriteByte(',')
	}
	buf.WriteString(`"roles":`)
	if j.RoleIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.RoleIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.Avatar) != 0 {
		buf.WriteString(`"avatar":`)
		fflib.WriteJsonString(buf, string(j.Avatar))
		buf.WriteByte(',')
	}
	buf.WriteString(`"joined_at":`)

	{

		obj, err = j.Joined.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"premium_since":`)

		{

			obj, err = j.BoostedSince.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"communication_disabled_until":`)

	{

		obj, err = j.CommunicationDisabledUntil.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Deaf {
		buf.WriteString(`,"deaf":true`)
	} else {
		buf.WriteString(`,"deaf":false`)
	}
	if j.Mute {
		buf.WriteString(`,"mute":true`)
	} else {
		buf.WriteString(`,"mute":false`)
	}
	buf.WriteString(`,"flags":`)
	fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
	if j.IsPending {
		buf.WriteString(`,"pending":true`)
	} else {
		buf.WriteString(`,"pending":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberAddEventbase = iota
	ffjtGuildMemberAddEventnosuchkey

	ffjtGuildMemberAddEventGuildID

	ffjtGuildMemberAddEventUser

	ffjtGuildMemberAddEventNick

	ffjtGuildMemberAddEventRoleIDs

	ffjtGuildMemberAddEventAvatar

	ffjtGuildMemberAddEventJoined

	ffjtGuildMemberAddEventBoostedSince

	ffjtGuildMemberAddEventCommunicationDisabledUntil

	ffjtGuildMemberAddEventDeaf

	ffjtGuildMemberAddEventMute

	ffjtGuildMemberAddEventFlags

	ffjtGuildMemberAddEventIsPending
)

var ffjKeyGuildMemberAddEventGuildID = []byte("guild_id")

var ffjKeyGuildMemberAddEventUser = []byte("user")

var ffjKeyGuildMemberAddEventNick = []byte("nick")

var ffjKeyGuildMemberAddEventRoleIDs = []byte("roles")

var ffjKeyGuildMemberAddEventAvatar = []byte("avatar")

var ffjKeyGuildMemberAddEventJoined = []byte("joined_at")

var ffjKeyGuildMemberAddEventBoostedSince = []byte("premium_since")

var ffjKeyGuildMemberAddEventCommunicationDisabledUntil = []byte("communication_disabled_until")

var ffjKeyGuildMemberAddEventDeaf = []byte("deaf")

var ffjKeyGuildMemberAddEventMute = []byte("mute")

var ffjKeyGuildMemberAddEventFlags = []byte("flags")

var ffjKeyGuildMemberAddEventIsPending = []byte("pending")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberAddEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberAddEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberAddEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildMemberAddEventAvatar, kn) {
						currentKey = ffjtGuildMemberAddEventAvatar
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyGuildMemberAddEventCommunicationDisabledUntil, kn) {
						currentKey = ffjtGuildMemberAddEventCommunicationDisabledUntil
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildMemberAddEventDeaf, kn) {
						currentKey = ffjtGuildMemberAddEventDeaf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyGuildMemberAddEventFlags, kn) {
						currentKey = ffjtGuildMemberAddEventFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildMemberAddEventGuildID, kn) {
						currentKey = ffjtGuildMemberAddEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffjKeyGuildMemberAddEventJoined, kn) {
						currentKey = ffjtGuildMemberAddEventJoined
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildMemberAddEventMute, kn) {
						currentKey = ffjtGuildMemberAddEventMute
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildMemberAddEventNick, kn) {
						currentKey = ffjtGuildMemberAddEventNick
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildMemberAddEventBoostedSince, kn) {
						currentKey = ffjtGuildMemberAddEventBoostedSince
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMemberAddEventIsPending, kn) {
						currentKey = ffjtGuildMemberAddEventIsPending
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildMemberAddEventRoleIDs, kn) {
						currentKey = ffjtGuildMemberAddEventRoleIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildMemberAddEventUser, kn) {
						currentKey = ffjtGuildMemberAddEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberAddEventIsPending, kn) {
					currentKey = ffjtGuildMemberAddEventIsPending
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberAddEventFlags, kn) {
					currentKey = ffjtGuildMemberAddEventFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberAddEventMute, kn) {
					currentKey = ffjtGuildMemberAddEventMute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberAddEventDeaf, kn) {
					currentKey = ffjtGuildMemberAddEventDeaf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberAddEventCommunicationDisabledUntil, kn) {
					currentKey = ffjtGuildMemberAddEventCommunicationDisabledUntil
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberAddEventBoostedSince, kn) {
					currentKey = ffjtGuildMemberAddEventBoostedSince
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberAddEventJoined, kn) {
					currentKey = ffjtGuildMemberAddEventJoined
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberAddEventAvatar, kn) {
					currentKey = ffjtGuildMemberAddEventAvatar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberAddEventRoleIDs, kn) {
					currentKey = ffjtGuildMemberAddEventRoleIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberAddEventNick, kn) {
					currentKey = ffjtGuildMemberAddEventNick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberAddEventUser, kn) {
					currentKey = ffjtGuildMemberAddEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberAddEventGuildID, kn) {
					currentKey = ffjtGuildMemberAddEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberAddEventGuildID:
					goto handle_GuildID

				case ffjtGuildMemberAddEventUser:
					goto handle_User

				case ffjtGuildMemberAddEventNick:
					goto handle_Nick

				case ffjtGuildMemberAddEventRoleIDs:
					goto handle_RoleIDs

				case ffjtGuildMemberAddEventAvatar:
					goto handle_Avatar

				case ffjtGuildMemberAddEventJoined:
					goto handle_Joined

				case ffjtGuildMemberAddEventBoostedSince:
					goto handle_BoostedSince

				case ffjtGuildMemberAddEventCommunicationDisabledUntil:
					goto handle_CommunicationDisabledUntil

				case ffjtGuildMemberAddEventDeaf:
					goto handle_Deaf

				case ffjtGuildMemberAddEventMute:
					goto handle_Mute

				case ffjtGuildMemberAddEventFlags:
					goto handle_Flags

				case ffjtGuildMemberAddEventIsPending:
					goto handle_IsPending

				case ffjtGuildMemberAddEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nick:

	/* handler: j.Nick type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nick = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RoleIDs:

	/* handler: j.RoleIDs type=[]discord.RoleID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RoleIDs = nil
		} else {

			j.RoleIDs = []discord.RoleID{}

			wantVal := true

			for {

				var tmpJRoleIDs discord.RoleID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoleIDs type=discord.RoleID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRoleIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RoleIDs = append(j.RoleIDs, tmpJRoleIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Avatar:

	/* handler: j.Avatar type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Avatar = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Joined:

	/* handler: j.Joined type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Joined.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BoostedSince:

	/* handler: j.BoostedSince type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BoostedSince.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommunicationDisabledUntil:

	/* handler: j.CommunicationDisabledUntil type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommunicationDisabledUntil.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deaf:

	/* handler: j.Deaf type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Deaf = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Deaf = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mute:

	/* handler: j.Mute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flags:

	/* handler: j.Flags type=discord.MemberFlags kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MemberFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Flags = discord.MemberFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPending:

	/* handler: j.IsPending type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsPending = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsPending = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberListGroup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberListGroup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"count":`)
	fflib.FormatBits2(buf, uint64(j.Count), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberListGroupbase = iota
	ffjtGuildMemberListGroupnosuchkey

	ffjtGuildMemberListGroupID

	ffjtGuildMemberListGroupCount
)

var ffjKeyGuildMemberListGroupID = []byte("id")

var ffjKeyGuildMemberListGroupCount = []byte("count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberListGroup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberListGroup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberListGroupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberListGroupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildMemberListGroupCount, kn) {
						currentKey = ffjtGuildMemberListGroupCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildMemberListGroupID, kn) {
						currentKey = ffjtGuildMemberListGroupID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListGroupCount, kn) {
					currentKey = ffjtGuildMemberListGroupCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListGroupID, kn) {
					currentKey = ffjtGuildMemberListGroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberListGroupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberListGroupID:
					goto handle_ID

				case ffjtGuildMemberListGroupCount:
					goto handle_Count

				case ffjtGuildMemberListGroupnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Count:

	/* handler: j.Count type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Count = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberListOp) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberListOp) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "op":`)
	fflib.WriteJsonString(buf, string(j.Op))
	buf.WriteByte(',')
	if j.Index != 0 {
		buf.WriteString(`"index":`)
		fflib.FormatBits2(buf, uint64(j.Index), 10, j.Index < 0)
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"item":`)

		{

			err = j.Item.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	if len(j.Range) != 0 {
		buf.WriteString(`"range":`)
		buf.WriteString(`[`)
		for i, v := range j.Range {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
		buf.WriteByte(',')
	}
	if len(j.Items) != 0 {
		buf.WriteString(`"items":`)
		if j.Items != nil {
			buf.WriteString(`[`)
			for i, v := range j.Items {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberListOpbase = iota
	ffjtGuildMemberListOpnosuchkey

	ffjtGuildMemberListOpOp

	ffjtGuildMemberListOpIndex

	ffjtGuildMemberListOpItem

	ffjtGuildMemberListOpRange

	ffjtGuildMemberListOpItems
)

var ffjKeyGuildMemberListOpOp = []byte("op")

var ffjKeyGuildMemberListOpIndex = []byte("index")

var ffjKeyGuildMemberListOpItem = []byte("item")

var ffjKeyGuildMemberListOpRange = []byte("range")

var ffjKeyGuildMemberListOpItems = []byte("items")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberListOp) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberListOp) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberListOpbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberListOpnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyGuildMemberListOpIndex, kn) {
						currentKey = ffjtGuildMemberListOpIndex
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMemberListOpItem, kn) {
						currentKey = ffjtGuildMemberListOpItem
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMemberListOpItems, kn) {
						currentKey = ffjtGuildMemberListOpItems
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyGuildMemberListOpOp, kn) {
						currentKey = ffjtGuildMemberListOpOp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildMemberListOpRange, kn) {
						currentKey = ffjtGuildMemberListOpRange
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberListOpItems, kn) {
					currentKey = ffjtGuildMemberListOpItems
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListOpRange, kn) {
					currentKey = ffjtGuildMemberListOpRange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListOpItem, kn) {
					currentKey = ffjtGuildMemberListOpItem
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListOpIndex, kn) {
					currentKey = ffjtGuildMemberListOpIndex
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListOpOp, kn) {
					currentKey = ffjtGuildMemberListOpOp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberListOpnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberListOpOp:
					goto handle_Op

				case ffjtGuildMemberListOpIndex:
					goto handle_Index

				case ffjtGuildMemberListOpItem:
					goto handle_Item

				case ffjtGuildMemberListOpRange:
					goto handle_Range

				case ffjtGuildMemberListOpItems:
					goto handle_Items

				case ffjtGuildMemberListOpnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Op:

	/* handler: j.Op type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Op = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Index:

	/* handler: j.Index type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Index = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Item:

	/* handler: j.Item type=gateway.GuildMemberListOpItem kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Item.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Range:

	/* handler: j.Range type=[2]int kind=array quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		j.Range = [2]int{}

		if tok != fflib.FFTok_null {
			wantVal := true

			idx := 0
			for {

				var tmpJRange int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRange type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJRange = int(tval)

					}
				}

				// Standard json.Unmarshal ignores elements out of array bounds,
				// that what we do as well.
				if idx < 2 {
					j.Range[idx] = tmpJRange
					idx++
				}

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: j.Items type=[]gateway.GuildMemberListOpItem kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Items = nil
		} else {

			j.Items = []GuildMemberListOpItem{}

			wantVal := true

			for {

				var tmpJItems GuildMemberListOpItem

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJItems type=gateway.GuildMemberListOpItem kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJItems.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Items = append(j.Items, tmpJItems)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberListOpItem) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberListOpItem) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.Group != nil {
		if true {
			buf.WriteString(`"group":`)

			{

				err = j.Group.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberListOpItembase = iota
	ffjtGuildMemberListOpItemnosuchkey

	ffjtGuildMemberListOpItemGroup

	ffjtGuildMemberListOpItemMember
)

var ffjKeyGuildMemberListOpItemGroup = []byte("group")

var ffjKeyGuildMemberListOpItemMember = []byte("member")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberListOpItem) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberListOpItem) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberListOpItembase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberListOpItemnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildMemberListOpItemGroup, kn) {
						currentKey = ffjtGuildMemberListOpItemGroup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildMemberListOpItemMember, kn) {
						currentKey = ffjtGuildMemberListOpItemMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListOpItemMember, kn) {
					currentKey = ffjtGuildMemberListOpItemMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListOpItemGroup, kn) {
					currentKey = ffjtGuildMemberListOpItemGroup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberListOpItemnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberListOpItemGroup:
					goto handle_Group

				case ffjtGuildMemberListOpItemMember:
					goto handle_Member

				case ffjtGuildMemberListOpItemnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Group:

	/* handler: j.Group type=gateway.GuildMemberListGroup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Group = nil

		} else {

			if j.Group == nil {
				j.Group = new(GuildMemberListGroup)
			}

			err = j.Group.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Member:

	/* handler: j.Member type=struct { discord.Member; HoistedRole string "json:\"hoisted_role\""; Presence discord.Presence "json:\"presence\"" } kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(struct {
					discord.Member
					HoistedRole string           "json:\"hoisted_role\""
					Presence    discord.Presence "json:\"presence\""
				})
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberListUpdate) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberListUpdate) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"member_count":`)
	fflib.FormatBits2(buf, uint64(j.MemberCount), 10, false)
	buf.WriteString(`,"online_count":`)
	fflib.FormatBits2(buf, uint64(j.OnlineCount), 10, false)
	buf.WriteString(`,"groups":`)
	if j.Groups != nil {
		buf.WriteString(`[`)
		for i, v := range j.Groups {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"ops":`)
	if j.Ops != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ops {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberListUpdatebase = iota
	ffjtGuildMemberListUpdatenosuchkey

	ffjtGuildMemberListUpdateID

	ffjtGuildMemberListUpdateGuildID

	ffjtGuildMemberListUpdateMemberCount

	ffjtGuildMemberListUpdateOnlineCount

	ffjtGuildMemberListUpdateGroups

	ffjtGuildMemberListUpdateOps
)

var ffjKeyGuildMemberListUpdateID = []byte("id")

var ffjKeyGuildMemberListUpdateGuildID = []byte("guild_id")

var ffjKeyGuildMemberListUpdateMemberCount = []byte("member_count")

var ffjKeyGuildMemberListUpdateOnlineCount = []byte("online_count")

var ffjKeyGuildMemberListUpdateGroups = []byte("groups")

var ffjKeyGuildMemberListUpdateOps = []byte("ops")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberListUpdate) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberListUpdate) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberListUpdatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberListUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildMemberListUpdateGuildID, kn) {
						currentKey = ffjtGuildMemberListUpdateGuildID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMemberListUpdateGroups, kn) {
						currentKey = ffjtGuildMemberListUpdateGroups
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildMemberListUpdateID, kn) {
						currentKey = ffjtGuildMemberListUpdateID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildMemberListUpdateMemberCount, kn) {
						currentKey = ffjtGuildMemberListUpdateMemberCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyGuildMemberListUpdateOnlineCount, kn) {
						currentKey = ffjtGuildMemberListUpdateOnlineCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMemberListUpdateOps, kn) {
						currentKey = ffjtGuildMemberListUpdateOps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberListUpdateOps, kn) {
					currentKey = ffjtGuildMemberListUpdateOps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberListUpdateGroups, kn) {
					currentKey = ffjtGuildMemberListUpdateGroups
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberListUpdateOnlineCount, kn) {
					currentKey = ffjtGuildMemberListUpdateOnlineCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberListUpdateMemberCount, kn) {
					currentKey = ffjtGuildMemberListUpdateMemberCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberListUpdateGuildID, kn) {
					currentKey = ffjtGuildMemberListUpdateGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberListUpdateID, kn) {
					currentKey = ffjtGuildMemberListUpdateID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberListUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberListUpdateID:
					goto handle_ID

				case ffjtGuildMemberListUpdateGuildID:
					goto handle_GuildID

				case ffjtGuildMemberListUpdateMemberCount:
					goto handle_MemberCount

				case ffjtGuildMemberListUpdateOnlineCount:
					goto handle_OnlineCount

				case ffjtGuildMemberListUpdateGroups:
					goto handle_Groups

				case ffjtGuildMemberListUpdateOps:
					goto handle_Ops

				case ffjtGuildMemberListUpdatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemberCount:

	/* handler: j.MemberCount type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MemberCount = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OnlineCount:

	/* handler: j.OnlineCount type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OnlineCount = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Groups:

	/* handler: j.Groups type=[]gateway.GuildMemberListGroup kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Groups = nil
		} else {

			j.Groups = []GuildMemberListGroup{}

			wantVal := true

			for {

				var tmpJGroups GuildMemberListGroup

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGroups type=gateway.GuildMemberListGroup kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJGroups.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Groups = append(j.Groups, tmpJGroups)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ops:

	/* handler: j.Ops type=[]gateway.GuildMemberListOp kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ops = nil
		} else {

			j.Ops = []GuildMemberListOp{}

			wantVal := true

			for {

				var tmpJOps GuildMemberListOp

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOps type=gateway.GuildMemberListOp kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJOps.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Ops = append(j.Ops, tmpJOps)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberRemoveEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberRemoveEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberRemoveEventbase = iota
	ffjtGuildMemberRemoveEventnosuchkey

	ffjtGuildMemberRemoveEventGuildID

	ffjtGuildMemberRemoveEventUser
)

var ffjKeyGuildMemberRemoveEventGuildID = []byte("guild_id")

var ffjKeyGuildMemberRemoveEventUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberRemoveEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberRemoveEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberRemoveEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildMemberRemoveEventGuildID, kn) {
						currentKey = ffjtGuildMemberRemoveEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildMemberRemoveEventUser, kn) {
						currentKey = ffjtGuildMemberRemoveEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberRemoveEventUser, kn) {
					currentKey = ffjtGuildMemberRemoveEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberRemoveEventGuildID, kn) {
					currentKey = ffjtGuildMemberRemoveEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberRemoveEventGuildID:
					goto handle_GuildID

				case ffjtGuildMemberRemoveEventUser:
					goto handle_User

				case ffjtGuildMemberRemoveEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMemberUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMemberUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"roles":`)
	if j.RoleIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.RoleIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"nick":`)
	fflib.WriteJsonString(buf, string(j.Nick))
	buf.WriteString(`,"avatar":`)
	fflib.WriteJsonString(buf, string(j.Avatar))
	buf.WriteByte(',')
	if j.IsPending != false {
		if j.IsPending {
			buf.WriteString(`"pending":true`)
		} else {
			buf.WriteString(`"pending":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"communication_disabled_until":`)

	{

		obj, err = j.CommunicationDisabledUntil.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMemberUpdateEventbase = iota
	ffjtGuildMemberUpdateEventnosuchkey

	ffjtGuildMemberUpdateEventGuildID

	ffjtGuildMemberUpdateEventRoleIDs

	ffjtGuildMemberUpdateEventUser

	ffjtGuildMemberUpdateEventNick

	ffjtGuildMemberUpdateEventAvatar

	ffjtGuildMemberUpdateEventIsPending

	ffjtGuildMemberUpdateEventCommunicationDisabledUntil
)

var ffjKeyGuildMemberUpdateEventGuildID = []byte("guild_id")

var ffjKeyGuildMemberUpdateEventRoleIDs = []byte("roles")

var ffjKeyGuildMemberUpdateEventUser = []byte("user")

var ffjKeyGuildMemberUpdateEventNick = []byte("nick")

var ffjKeyGuildMemberUpdateEventAvatar = []byte("avatar")

var ffjKeyGuildMemberUpdateEventIsPending = []byte("pending")

var ffjKeyGuildMemberUpdateEventCommunicationDisabledUntil = []byte("communication_disabled_until")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMemberUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMemberUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMemberUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMemberUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventAvatar, kn) {
						currentKey = ffjtGuildMemberUpdateEventAvatar
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventCommunicationDisabledUntil, kn) {
						currentKey = ffjtGuildMemberUpdateEventCommunicationDisabledUntil
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventGuildID, kn) {
						currentKey = ffjtGuildMemberUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventNick, kn) {
						currentKey = ffjtGuildMemberUpdateEventNick
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventIsPending, kn) {
						currentKey = ffjtGuildMemberUpdateEventIsPending
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventRoleIDs, kn) {
						currentKey = ffjtGuildMemberUpdateEventRoleIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildMemberUpdateEventUser, kn) {
						currentKey = ffjtGuildMemberUpdateEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberUpdateEventCommunicationDisabledUntil, kn) {
					currentKey = ffjtGuildMemberUpdateEventCommunicationDisabledUntil
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberUpdateEventIsPending, kn) {
					currentKey = ffjtGuildMemberUpdateEventIsPending
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMemberUpdateEventAvatar, kn) {
					currentKey = ffjtGuildMemberUpdateEventAvatar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberUpdateEventNick, kn) {
					currentKey = ffjtGuildMemberUpdateEventNick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberUpdateEventUser, kn) {
					currentKey = ffjtGuildMemberUpdateEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMemberUpdateEventRoleIDs, kn) {
					currentKey = ffjtGuildMemberUpdateEventRoleIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMemberUpdateEventGuildID, kn) {
					currentKey = ffjtGuildMemberUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMemberUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMemberUpdateEventGuildID:
					goto handle_GuildID

				case ffjtGuildMemberUpdateEventRoleIDs:
					goto handle_RoleIDs

				case ffjtGuildMemberUpdateEventUser:
					goto handle_User

				case ffjtGuildMemberUpdateEventNick:
					goto handle_Nick

				case ffjtGuildMemberUpdateEventAvatar:
					goto handle_Avatar

				case ffjtGuildMemberUpdateEventIsPending:
					goto handle_IsPending

				case ffjtGuildMemberUpdateEventCommunicationDisabledUntil:
					goto handle_CommunicationDisabledUntil

				case ffjtGuildMemberUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RoleIDs:

	/* handler: j.RoleIDs type=[]discord.RoleID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RoleIDs = nil
		} else {

			j.RoleIDs = []discord.RoleID{}

			wantVal := true

			for {

				var tmpJRoleIDs discord.RoleID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoleIDs type=discord.RoleID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRoleIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RoleIDs = append(j.RoleIDs, tmpJRoleIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nick:

	/* handler: j.Nick type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nick = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Avatar:

	/* handler: j.Avatar type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Avatar = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPending:

	/* handler: j.IsPending type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsPending = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsPending = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommunicationDisabledUntil:

	/* handler: j.CommunicationDisabledUntil type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommunicationDisabledUntil.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildMembersChunkEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildMembersChunkEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"members":`)
	if j.Members != nil {
		buf.WriteString(`[`)
		for i, v := range j.Members {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"chunk_index":`)
	fflib.FormatBits2(buf, uint64(j.ChunkIndex), 10, j.ChunkIndex < 0)
	buf.WriteString(`,"chunk_count":`)
	fflib.FormatBits2(buf, uint64(j.ChunkCount), 10, j.ChunkCount < 0)
	buf.WriteByte(',')
	if len(j.NotFound) != 0 {
		buf.WriteString(`"not_found":`)
		if j.NotFound != nil {
			buf.WriteString(`[`)
			for i, v := range j.NotFound {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Presences) != 0 {
		buf.WriteString(`"presences":`)
		if j.Presences != nil {
			buf.WriteString(`[`)
			for i, v := range j.Presences {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Nonce) != 0 {
		buf.WriteString(`"nonce":`)
		fflib.WriteJsonString(buf, string(j.Nonce))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildMembersChunkEventbase = iota
	ffjtGuildMembersChunkEventnosuchkey

	ffjtGuildMembersChunkEventGuildID

	ffjtGuildMembersChunkEventMembers

	ffjtGuildMembersChunkEventChunkIndex

	ffjtGuildMembersChunkEventChunkCount

	ffjtGuildMembersChunkEventNotFound

	ffjtGuildMembersChunkEventPresences

	ffjtGuildMembersChunkEventNonce
)

var ffjKeyGuildMembersChunkEventGuildID = []byte("guild_id")

var ffjKeyGuildMembersChunkEventMembers = []byte("members")

var ffjKeyGuildMembersChunkEventChunkIndex = []byte("chunk_index")

var ffjKeyGuildMembersChunkEventChunkCount = []byte("chunk_count")

var ffjKeyGuildMembersChunkEventNotFound = []byte("not_found")

var ffjKeyGuildMembersChunkEventPresences = []byte("presences")

var ffjKeyGuildMembersChunkEventNonce = []byte("nonce")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildMembersChunkEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildMembersChunkEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildMembersChunkEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildMembersChunkEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildMembersChunkEventChunkIndex, kn) {
						currentKey = ffjtGuildMembersChunkEventChunkIndex
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMembersChunkEventChunkCount, kn) {
						currentKey = ffjtGuildMembersChunkEventChunkCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildMembersChunkEventGuildID, kn) {
						currentKey = ffjtGuildMembersChunkEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildMembersChunkEventMembers, kn) {
						currentKey = ffjtGuildMembersChunkEventMembers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildMembersChunkEventNotFound, kn) {
						currentKey = ffjtGuildMembersChunkEventNotFound
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildMembersChunkEventNonce, kn) {
						currentKey = ffjtGuildMembersChunkEventNonce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildMembersChunkEventPresences, kn) {
						currentKey = ffjtGuildMembersChunkEventPresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildMembersChunkEventNonce, kn) {
					currentKey = ffjtGuildMembersChunkEventNonce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMembersChunkEventPresences, kn) {
					currentKey = ffjtGuildMembersChunkEventPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMembersChunkEventNotFound, kn) {
					currentKey = ffjtGuildMembersChunkEventNotFound
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMembersChunkEventChunkCount, kn) {
					currentKey = ffjtGuildMembersChunkEventChunkCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMembersChunkEventChunkIndex, kn) {
					currentKey = ffjtGuildMembersChunkEventChunkIndex
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildMembersChunkEventMembers, kn) {
					currentKey = ffjtGuildMembersChunkEventMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildMembersChunkEventGuildID, kn) {
					currentKey = ffjtGuildMembersChunkEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildMembersChunkEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildMembersChunkEventGuildID:
					goto handle_GuildID

				case ffjtGuildMembersChunkEventMembers:
					goto handle_Members

				case ffjtGuildMembersChunkEventChunkIndex:
					goto handle_ChunkIndex

				case ffjtGuildMembersChunkEventChunkCount:
					goto handle_ChunkCount

				case ffjtGuildMembersChunkEventNotFound:
					goto handle_NotFound

				case ffjtGuildMembersChunkEventPresences:
					goto handle_Presences

				case ffjtGuildMembersChunkEventNonce:
					goto handle_Nonce

				case ffjtGuildMembersChunkEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Members:

	/* handler: j.Members type=[]discord.Member kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Members = nil
		} else {

			j.Members = []discord.Member{}

			wantVal := true

			for {

				var tmpJMembers discord.Member

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMembers type=discord.Member kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Members = append(j.Members, tmpJMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChunkIndex:

	/* handler: j.ChunkIndex type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChunkIndex = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChunkCount:

	/* handler: j.ChunkCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChunkCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NotFound:

	/* handler: j.NotFound type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NotFound = nil
		} else {

			j.NotFound = []string{}

			wantVal := true

			for {

				var tmpJNotFound string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNotFound type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJNotFound = string(string(outBuf))

					}
				}

				j.NotFound = append(j.NotFound, tmpJNotFound)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Presences:

	/* handler: j.Presences type=[]discord.Presence kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Presences = nil
		} else {

			j.Presences = []discord.Presence{}

			wantVal := true

			for {

				var tmpJPresences discord.Presence

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPresences type=discord.Presence kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPresences.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Presences = append(j.Presences, tmpJPresences)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nonce:

	/* handler: j.Nonce type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nonce = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildRoleCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildRoleCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"role":`)

	{

		err = j.Role.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildRoleCreateEventbase = iota
	ffjtGuildRoleCreateEventnosuchkey

	ffjtGuildRoleCreateEventGuildID

	ffjtGuildRoleCreateEventRole
)

var ffjKeyGuildRoleCreateEventGuildID = []byte("guild_id")

var ffjKeyGuildRoleCreateEventRole = []byte("role")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildRoleCreateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildRoleCreateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildRoleCreateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildRoleCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildRoleCreateEventGuildID, kn) {
						currentKey = ffjtGuildRoleCreateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildRoleCreateEventRole, kn) {
						currentKey = ffjtGuildRoleCreateEventRole
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildRoleCreateEventRole, kn) {
					currentKey = ffjtGuildRoleCreateEventRole
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildRoleCreateEventGuildID, kn) {
					currentKey = ffjtGuildRoleCreateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildRoleCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildRoleCreateEventGuildID:
					goto handle_GuildID

				case ffjtGuildRoleCreateEventRole:
					goto handle_Role

				case ffjtGuildRoleCreateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: j.Role type=discord.Role kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Role.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildRoleDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildRoleDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"role_id":`)

	{

		obj, err = j.RoleID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildRoleDeleteEventbase = iota
	ffjtGuildRoleDeleteEventnosuchkey

	ffjtGuildRoleDeleteEventGuildID

	ffjtGuildRoleDeleteEventRoleID
)

var ffjKeyGuildRoleDeleteEventGuildID = []byte("guild_id")

var ffjKeyGuildRoleDeleteEventRoleID = []byte("role_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildRoleDeleteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildRoleDeleteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildRoleDeleteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildRoleDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildRoleDeleteEventGuildID, kn) {
						currentKey = ffjtGuildRoleDeleteEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildRoleDeleteEventRoleID, kn) {
						currentKey = ffjtGuildRoleDeleteEventRoleID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyGuildRoleDeleteEventRoleID, kn) {
					currentKey = ffjtGuildRoleDeleteEventRoleID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildRoleDeleteEventGuildID, kn) {
					currentKey = ffjtGuildRoleDeleteEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildRoleDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildRoleDeleteEventGuildID:
					goto handle_GuildID

				case ffjtGuildRoleDeleteEventRoleID:
					goto handle_RoleID

				case ffjtGuildRoleDeleteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RoleID:

	/* handler: j.RoleID type=discord.RoleID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.RoleID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildRoleUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildRoleUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"role":`)

	{

		err = j.Role.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildRoleUpdateEventbase = iota
	ffjtGuildRoleUpdateEventnosuchkey

	ffjtGuildRoleUpdateEventGuildID

	ffjtGuildRoleUpdateEventRole
)

var ffjKeyGuildRoleUpdateEventGuildID = []byte("guild_id")

var ffjKeyGuildRoleUpdateEventRole = []byte("role")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildRoleUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildRoleUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildRoleUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildRoleUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildRoleUpdateEventGuildID, kn) {
						currentKey = ffjtGuildRoleUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildRoleUpdateEventRole, kn) {
						currentKey = ffjtGuildRoleUpdateEventRole
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildRoleUpdateEventRole, kn) {
					currentKey = ffjtGuildRoleUpdateEventRole
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildRoleUpdateEventGuildID, kn) {
					currentKey = ffjtGuildRoleUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildRoleUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildRoleUpdateEventGuildID:
					goto handle_GuildID

				case ffjtGuildRoleUpdateEventRole:
					goto handle_Role

				case ffjtGuildRoleUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: j.Role type=discord.Role kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Role.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildScheduledEventCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildScheduledEventCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"creator_id":`)

	{

		obj, err = j.CreatorID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"scheduled_start_time":`)

	{

		obj, err = j.StartTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"scheduled_end_time":`)

	{

		obj, err = j.EndTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"privacy_level":`)
	fflib.FormatBits2(buf, uint64(j.PrivacyLevel), 10, j.PrivacyLevel < 0)
	buf.WriteString(`,"status":`)
	fflib.FormatBits2(buf, uint64(j.Status), 10, j.Status < 0)
	buf.WriteString(`,"entity_type":`)
	fflib.FormatBits2(buf, uint64(j.EntityType), 10, j.EntityType < 0)
	buf.WriteString(`,"entity_id":`)

	{

		obj, err = j.EntityID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.EntityMetadata != nil {
		/* Struct fall back. type=discord.EntityMetadata kind=struct */
		buf.WriteString(`,"entity_metadata":`)
		err = buf.Encode(j.EntityMetadata)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"entity_metadata":null`)
	}
	if j.Creator != nil {
		buf.WriteString(`,"creator":`)

		{

			err = j.Creator.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"creator":null`)
	}
	buf.WriteString(`,"user_count":`)
	fflib.FormatBits2(buf, uint64(j.UserCount), 10, j.UserCount < 0)
	buf.WriteByte(',')
	if len(j.Image) != 0 {
		buf.WriteString(`"image":`)
		fflib.WriteJsonString(buf, string(j.Image))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildScheduledEventCreateEventbase = iota
	ffjtGuildScheduledEventCreateEventnosuchkey

	ffjtGuildScheduledEventCreateEventID

	ffjtGuildScheduledEventCreateEventGuildID

	ffjtGuildScheduledEventCreateEventChannelID

	ffjtGuildScheduledEventCreateEventCreatorID

	ffjtGuildScheduledEventCreateEventName

	ffjtGuildScheduledEventCreateEventDescription

	ffjtGuildScheduledEventCreateEventStartTime

	ffjtGuildScheduledEventCreateEventEndTime

	ffjtGuildScheduledEventCreateEventPrivacyLevel

	ffjtGuildScheduledEventCreateEventStatus

	ffjtGuildScheduledEventCreateEventEntityType

	ffjtGuildScheduledEventCreateEventEntityID

	ffjtGuildScheduledEventCreateEventEntityMetadata

	ffjtGuildScheduledEventCreateEventCreator

	ffjtGuildScheduledEventCreateEventUserCount

	ffjtGuildScheduledEventCreateEventImage
)

var ffjKeyGuildScheduledEventCreateEventID = []byte("id")

var ffjKeyGuildScheduledEventCreateEventGuildID = []byte("guild_id")

var ffjKeyGuildScheduledEventCreateEventChannelID = []byte("channel_id")

var ffjKeyGuildScheduledEventCreateEventCreatorID = []byte("creator_id")

var ffjKeyGuildScheduledEventCreateEventName = []byte("name")

var ffjKeyGuildScheduledEventCreateEventDescription = []byte("description")

var ffjKeyGuildScheduledEventCreateEventStartTime = []byte("scheduled_start_time")

var ffjKeyGuildScheduledEventCreateEventEndTime = []byte("scheduled_end_time")

var ffjKeyGuildScheduledEventCreateEventPrivacyLevel = []byte("privacy_level")

var ffjKeyGuildScheduledEventCreateEventStatus = []byte("status")

var ffjKeyGuildScheduledEventCreateEventEntityType = []byte("entity_type")

var ffjKeyGuildScheduledEventCreateEventEntityID = []byte("entity_id")

var ffjKeyGuildScheduledEventCreateEventEntityMetadata = []byte("entity_metadata")

var ffjKeyGuildScheduledEventCreateEventCreator = []byte("creator")

var ffjKeyGuildScheduledEventCreateEventUserCount = []byte("user_count")

var ffjKeyGuildScheduledEventCreateEventImage = []byte("image")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildScheduledEventCreateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildScheduledEventCreateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildScheduledEventCreateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildScheduledEventCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventChannelID, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventCreatorID, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventCreatorID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventCreator, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventCreator
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventDescription, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventEntityType, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventEntityType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventEntityID, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventEntityID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventEntityMetadata, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventEntityMetadata
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventGuildID, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventID, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventImage, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventName, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventPrivacyLevel, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventPrivacyLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventStartTime, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventStartTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventEndTime, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventEndTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventCreateEventStatus, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildScheduledEventCreateEventUserCount, kn) {
						currentKey = ffjtGuildScheduledEventCreateEventUserCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventCreateEventImage, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventCreateEventUserCount, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventUserCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventCreateEventCreator, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventCreator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventEntityMetadata, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventEntityMetadata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventEntityID, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventEntityID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventEntityType, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventEntityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventCreateEventStatus, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventPrivacyLevel, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventPrivacyLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventCreateEventEndTime, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventEndTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventCreateEventStartTime, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventStartTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventCreateEventDescription, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventCreateEventName, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventCreatorID, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventCreatorID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventChannelID, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventCreateEventGuildID, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventCreateEventID, kn) {
					currentKey = ffjtGuildScheduledEventCreateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildScheduledEventCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildScheduledEventCreateEventID:
					goto handle_ID

				case ffjtGuildScheduledEventCreateEventGuildID:
					goto handle_GuildID

				case ffjtGuildScheduledEventCreateEventChannelID:
					goto handle_ChannelID

				case ffjtGuildScheduledEventCreateEventCreatorID:
					goto handle_CreatorID

				case ffjtGuildScheduledEventCreateEventName:
					goto handle_Name

				case ffjtGuildScheduledEventCreateEventDescription:
					goto handle_Description

				case ffjtGuildScheduledEventCreateEventStartTime:
					goto handle_StartTime

				case ffjtGuildScheduledEventCreateEventEndTime:
					goto handle_EndTime

				case ffjtGuildScheduledEventCreateEventPrivacyLevel:
					goto handle_PrivacyLevel

				case ffjtGuildScheduledEventCreateEventStatus:
					goto handle_Status

				case ffjtGuildScheduledEventCreateEventEntityType:
					goto handle_EntityType

				case ffjtGuildScheduledEventCreateEventEntityID:
					goto handle_EntityID

				case ffjtGuildScheduledEventCreateEventEntityMetadata:
					goto handle_EntityMetadata

				case ffjtGuildScheduledEventCreateEventCreator:
					goto handle_Creator

				case ffjtGuildScheduledEventCreateEventUserCount:
					goto handle_UserCount

				case ffjtGuildScheduledEventCreateEventImage:
					goto handle_Image

				case ffjtGuildScheduledEventCreateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.EventID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatorID:

	/* handler: j.CreatorID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatorID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartTime:

	/* handler: j.StartTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndTime:

	/* handler: j.EndTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EndTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PrivacyLevel:

	/* handler: j.PrivacyLevel type=discord.ScheduledEventPrivacyLevel kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ScheduledEventPrivacyLevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PrivacyLevel = discord.ScheduledEventPrivacyLevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.EventStatus kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for EventStatus", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Status = discord.EventStatus(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityType:

	/* handler: j.EntityType type=discord.EntityType kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for EntityType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.EntityType = discord.EntityType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityID:

	/* handler: j.EntityID type=discord.EntityID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EntityID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityMetadata:

	/* handler: j.EntityMetadata type=discord.EntityMetadata kind=struct quoted=false*/

	{
		/* Falling back. type=discord.EntityMetadata kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.EntityMetadata)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Creator:

	/* handler: j.Creator type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Creator = nil

		} else {

			if j.Creator == nil {
				j.Creator = new(discord.User)
			}

			err = j.Creator.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserCount:

	/* handler: j.UserCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: j.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildScheduledEventDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildScheduledEventDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"creator_id":`)

	{

		obj, err = j.CreatorID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"scheduled_start_time":`)

	{

		obj, err = j.StartTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"scheduled_end_time":`)

	{

		obj, err = j.EndTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"privacy_level":`)
	fflib.FormatBits2(buf, uint64(j.PrivacyLevel), 10, j.PrivacyLevel < 0)
	buf.WriteString(`,"status":`)
	fflib.FormatBits2(buf, uint64(j.Status), 10, j.Status < 0)
	buf.WriteString(`,"entity_type":`)
	fflib.FormatBits2(buf, uint64(j.EntityType), 10, j.EntityType < 0)
	buf.WriteString(`,"entity_id":`)

	{

		obj, err = j.EntityID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.EntityMetadata != nil {
		/* Struct fall back. type=discord.EntityMetadata kind=struct */
		buf.WriteString(`,"entity_metadata":`)
		err = buf.Encode(j.EntityMetadata)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"entity_metadata":null`)
	}
	if j.Creator != nil {
		buf.WriteString(`,"creator":`)

		{

			err = j.Creator.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"creator":null`)
	}
	buf.WriteString(`,"user_count":`)
	fflib.FormatBits2(buf, uint64(j.UserCount), 10, j.UserCount < 0)
	buf.WriteByte(',')
	if len(j.Image) != 0 {
		buf.WriteString(`"image":`)
		fflib.WriteJsonString(buf, string(j.Image))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildScheduledEventDeleteEventbase = iota
	ffjtGuildScheduledEventDeleteEventnosuchkey

	ffjtGuildScheduledEventDeleteEventID

	ffjtGuildScheduledEventDeleteEventGuildID

	ffjtGuildScheduledEventDeleteEventChannelID

	ffjtGuildScheduledEventDeleteEventCreatorID

	ffjtGuildScheduledEventDeleteEventName

	ffjtGuildScheduledEventDeleteEventDescription

	ffjtGuildScheduledEventDeleteEventStartTime

	ffjtGuildScheduledEventDeleteEventEndTime

	ffjtGuildScheduledEventDeleteEventPrivacyLevel

	ffjtGuildScheduledEventDeleteEventStatus

	ffjtGuildScheduledEventDeleteEventEntityType

	ffjtGuildScheduledEventDeleteEventEntityID

	ffjtGuildScheduledEventDeleteEventEntityMetadata

	ffjtGuildScheduledEventDeleteEventCreator

	ffjtGuildScheduledEventDeleteEventUserCount

	ffjtGuildScheduledEventDeleteEventImage
)

var ffjKeyGuildScheduledEventDeleteEventID = []byte("id")

var ffjKeyGuildScheduledEventDeleteEventGuildID = []byte("guild_id")

var ffjKeyGuildScheduledEventDeleteEventChannelID = []byte("channel_id")

var ffjKeyGuildScheduledEventDeleteEventCreatorID = []byte("creator_id")

var ffjKeyGuildScheduledEventDeleteEventName = []byte("name")

var ffjKeyGuildScheduledEventDeleteEventDescription = []byte("description")

var ffjKeyGuildScheduledEventDeleteEventStartTime = []byte("scheduled_start_time")

var ffjKeyGuildScheduledEventDeleteEventEndTime = []byte("scheduled_end_time")

var ffjKeyGuildScheduledEventDeleteEventPrivacyLevel = []byte("privacy_level")

var ffjKeyGuildScheduledEventDeleteEventStatus = []byte("status")

var ffjKeyGuildScheduledEventDeleteEventEntityType = []byte("entity_type")

var ffjKeyGuildScheduledEventDeleteEventEntityID = []byte("entity_id")

var ffjKeyGuildScheduledEventDeleteEventEntityMetadata = []byte("entity_metadata")

var ffjKeyGuildScheduledEventDeleteEventCreator = []byte("creator")

var ffjKeyGuildScheduledEventDeleteEventUserCount = []byte("user_count")

var ffjKeyGuildScheduledEventDeleteEventImage = []byte("image")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildScheduledEventDeleteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildScheduledEventDeleteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildScheduledEventDeleteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildScheduledEventDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventChannelID, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventCreatorID, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventCreatorID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventCreator, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventCreator
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventDescription, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventEntityType, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventEntityType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventEntityID, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventEntityID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventEntityMetadata, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventEntityMetadata
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventGuildID, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventID, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventImage, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventName, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventPrivacyLevel, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventPrivacyLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventStartTime, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventStartTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventEndTime, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventEndTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventStatus, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildScheduledEventDeleteEventUserCount, kn) {
						currentKey = ffjtGuildScheduledEventDeleteEventUserCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventDeleteEventImage, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventDeleteEventUserCount, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventUserCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventDeleteEventCreator, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventCreator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventEntityMetadata, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventEntityMetadata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventEntityID, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventEntityID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventEntityType, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventEntityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventDeleteEventStatus, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventPrivacyLevel, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventPrivacyLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventDeleteEventEndTime, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventEndTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventDeleteEventStartTime, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventStartTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventDeleteEventDescription, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventDeleteEventName, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventCreatorID, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventCreatorID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventChannelID, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventDeleteEventGuildID, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventDeleteEventID, kn) {
					currentKey = ffjtGuildScheduledEventDeleteEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildScheduledEventDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildScheduledEventDeleteEventID:
					goto handle_ID

				case ffjtGuildScheduledEventDeleteEventGuildID:
					goto handle_GuildID

				case ffjtGuildScheduledEventDeleteEventChannelID:
					goto handle_ChannelID

				case ffjtGuildScheduledEventDeleteEventCreatorID:
					goto handle_CreatorID

				case ffjtGuildScheduledEventDeleteEventName:
					goto handle_Name

				case ffjtGuildScheduledEventDeleteEventDescription:
					goto handle_Description

				case ffjtGuildScheduledEventDeleteEventStartTime:
					goto handle_StartTime

				case ffjtGuildScheduledEventDeleteEventEndTime:
					goto handle_EndTime

				case ffjtGuildScheduledEventDeleteEventPrivacyLevel:
					goto handle_PrivacyLevel

				case ffjtGuildScheduledEventDeleteEventStatus:
					goto handle_Status

				case ffjtGuildScheduledEventDeleteEventEntityType:
					goto handle_EntityType

				case ffjtGuildScheduledEventDeleteEventEntityID:
					goto handle_EntityID

				case ffjtGuildScheduledEventDeleteEventEntityMetadata:
					goto handle_EntityMetadata

				case ffjtGuildScheduledEventDeleteEventCreator:
					goto handle_Creator

				case ffjtGuildScheduledEventDeleteEventUserCount:
					goto handle_UserCount

				case ffjtGuildScheduledEventDeleteEventImage:
					goto handle_Image

				case ffjtGuildScheduledEventDeleteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.EventID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatorID:

	/* handler: j.CreatorID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatorID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartTime:

	/* handler: j.StartTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndTime:

	/* handler: j.EndTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EndTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PrivacyLevel:

	/* handler: j.PrivacyLevel type=discord.ScheduledEventPrivacyLevel kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ScheduledEventPrivacyLevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PrivacyLevel = discord.ScheduledEventPrivacyLevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.EventStatus kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for EventStatus", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Status = discord.EventStatus(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityType:

	/* handler: j.EntityType type=discord.EntityType kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for EntityType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.EntityType = discord.EntityType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityID:

	/* handler: j.EntityID type=discord.EntityID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EntityID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityMetadata:

	/* handler: j.EntityMetadata type=discord.EntityMetadata kind=struct quoted=false*/

	{
		/* Falling back. type=discord.EntityMetadata kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.EntityMetadata)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Creator:

	/* handler: j.Creator type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Creator = nil

		} else {

			if j.Creator == nil {
				j.Creator = new(discord.User)
			}

			err = j.Creator.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserCount:

	/* handler: j.UserCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: j.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildScheduledEventUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildScheduledEventUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"creator_id":`)

	{

		obj, err = j.CreatorID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"scheduled_start_time":`)

	{

		obj, err = j.StartTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"scheduled_end_time":`)

	{

		obj, err = j.EndTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"privacy_level":`)
	fflib.FormatBits2(buf, uint64(j.PrivacyLevel), 10, j.PrivacyLevel < 0)
	buf.WriteString(`,"status":`)
	fflib.FormatBits2(buf, uint64(j.Status), 10, j.Status < 0)
	buf.WriteString(`,"entity_type":`)
	fflib.FormatBits2(buf, uint64(j.EntityType), 10, j.EntityType < 0)
	buf.WriteString(`,"entity_id":`)

	{

		obj, err = j.EntityID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.EntityMetadata != nil {
		/* Struct fall back. type=discord.EntityMetadata kind=struct */
		buf.WriteString(`,"entity_metadata":`)
		err = buf.Encode(j.EntityMetadata)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"entity_metadata":null`)
	}
	if j.Creator != nil {
		buf.WriteString(`,"creator":`)

		{

			err = j.Creator.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"creator":null`)
	}
	buf.WriteString(`,"user_count":`)
	fflib.FormatBits2(buf, uint64(j.UserCount), 10, j.UserCount < 0)
	buf.WriteByte(',')
	if len(j.Image) != 0 {
		buf.WriteString(`"image":`)
		fflib.WriteJsonString(buf, string(j.Image))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildScheduledEventUpdateEventbase = iota
	ffjtGuildScheduledEventUpdateEventnosuchkey

	ffjtGuildScheduledEventUpdateEventID

	ffjtGuildScheduledEventUpdateEventGuildID

	ffjtGuildScheduledEventUpdateEventChannelID

	ffjtGuildScheduledEventUpdateEventCreatorID

	ffjtGuildScheduledEventUpdateEventName

	ffjtGuildScheduledEventUpdateEventDescription

	ffjtGuildScheduledEventUpdateEventStartTime

	ffjtGuildScheduledEventUpdateEventEndTime

	ffjtGuildScheduledEventUpdateEventPrivacyLevel

	ffjtGuildScheduledEventUpdateEventStatus

	ffjtGuildScheduledEventUpdateEventEntityType

	ffjtGuildScheduledEventUpdateEventEntityID

	ffjtGuildScheduledEventUpdateEventEntityMetadata

	ffjtGuildScheduledEventUpdateEventCreator

	ffjtGuildScheduledEventUpdateEventUserCount

	ffjtGuildScheduledEventUpdateEventImage
)

var ffjKeyGuildScheduledEventUpdateEventID = []byte("id")

var ffjKeyGuildScheduledEventUpdateEventGuildID = []byte("guild_id")

var ffjKeyGuildScheduledEventUpdateEventChannelID = []byte("channel_id")

var ffjKeyGuildScheduledEventUpdateEventCreatorID = []byte("creator_id")

var ffjKeyGuildScheduledEventUpdateEventName = []byte("name")

var ffjKeyGuildScheduledEventUpdateEventDescription = []byte("description")

var ffjKeyGuildScheduledEventUpdateEventStartTime = []byte("scheduled_start_time")

var ffjKeyGuildScheduledEventUpdateEventEndTime = []byte("scheduled_end_time")

var ffjKeyGuildScheduledEventUpdateEventPrivacyLevel = []byte("privacy_level")

var ffjKeyGuildScheduledEventUpdateEventStatus = []byte("status")

var ffjKeyGuildScheduledEventUpdateEventEntityType = []byte("entity_type")

var ffjKeyGuildScheduledEventUpdateEventEntityID = []byte("entity_id")

var ffjKeyGuildScheduledEventUpdateEventEntityMetadata = []byte("entity_metadata")

var ffjKeyGuildScheduledEventUpdateEventCreator = []byte("creator")

var ffjKeyGuildScheduledEventUpdateEventUserCount = []byte("user_count")

var ffjKeyGuildScheduledEventUpdateEventImage = []byte("image")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildScheduledEventUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildScheduledEventUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildScheduledEventUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildScheduledEventUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventChannelID, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventCreatorID, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventCreatorID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventCreator, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventCreator
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventDescription, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventEntityType, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventEntityType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventEntityID, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventEntityID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventEntityMetadata, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventEntityMetadata
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventGuildID, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventID, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventImage, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventName, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventPrivacyLevel, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventPrivacyLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventStartTime, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventStartTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventEndTime, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventEndTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventStatus, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildScheduledEventUpdateEventUserCount, kn) {
						currentKey = ffjtGuildScheduledEventUpdateEventUserCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventUpdateEventImage, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUpdateEventUserCount, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventUserCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventUpdateEventCreator, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventCreator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventEntityMetadata, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventEntityMetadata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventEntityID, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventEntityID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventEntityType, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventEntityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUpdateEventStatus, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventPrivacyLevel, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventPrivacyLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUpdateEventEndTime, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventEndTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUpdateEventStartTime, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventStartTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUpdateEventDescription, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventUpdateEventName, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventCreatorID, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventCreatorID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventChannelID, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUpdateEventGuildID, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildScheduledEventUpdateEventID, kn) {
					currentKey = ffjtGuildScheduledEventUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildScheduledEventUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildScheduledEventUpdateEventID:
					goto handle_ID

				case ffjtGuildScheduledEventUpdateEventGuildID:
					goto handle_GuildID

				case ffjtGuildScheduledEventUpdateEventChannelID:
					goto handle_ChannelID

				case ffjtGuildScheduledEventUpdateEventCreatorID:
					goto handle_CreatorID

				case ffjtGuildScheduledEventUpdateEventName:
					goto handle_Name

				case ffjtGuildScheduledEventUpdateEventDescription:
					goto handle_Description

				case ffjtGuildScheduledEventUpdateEventStartTime:
					goto handle_StartTime

				case ffjtGuildScheduledEventUpdateEventEndTime:
					goto handle_EndTime

				case ffjtGuildScheduledEventUpdateEventPrivacyLevel:
					goto handle_PrivacyLevel

				case ffjtGuildScheduledEventUpdateEventStatus:
					goto handle_Status

				case ffjtGuildScheduledEventUpdateEventEntityType:
					goto handle_EntityType

				case ffjtGuildScheduledEventUpdateEventEntityID:
					goto handle_EntityID

				case ffjtGuildScheduledEventUpdateEventEntityMetadata:
					goto handle_EntityMetadata

				case ffjtGuildScheduledEventUpdateEventCreator:
					goto handle_Creator

				case ffjtGuildScheduledEventUpdateEventUserCount:
					goto handle_UserCount

				case ffjtGuildScheduledEventUpdateEventImage:
					goto handle_Image

				case ffjtGuildScheduledEventUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.EventID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatorID:

	/* handler: j.CreatorID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatorID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartTime:

	/* handler: j.StartTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndTime:

	/* handler: j.EndTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EndTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PrivacyLevel:

	/* handler: j.PrivacyLevel type=discord.ScheduledEventPrivacyLevel kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ScheduledEventPrivacyLevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PrivacyLevel = discord.ScheduledEventPrivacyLevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.EventStatus kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for EventStatus", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Status = discord.EventStatus(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityType:

	/* handler: j.EntityType type=discord.EntityType kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for EntityType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.EntityType = discord.EntityType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityID:

	/* handler: j.EntityID type=discord.EntityID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EntityID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EntityMetadata:

	/* handler: j.EntityMetadata type=discord.EntityMetadata kind=struct quoted=false*/

	{
		/* Falling back. type=discord.EntityMetadata kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.EntityMetadata)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Creator:

	/* handler: j.Creator type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Creator = nil

		} else {

			if j.Creator == nil {
				j.Creator = new(discord.User)
			}

			err = j.Creator.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserCount:

	/* handler: j.UserCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: j.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildScheduledEventUserAddEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildScheduledEventUserAddEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_scheduled_event_id":`)

	{

		obj, err = j.EventID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildScheduledEventUserAddEventbase = iota
	ffjtGuildScheduledEventUserAddEventnosuchkey

	ffjtGuildScheduledEventUserAddEventEventID

	ffjtGuildScheduledEventUserAddEventUserID

	ffjtGuildScheduledEventUserAddEventGuildID
)

var ffjKeyGuildScheduledEventUserAddEventEventID = []byte("guild_scheduled_event_id")

var ffjKeyGuildScheduledEventUserAddEventUserID = []byte("user_id")

var ffjKeyGuildScheduledEventUserAddEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildScheduledEventUserAddEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildScheduledEventUserAddEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildScheduledEventUserAddEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildScheduledEventUserAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildScheduledEventUserAddEventEventID, kn) {
						currentKey = ffjtGuildScheduledEventUserAddEventEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUserAddEventGuildID, kn) {
						currentKey = ffjtGuildScheduledEventUserAddEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildScheduledEventUserAddEventUserID, kn) {
						currentKey = ffjtGuildScheduledEventUserAddEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUserAddEventGuildID, kn) {
					currentKey = ffjtGuildScheduledEventUserAddEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUserAddEventUserID, kn) {
					currentKey = ffjtGuildScheduledEventUserAddEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUserAddEventEventID, kn) {
					currentKey = ffjtGuildScheduledEventUserAddEventEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildScheduledEventUserAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildScheduledEventUserAddEventEventID:
					goto handle_EventID

				case ffjtGuildScheduledEventUserAddEventUserID:
					goto handle_UserID

				case ffjtGuildScheduledEventUserAddEventGuildID:
					goto handle_GuildID

				case ffjtGuildScheduledEventUserAddEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_EventID:

	/* handler: j.EventID type=discord.EventID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EventID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildScheduledEventUserRemoveEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildScheduledEventUserRemoveEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_scheduled_event_id":`)

	{

		obj, err = j.EventID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildScheduledEventUserRemoveEventbase = iota
	ffjtGuildScheduledEventUserRemoveEventnosuchkey

	ffjtGuildScheduledEventUserRemoveEventEventID

	ffjtGuildScheduledEventUserRemoveEventUserID

	ffjtGuildScheduledEventUserRemoveEventGuildID
)

var ffjKeyGuildScheduledEventUserRemoveEventEventID = []byte("guild_scheduled_event_id")

var ffjKeyGuildScheduledEventUserRemoveEventUserID = []byte("user_id")

var ffjKeyGuildScheduledEventUserRemoveEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildScheduledEventUserRemoveEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildScheduledEventUserRemoveEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildScheduledEventUserRemoveEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildScheduledEventUserRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGuildScheduledEventUserRemoveEventEventID, kn) {
						currentKey = ffjtGuildScheduledEventUserRemoveEventEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildScheduledEventUserRemoveEventGuildID, kn) {
						currentKey = ffjtGuildScheduledEventUserRemoveEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGuildScheduledEventUserRemoveEventUserID, kn) {
						currentKey = ffjtGuildScheduledEventUserRemoveEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyGuildScheduledEventUserRemoveEventGuildID, kn) {
					currentKey = ffjtGuildScheduledEventUserRemoveEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUserRemoveEventUserID, kn) {
					currentKey = ffjtGuildScheduledEventUserRemoveEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildScheduledEventUserRemoveEventEventID, kn) {
					currentKey = ffjtGuildScheduledEventUserRemoveEventEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildScheduledEventUserRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildScheduledEventUserRemoveEventEventID:
					goto handle_EventID

				case ffjtGuildScheduledEventUserRemoveEventUserID:
					goto handle_UserID

				case ffjtGuildScheduledEventUserRemoveEventGuildID:
					goto handle_GuildID

				case ffjtGuildScheduledEventUserRemoveEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_EventID:

	/* handler: j.EventID type=discord.EventID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EventID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildSubscribeCommand) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildSubscribeCommand) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Typing {
		buf.WriteString(`{ "typing":true`)
	} else {
		buf.WriteString(`{ "typing":false`)
	}
	if j.Threads {
		buf.WriteString(`,"threads":true`)
	} else {
		buf.WriteString(`,"threads":false`)
	}
	if j.Activities {
		buf.WriteString(`,"activities":true`)
	} else {
		buf.WriteString(`,"activities":false`)
	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if len(j.Channels) != 0 {
		/* Falling back. type=map[discord.ChannelID][][2]int kind=map */
		buf.WriteString(`"channels":`)
		err = buf.Encode(j.Channels)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildSubscribeCommandbase = iota
	ffjtGuildSubscribeCommandnosuchkey

	ffjtGuildSubscribeCommandTyping

	ffjtGuildSubscribeCommandThreads

	ffjtGuildSubscribeCommandActivities

	ffjtGuildSubscribeCommandGuildID

	ffjtGuildSubscribeCommandChannels
)

var ffjKeyGuildSubscribeCommandTyping = []byte("typing")

var ffjKeyGuildSubscribeCommandThreads = []byte("threads")

var ffjKeyGuildSubscribeCommandActivities = []byte("activities")

var ffjKeyGuildSubscribeCommandGuildID = []byte("guild_id")

var ffjKeyGuildSubscribeCommandChannels = []byte("channels")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildSubscribeCommand) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildSubscribeCommand) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildSubscribeCommandbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildSubscribeCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildSubscribeCommandActivities, kn) {
						currentKey = ffjtGuildSubscribeCommandActivities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyGuildSubscribeCommandChannels, kn) {
						currentKey = ffjtGuildSubscribeCommandChannels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyGuildSubscribeCommandGuildID, kn) {
						currentKey = ffjtGuildSubscribeCommandGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyGuildSubscribeCommandTyping, kn) {
						currentKey = ffjtGuildSubscribeCommandTyping
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildSubscribeCommandThreads, kn) {
						currentKey = ffjtGuildSubscribeCommandThreads
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildSubscribeCommandChannels, kn) {
					currentKey = ffjtGuildSubscribeCommandChannels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildSubscribeCommandGuildID, kn) {
					currentKey = ffjtGuildSubscribeCommandGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildSubscribeCommandActivities, kn) {
					currentKey = ffjtGuildSubscribeCommandActivities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildSubscribeCommandThreads, kn) {
					currentKey = ffjtGuildSubscribeCommandThreads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildSubscribeCommandTyping, kn) {
					currentKey = ffjtGuildSubscribeCommandTyping
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildSubscribeCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildSubscribeCommandTyping:
					goto handle_Typing

				case ffjtGuildSubscribeCommandThreads:
					goto handle_Threads

				case ffjtGuildSubscribeCommandActivities:
					goto handle_Activities

				case ffjtGuildSubscribeCommandGuildID:
					goto handle_GuildID

				case ffjtGuildSubscribeCommandChannels:
					goto handle_Channels

				case ffjtGuildSubscribeCommandnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Typing:

	/* handler: j.Typing type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Typing = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Typing = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Threads:

	/* handler: j.Threads type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Threads = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Threads = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activities:

	/* handler: j.Activities type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Activities = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Activities = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Channels:

	/* handler: j.Channels type=map[discord.ChannelID][][2]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Channels = nil
		} else {

			j.Channels = make(map[discord.ChannelID][][2]int, 0)

			wantVal := true

			for {

				var k discord.ChannelID

				var tmpJChannels [][2]int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=discord.ChannelID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = k.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJChannels type=[][2]int kind=slice quoted=false*/

				{
					/* Falling back. type=[][2]int kind=slice */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJChannels)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Channels[k] = tmpJChannels

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GuildUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GuildUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"icon":`)
	fflib.WriteJsonString(buf, string(j.Icon))
	buf.WriteByte(',')
	if len(j.Splash) != 0 {
		buf.WriteString(`"splash":`)
		fflib.WriteJsonString(buf, string(j.Splash))
		buf.WriteByte(',')
	}
	if len(j.DiscoverySplash) != 0 {
		buf.WriteString(`"discovery_splash":`)
		fflib.WriteJsonString(buf, string(j.DiscoverySplash))
		buf.WriteByte(',')
	}
	if j.Owner != false {
		if j.Owner {
			buf.WriteString(`"owner":true`)
		} else {
			buf.WriteString(`"owner":false`)
		}
		buf.WriteByte(',')
	}
	if j.Widget != false {
		if j.Widget {
			buf.WriteString(`"widget_enabled":true`)
		} else {
			buf.WriteString(`"widget_enabled":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"system_channel_flags":`)
	fflib.FormatBits2(buf, uint64(j.SystemChannelFlags), 10, false)
	buf.WriteString(`,"verification_level":`)

	{

		obj, err = j.Verification.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"default_message_notifications":`)

	{

		obj, err = j.Notification.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"explicit_content_filter":`)

	{

		obj, err = j.ExplicitFilter.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"premium_tier":`)
	fflib.FormatBits2(buf, uint64(j.NitroBoost), 10, false)
	buf.WriteString(`,"mfa_level":`)
	fflib.FormatBits2(buf, uint64(j.MFA), 10, false)
	buf.WriteString(`,"owner_id":`)

	{

		obj, err = j.OwnerID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.WidgetChannelID != 0 {
		buf.WriteString(`"widget_channel_id":`)

		{

			obj, err = j.WidgetChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.SystemChannelID != 0 {
		buf.WriteString(`"system_channel_id":`)

		{

			obj, err = j.SystemChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Permissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.Permissions), 10, false)
		buf.WriteString(`",`)
	}
	buf.WriteString(`"region":`)
	fflib.WriteJsonString(buf, string(j.VoiceRegion))
	buf.WriteByte(',')
	if j.AFKChannelID != 0 {
		buf.WriteString(`"afk_channel_id":`)

		{

			obj, err = j.AFKChannelID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"afk_timeout":`)

	{

		obj, err = j.AFKTimeout.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"roles":`)
	if j.Roles != nil {
		buf.WriteString(`[`)
		for i, v := range j.Roles {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"emojis":`)
	if j.Emojis != nil {
		buf.WriteString(`[`)
		for i, v := range j.Emojis {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"features":`)
	if j.Features != nil {
		buf.WriteString(`[`)
		for i, v := range j.Features {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"rules_channel_id":`)

	{

		obj, err = j.RulesChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.MaxPresences != 0 {
		buf.WriteString(`"max_presences":`)
		fflib.FormatBits2(buf, uint64(j.MaxPresences), 10, false)
		buf.WriteByte(',')
	}
	if j.MaxMembers != 0 {
		buf.WriteString(`"max_members":`)
		fflib.FormatBits2(buf, uint64(j.MaxMembers), 10, false)
		buf.WriteByte(',')
	}
	if len(j.VanityURLCode) != 0 {
		buf.WriteString(`"vanity_url_code":`)
		fflib.WriteJsonString(buf, string(j.VanityURLCode))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Banner) != 0 {
		buf.WriteString(`"banner":`)
		fflib.WriteJsonString(buf, string(j.Banner))
		buf.WriteByte(',')
	}
	if j.NitroBoosters != 0 {
		buf.WriteString(`"premium_subscription_count":`)
		fflib.FormatBits2(buf, uint64(j.NitroBoosters), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"preferred_locale":`)
	fflib.WriteJsonString(buf, string(j.PreferredLocale))
	buf.WriteString(`,"public_updates_channel_id":`)

	{

		obj, err = j.PublicUpdatesChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.MaxVideoChannelUsers != 0 {
		buf.WriteString(`"max_video_channel_users":`)
		fflib.FormatBits2(buf, uint64(j.MaxVideoChannelUsers), 10, false)
		buf.WriteByte(',')
	}
	if j.ApproximateMembers != 0 {
		buf.WriteString(`"approximate_member_count":`)
		fflib.FormatBits2(buf, uint64(j.ApproximateMembers), 10, false)
		buf.WriteByte(',')
	}
	if j.ApproximatePresences != 0 {
		buf.WriteString(`"approximate_presence_count":`)
		fflib.FormatBits2(buf, uint64(j.ApproximatePresences), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"nsfw_level":`)
	fflib.FormatBits2(buf, uint64(j.NSFWLevel), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGuildUpdateEventbase = iota
	ffjtGuildUpdateEventnosuchkey

	ffjtGuildUpdateEventID

	ffjtGuildUpdateEventName

	ffjtGuildUpdateEventIcon

	ffjtGuildUpdateEventSplash

	ffjtGuildUpdateEventDiscoverySplash

	ffjtGuildUpdateEventOwner

	ffjtGuildUpdateEventWidget

	ffjtGuildUpdateEventSystemChannelFlags

	ffjtGuildUpdateEventVerification

	ffjtGuildUpdateEventNotification

	ffjtGuildUpdateEventExplicitFilter

	ffjtGuildUpdateEventNitroBoost

	ffjtGuildUpdateEventMFA

	ffjtGuildUpdateEventOwnerID

	ffjtGuildUpdateEventWidgetChannelID

	ffjtGuildUpdateEventSystemChannelID

	ffjtGuildUpdateEventPermissions

	ffjtGuildUpdateEventVoiceRegion

	ffjtGuildUpdateEventAFKChannelID

	ffjtGuildUpdateEventAFKTimeout

	ffjtGuildUpdateEventRoles

	ffjtGuildUpdateEventEmojis

	ffjtGuildUpdateEventFeatures

	ffjtGuildUpdateEventAppID

	ffjtGuildUpdateEventRulesChannelID

	ffjtGuildUpdateEventMaxPresences

	ffjtGuildUpdateEventMaxMembers

	ffjtGuildUpdateEventVanityURLCode

	ffjtGuildUpdateEventDescription

	ffjtGuildUpdateEventBanner

	ffjtGuildUpdateEventNitroBoosters

	ffjtGuildUpdateEventPreferredLocale

	ffjtGuildUpdateEventPublicUpdatesChannelID

	ffjtGuildUpdateEventMaxVideoChannelUsers

	ffjtGuildUpdateEventApproximateMembers

	ffjtGuildUpdateEventApproximatePresences

	ffjtGuildUpdateEventNSFWLevel
)

var ffjKeyGuildUpdateEventID = []byte("id")

var ffjKeyGuildUpdateEventName = []byte("name")

var ffjKeyGuildUpdateEventIcon = []byte("icon")

var ffjKeyGuildUpdateEventSplash = []byte("splash")

var ffjKeyGuildUpdateEventDiscoverySplash = []byte("discovery_splash")

var ffjKeyGuildUpdateEventOwner = []byte("owner")

var ffjKeyGuildUpdateEventWidget = []byte("widget_enabled")

var ffjKeyGuildUpdateEventSystemChannelFlags = []byte("system_channel_flags")

var ffjKeyGuildUpdateEventVerification = []byte("verification_level")

var ffjKeyGuildUpdateEventNotification = []byte("default_message_notifications")

var ffjKeyGuildUpdateEventExplicitFilter = []byte("explicit_content_filter")

var ffjKeyGuildUpdateEventNitroBoost = []byte("premium_tier")

var ffjKeyGuildUpdateEventMFA = []byte("mfa_level")

var ffjKeyGuildUpdateEventOwnerID = []byte("owner_id")

var ffjKeyGuildUpdateEventWidgetChannelID = []byte("widget_channel_id")

var ffjKeyGuildUpdateEventSystemChannelID = []byte("system_channel_id")

var ffjKeyGuildUpdateEventPermissions = []byte("permissions")

var ffjKeyGuildUpdateEventVoiceRegion = []byte("region")

var ffjKeyGuildUpdateEventAFKChannelID = []byte("afk_channel_id")

var ffjKeyGuildUpdateEventAFKTimeout = []byte("afk_timeout")

var ffjKeyGuildUpdateEventRoles = []byte("roles")

var ffjKeyGuildUpdateEventEmojis = []byte("emojis")

var ffjKeyGuildUpdateEventFeatures = []byte("features")

var ffjKeyGuildUpdateEventAppID = []byte("application_id")

var ffjKeyGuildUpdateEventRulesChannelID = []byte("rules_channel_id")

var ffjKeyGuildUpdateEventMaxPresences = []byte("max_presences")

var ffjKeyGuildUpdateEventMaxMembers = []byte("max_members")

var ffjKeyGuildUpdateEventVanityURLCode = []byte("vanity_url_code")

var ffjKeyGuildUpdateEventDescription = []byte("description")

var ffjKeyGuildUpdateEventBanner = []byte("banner")

var ffjKeyGuildUpdateEventNitroBoosters = []byte("premium_subscription_count")

var ffjKeyGuildUpdateEventPreferredLocale = []byte("preferred_locale")

var ffjKeyGuildUpdateEventPublicUpdatesChannelID = []byte("public_updates_channel_id")

var ffjKeyGuildUpdateEventMaxVideoChannelUsers = []byte("max_video_channel_users")

var ffjKeyGuildUpdateEventApproximateMembers = []byte("approximate_member_count")

var ffjKeyGuildUpdateEventApproximatePresences = []byte("approximate_presence_count")

var ffjKeyGuildUpdateEventNSFWLevel = []byte("nsfw_level")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GuildUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GuildUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGuildUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGuildUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGuildUpdateEventAFKChannelID, kn) {
						currentKey = ffjtGuildUpdateEventAFKChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventAFKTimeout, kn) {
						currentKey = ffjtGuildUpdateEventAFKTimeout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventAppID, kn) {
						currentKey = ffjtGuildUpdateEventAppID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventApproximateMembers, kn) {
						currentKey = ffjtGuildUpdateEventApproximateMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventApproximatePresences, kn) {
						currentKey = ffjtGuildUpdateEventApproximatePresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyGuildUpdateEventBanner, kn) {
						currentKey = ffjtGuildUpdateEventBanner
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGuildUpdateEventDiscoverySplash, kn) {
						currentKey = ffjtGuildUpdateEventDiscoverySplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventNotification, kn) {
						currentKey = ffjtGuildUpdateEventNotification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventDescription, kn) {
						currentKey = ffjtGuildUpdateEventDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyGuildUpdateEventExplicitFilter, kn) {
						currentKey = ffjtGuildUpdateEventExplicitFilter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventEmojis, kn) {
						currentKey = ffjtGuildUpdateEventEmojis
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyGuildUpdateEventFeatures, kn) {
						currentKey = ffjtGuildUpdateEventFeatures
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGuildUpdateEventID, kn) {
						currentKey = ffjtGuildUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventIcon, kn) {
						currentKey = ffjtGuildUpdateEventIcon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyGuildUpdateEventMFA, kn) {
						currentKey = ffjtGuildUpdateEventMFA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventMaxPresences, kn) {
						currentKey = ffjtGuildUpdateEventMaxPresences
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventMaxMembers, kn) {
						currentKey = ffjtGuildUpdateEventMaxMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventMaxVideoChannelUsers, kn) {
						currentKey = ffjtGuildUpdateEventMaxVideoChannelUsers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGuildUpdateEventName, kn) {
						currentKey = ffjtGuildUpdateEventName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventNSFWLevel, kn) {
						currentKey = ffjtGuildUpdateEventNSFWLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyGuildUpdateEventOwner, kn) {
						currentKey = ffjtGuildUpdateEventOwner
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventOwnerID, kn) {
						currentKey = ffjtGuildUpdateEventOwnerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGuildUpdateEventNitroBoost, kn) {
						currentKey = ffjtGuildUpdateEventNitroBoost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventPermissions, kn) {
						currentKey = ffjtGuildUpdateEventPermissions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventNitroBoosters, kn) {
						currentKey = ffjtGuildUpdateEventNitroBoosters
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventPreferredLocale, kn) {
						currentKey = ffjtGuildUpdateEventPreferredLocale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventPublicUpdatesChannelID, kn) {
						currentKey = ffjtGuildUpdateEventPublicUpdatesChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyGuildUpdateEventVoiceRegion, kn) {
						currentKey = ffjtGuildUpdateEventVoiceRegion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventRoles, kn) {
						currentKey = ffjtGuildUpdateEventRoles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventRulesChannelID, kn) {
						currentKey = ffjtGuildUpdateEventRulesChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGuildUpdateEventSplash, kn) {
						currentKey = ffjtGuildUpdateEventSplash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventSystemChannelFlags, kn) {
						currentKey = ffjtGuildUpdateEventSystemChannelFlags
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventSystemChannelID, kn) {
						currentKey = ffjtGuildUpdateEventSystemChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyGuildUpdateEventVerification, kn) {
						currentKey = ffjtGuildUpdateEventVerification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventVanityURLCode, kn) {
						currentKey = ffjtGuildUpdateEventVanityURLCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyGuildUpdateEventWidget, kn) {
						currentKey = ffjtGuildUpdateEventWidget
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGuildUpdateEventWidgetChannelID, kn) {
						currentKey = ffjtGuildUpdateEventWidgetChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventNSFWLevel, kn) {
					currentKey = ffjtGuildUpdateEventNSFWLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventApproximatePresences, kn) {
					currentKey = ffjtGuildUpdateEventApproximatePresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventApproximateMembers, kn) {
					currentKey = ffjtGuildUpdateEventApproximateMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventMaxVideoChannelUsers, kn) {
					currentKey = ffjtGuildUpdateEventMaxVideoChannelUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventPublicUpdatesChannelID, kn) {
					currentKey = ffjtGuildUpdateEventPublicUpdatesChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventPreferredLocale, kn) {
					currentKey = ffjtGuildUpdateEventPreferredLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventNitroBoosters, kn) {
					currentKey = ffjtGuildUpdateEventNitroBoosters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildUpdateEventBanner, kn) {
					currentKey = ffjtGuildUpdateEventBanner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventDescription, kn) {
					currentKey = ffjtGuildUpdateEventDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventVanityURLCode, kn) {
					currentKey = ffjtGuildUpdateEventVanityURLCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventMaxMembers, kn) {
					currentKey = ffjtGuildUpdateEventMaxMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventMaxPresences, kn) {
					currentKey = ffjtGuildUpdateEventMaxPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventRulesChannelID, kn) {
					currentKey = ffjtGuildUpdateEventRulesChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventAppID, kn) {
					currentKey = ffjtGuildUpdateEventAppID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventFeatures, kn) {
					currentKey = ffjtGuildUpdateEventFeatures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventEmojis, kn) {
					currentKey = ffjtGuildUpdateEventEmojis
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventRoles, kn) {
					currentKey = ffjtGuildUpdateEventRoles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventAFKTimeout, kn) {
					currentKey = ffjtGuildUpdateEventAFKTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventAFKChannelID, kn) {
					currentKey = ffjtGuildUpdateEventAFKChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildUpdateEventVoiceRegion, kn) {
					currentKey = ffjtGuildUpdateEventVoiceRegion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventPermissions, kn) {
					currentKey = ffjtGuildUpdateEventPermissions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventSystemChannelID, kn) {
					currentKey = ffjtGuildUpdateEventSystemChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventWidgetChannelID, kn) {
					currentKey = ffjtGuildUpdateEventWidgetChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventOwnerID, kn) {
					currentKey = ffjtGuildUpdateEventOwnerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventMFA, kn) {
					currentKey = ffjtGuildUpdateEventMFA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventNitroBoost, kn) {
					currentKey = ffjtGuildUpdateEventNitroBoost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventExplicitFilter, kn) {
					currentKey = ffjtGuildUpdateEventExplicitFilter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventNotification, kn) {
					currentKey = ffjtGuildUpdateEventNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventVerification, kn) {
					currentKey = ffjtGuildUpdateEventVerification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventSystemChannelFlags, kn) {
					currentKey = ffjtGuildUpdateEventSystemChannelFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGuildUpdateEventWidget, kn) {
					currentKey = ffjtGuildUpdateEventWidget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildUpdateEventOwner, kn) {
					currentKey = ffjtGuildUpdateEventOwner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventDiscoverySplash, kn) {
					currentKey = ffjtGuildUpdateEventDiscoverySplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGuildUpdateEventSplash, kn) {
					currentKey = ffjtGuildUpdateEventSplash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildUpdateEventIcon, kn) {
					currentKey = ffjtGuildUpdateEventIcon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildUpdateEventName, kn) {
					currentKey = ffjtGuildUpdateEventName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGuildUpdateEventID, kn) {
					currentKey = ffjtGuildUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGuildUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGuildUpdateEventID:
					goto handle_ID

				case ffjtGuildUpdateEventName:
					goto handle_Name

				case ffjtGuildUpdateEventIcon:
					goto handle_Icon

				case ffjtGuildUpdateEventSplash:
					goto handle_Splash

				case ffjtGuildUpdateEventDiscoverySplash:
					goto handle_DiscoverySplash

				case ffjtGuildUpdateEventOwner:
					goto handle_Owner

				case ffjtGuildUpdateEventWidget:
					goto handle_Widget

				case ffjtGuildUpdateEventSystemChannelFlags:
					goto handle_SystemChannelFlags

				case ffjtGuildUpdateEventVerification:
					goto handle_Verification

				case ffjtGuildUpdateEventNotification:
					goto handle_Notification

				case ffjtGuildUpdateEventExplicitFilter:
					goto handle_ExplicitFilter

				case ffjtGuildUpdateEventNitroBoost:
					goto handle_NitroBoost

				case ffjtGuildUpdateEventMFA:
					goto handle_MFA

				case ffjtGuildUpdateEventOwnerID:
					goto handle_OwnerID

				case ffjtGuildUpdateEventWidgetChannelID:
					goto handle_WidgetChannelID

				case ffjtGuildUpdateEventSystemChannelID:
					goto handle_SystemChannelID

				case ffjtGuildUpdateEventPermissions:
					goto handle_Permissions

				case ffjtGuildUpdateEventVoiceRegion:
					goto handle_VoiceRegion

				case ffjtGuildUpdateEventAFKChannelID:
					goto handle_AFKChannelID

				case ffjtGuildUpdateEventAFKTimeout:
					goto handle_AFKTimeout

				case ffjtGuildUpdateEventRoles:
					goto handle_Roles

				case ffjtGuildUpdateEventEmojis:
					goto handle_Emojis

				case ffjtGuildUpdateEventFeatures:
					goto handle_Features

				case ffjtGuildUpdateEventAppID:
					goto handle_AppID

				case ffjtGuildUpdateEventRulesChannelID:
					goto handle_RulesChannelID

				case ffjtGuildUpdateEventMaxPresences:
					goto handle_MaxPresences

				case ffjtGuildUpdateEventMaxMembers:
					goto handle_MaxMembers

				case ffjtGuildUpdateEventVanityURLCode:
					goto handle_VanityURLCode

				case ffjtGuildUpdateEventDescription:
					goto handle_Description

				case ffjtGuildUpdateEventBanner:
					goto handle_Banner

				case ffjtGuildUpdateEventNitroBoosters:
					goto handle_NitroBoosters

				case ffjtGuildUpdateEventPreferredLocale:
					goto handle_PreferredLocale

				case ffjtGuildUpdateEventPublicUpdatesChannelID:
					goto handle_PublicUpdatesChannelID

				case ffjtGuildUpdateEventMaxVideoChannelUsers:
					goto handle_MaxVideoChannelUsers

				case ffjtGuildUpdateEventApproximateMembers:
					goto handle_ApproximateMembers

				case ffjtGuildUpdateEventApproximatePresences:
					goto handle_ApproximatePresences

				case ffjtGuildUpdateEventNSFWLevel:
					goto handle_NSFWLevel

				case ffjtGuildUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icon:

	/* handler: j.Icon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Icon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Splash:

	/* handler: j.Splash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Splash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiscoverySplash:

	/* handler: j.DiscoverySplash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DiscoverySplash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Owner:

	/* handler: j.Owner type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Owner = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Owner = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Widget:

	/* handler: j.Widget type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Widget = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Widget = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemChannelFlags:

	/* handler: j.SystemChannelFlags type=discord.SystemChannelFlags kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for SystemChannelFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SystemChannelFlags = discord.SystemChannelFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Verification:

	/* handler: j.Verification type=discord.Verification kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Verification.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notification:

	/* handler: j.Notification type=discord.Notification kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Notification.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExplicitFilter:

	/* handler: j.ExplicitFilter type=discord.ExplicitFilter kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ExplicitFilter.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NitroBoost:

	/* handler: j.NitroBoost type=discord.NitroBoost kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NitroBoost", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NitroBoost = discord.NitroBoost(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MFA:

	/* handler: j.MFA type=discord.MFALevel kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MFALevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MFA = discord.MFALevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerID:

	/* handler: j.OwnerID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.OwnerID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WidgetChannelID:

	/* handler: j.WidgetChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WidgetChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemChannelID:

	/* handler: j.SystemChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.SystemChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Permissions:

	/* handler: j.Permissions type=discord.Permissions kind=uint64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Permissions", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Permissions = discord.Permissions(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceRegion:

	/* handler: j.VoiceRegion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VoiceRegion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFKChannelID:

	/* handler: j.AFKChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AFKChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFKTimeout:

	/* handler: j.AFKTimeout type=discord.Seconds kind=int quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AFKTimeout.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Roles:

	/* handler: j.Roles type=[]discord.Role kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Roles = nil
		} else {

			j.Roles = []discord.Role{}

			wantVal := true

			for {

				var tmpJRoles discord.Role

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoles type=discord.Role kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJRoles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Roles = append(j.Roles, tmpJRoles)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emojis:

	/* handler: j.Emojis type=[]discord.Emoji kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Emojis = nil
		} else {

			j.Emojis = []discord.Emoji{}

			wantVal := true

			for {

				var tmpJEmojis discord.Emoji

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmojis type=discord.Emoji kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJEmojis.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Emojis = append(j.Emojis, tmpJEmojis)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Features:

	/* handler: j.Features type=[]discord.GuildFeature kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Features = nil
		} else {

			j.Features = []discord.GuildFeature{}

			wantVal := true

			for {

				var tmpJFeatures discord.GuildFeature

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFeatures type=discord.GuildFeature kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for GuildFeature", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJFeatures = discord.GuildFeature(string(outBuf))

					}
				}

				j.Features = append(j.Features, tmpJFeatures)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppID:

	/* handler: j.AppID type=discord.AppID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AppID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RulesChannelID:

	/* handler: j.RulesChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.RulesChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxPresences:

	/* handler: j.MaxPresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxPresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxMembers:

	/* handler: j.MaxMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VanityURLCode:

	/* handler: j.VanityURLCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VanityURLCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Banner:

	/* handler: j.Banner type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Banner = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NitroBoosters:

	/* handler: j.NitroBoosters type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NitroBoosters = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreferredLocale:

	/* handler: j.PreferredLocale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PreferredLocale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PublicUpdatesChannelID:

	/* handler: j.PublicUpdatesChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.PublicUpdatesChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxVideoChannelUsers:

	/* handler: j.MaxVideoChannelUsers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxVideoChannelUsers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximateMembers:

	/* handler: j.ApproximateMembers type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximateMembers = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApproximatePresences:

	/* handler: j.ApproximatePresences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ApproximatePresences = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NSFWLevel:

	/* handler: j.NSFWLevel type=discord.NSFWLevel kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NSFWLevel", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NSFWLevel = discord.NSFWLevel(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HeartbeatAckEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HeartbeatAckEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtHeartbeatAckEventbase = iota
	ffjtHeartbeatAckEventnosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *HeartbeatAckEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HeartbeatAckEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHeartbeatAckEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHeartbeatAckEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtHeartbeatAckEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHeartbeatAckEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HelloEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HelloEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"heartbeat_interval":`)
	fflib.AppendFloat(buf, float64(j.HeartbeatInterval), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHelloEventbase = iota
	ffjtHelloEventnosuchkey

	ffjtHelloEventHeartbeatInterval
)

var ffjKeyHelloEventHeartbeatInterval = []byte("heartbeat_interval")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HelloEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HelloEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHelloEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHelloEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffjKeyHelloEventHeartbeatInterval, kn) {
						currentKey = ffjtHelloEventHeartbeatInterval
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyHelloEventHeartbeatInterval, kn) {
					currentKey = ffjtHelloEventHeartbeatInterval
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHelloEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHelloEventHeartbeatInterval:
					goto handle_HeartbeatInterval

				case ffjtHelloEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_HeartbeatInterval:

	/* handler: j.HeartbeatInterval type=discord.Milliseconds kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Milliseconds", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.HeartbeatInterval = discord.Milliseconds(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InviteCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InviteCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.WriteJsonString(buf, string(j.Code))
	buf.WriteString(`,"created_at":`)

	{

		obj, err = j.CreatedAt.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Inviter != nil {
		if true {
			buf.WriteString(`"inviter":`)

			{

				err = j.Inviter.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Target != nil {
		if true {
			buf.WriteString(`"target_user":`)

			{

				err = j.Target.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.TargetType != 0 {
		buf.WriteString(`"target_user_type":`)
		fflib.FormatBits2(buf, uint64(j.TargetType), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"uses":`)
	fflib.FormatBits2(buf, uint64(j.Uses), 10, j.Uses < 0)
	buf.WriteString(`,"max_uses":`)
	fflib.FormatBits2(buf, uint64(j.MaxUses), 10, j.MaxUses < 0)
	buf.WriteString(`,"max_age":`)

	{

		obj, err = j.MaxAge.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Temporary {
		buf.WriteString(`,"temporary":true`)
	} else {
		buf.WriteString(`,"temporary":false`)
	}
	buf.WriteString(`,"created_at":`)

	{

		obj, err = j.CreatedAt.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInviteCreateEventbase = iota
	ffjtInviteCreateEventnosuchkey

	ffjtInviteCreateEventCode

	ffjtInviteCreateEventCreatedAt

	ffjtInviteCreateEventChannelID

	ffjtInviteCreateEventGuildID

	ffjtInviteCreateEventInviter

	ffjtInviteCreateEventTarget

	ffjtInviteCreateEventTargetType

	ffjtInviteCreateEventUses

	ffjtInviteCreateEventMaxUses

	ffjtInviteCreateEventMaxAge

	ffjtInviteCreateEventTemporary
)

var ffjKeyInviteCreateEventCode = []byte("code")

var ffjKeyInviteCreateEventCreatedAt = []byte("created_at")

var ffjKeyInviteCreateEventChannelID = []byte("channel_id")

var ffjKeyInviteCreateEventGuildID = []byte("guild_id")

var ffjKeyInviteCreateEventInviter = []byte("inviter")

var ffjKeyInviteCreateEventTarget = []byte("target_user")

var ffjKeyInviteCreateEventTargetType = []byte("target_user_type")

var ffjKeyInviteCreateEventUses = []byte("uses")

var ffjKeyInviteCreateEventMaxUses = []byte("max_uses")

var ffjKeyInviteCreateEventMaxAge = []byte("max_age")

var ffjKeyInviteCreateEventTemporary = []byte("temporary")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InviteCreateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InviteCreateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInviteCreateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInviteCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInviteCreateEventCode, kn) {
						currentKey = ffjtInviteCreateEventCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteCreateEventCreatedAt, kn) {
						currentKey = ffjtInviteCreateEventCreatedAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteCreateEventChannelID, kn) {
						currentKey = ffjtInviteCreateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteCreateEventCreatedAt, kn) {
						currentKey = ffjtInviteCreateEventCreatedAt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyInviteCreateEventGuildID, kn) {
						currentKey = ffjtInviteCreateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInviteCreateEventInviter, kn) {
						currentKey = ffjtInviteCreateEventInviter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInviteCreateEventMaxUses, kn) {
						currentKey = ffjtInviteCreateEventMaxUses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteCreateEventMaxAge, kn) {
						currentKey = ffjtInviteCreateEventMaxAge
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInviteCreateEventTarget, kn) {
						currentKey = ffjtInviteCreateEventTarget
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteCreateEventTargetType, kn) {
						currentKey = ffjtInviteCreateEventTargetType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteCreateEventTemporary, kn) {
						currentKey = ffjtInviteCreateEventTemporary
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyInviteCreateEventUses, kn) {
						currentKey = ffjtInviteCreateEventUses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInviteCreateEventCreatedAt, kn) {
					currentKey = ffjtInviteCreateEventCreatedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInviteCreateEventTemporary, kn) {
					currentKey = ffjtInviteCreateEventTemporary
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInviteCreateEventMaxAge, kn) {
					currentKey = ffjtInviteCreateEventMaxAge
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInviteCreateEventMaxUses, kn) {
					currentKey = ffjtInviteCreateEventMaxUses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInviteCreateEventUses, kn) {
					currentKey = ffjtInviteCreateEventUses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInviteCreateEventTargetType, kn) {
					currentKey = ffjtInviteCreateEventTargetType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInviteCreateEventTarget, kn) {
					currentKey = ffjtInviteCreateEventTarget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInviteCreateEventInviter, kn) {
					currentKey = ffjtInviteCreateEventInviter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInviteCreateEventGuildID, kn) {
					currentKey = ffjtInviteCreateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInviteCreateEventChannelID, kn) {
					currentKey = ffjtInviteCreateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInviteCreateEventCreatedAt, kn) {
					currentKey = ffjtInviteCreateEventCreatedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInviteCreateEventCode, kn) {
					currentKey = ffjtInviteCreateEventCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInviteCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInviteCreateEventCode:
					goto handle_Code

				case ffjtInviteCreateEventChannelID:
					goto handle_ChannelID

				case ffjtInviteCreateEventGuildID:
					goto handle_GuildID

				case ffjtInviteCreateEventInviter:
					goto handle_Inviter

				case ffjtInviteCreateEventTarget:
					goto handle_Target

				case ffjtInviteCreateEventTargetType:
					goto handle_TargetType

				case ffjtInviteCreateEventUses:
					goto handle_Uses

				case ffjtInviteCreateEventMaxUses:
					goto handle_MaxUses

				case ffjtInviteCreateEventMaxAge:
					goto handle_MaxAge

				case ffjtInviteCreateEventTemporary:
					goto handle_Temporary

				case ffjtInviteCreateEventCreatedAt:
					goto handle_CreatedAt

				case ffjtInviteCreateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: j.Code type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Code = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inviter:

	/* handler: j.Inviter type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Inviter = nil

		} else {

			if j.Inviter == nil {
				j.Inviter = new(discord.User)
			}

			err = j.Inviter.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Target:

	/* handler: j.Target type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Target = nil

		} else {

			if j.Target == nil {
				j.Target = new(discord.User)
			}

			err = j.Target.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetType:

	/* handler: j.TargetType type=discord.InviteUserType kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InviteUserType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TargetType = discord.InviteUserType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uses:

	/* handler: j.Uses type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Uses = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxUses:

	/* handler: j.MaxUses type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxUses = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxAge:

	/* handler: j.MaxAge type=discord.Seconds kind=int quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaxAge.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Temporary:

	/* handler: j.Temporary type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Temporary = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Temporary = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedAt:

	/* handler: j.CreatedAt type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatedAt.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InviteDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InviteDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "code":`)
	fflib.WriteJsonString(buf, string(j.Code))
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInviteDeleteEventbase = iota
	ffjtInviteDeleteEventnosuchkey

	ffjtInviteDeleteEventCode

	ffjtInviteDeleteEventChannelID

	ffjtInviteDeleteEventGuildID
)

var ffjKeyInviteDeleteEventCode = []byte("code")

var ffjKeyInviteDeleteEventChannelID = []byte("channel_id")

var ffjKeyInviteDeleteEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InviteDeleteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InviteDeleteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInviteDeleteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInviteDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInviteDeleteEventCode, kn) {
						currentKey = ffjtInviteDeleteEventCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInviteDeleteEventChannelID, kn) {
						currentKey = ffjtInviteDeleteEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyInviteDeleteEventGuildID, kn) {
						currentKey = ffjtInviteDeleteEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInviteDeleteEventGuildID, kn) {
					currentKey = ffjtInviteDeleteEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInviteDeleteEventChannelID, kn) {
					currentKey = ffjtInviteDeleteEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInviteDeleteEventCode, kn) {
					currentKey = ffjtInviteDeleteEventCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInviteDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInviteDeleteEventCode:
					goto handle_Code

				case ffjtInviteDeleteEventChannelID:
					goto handle_ChannelID

				case ffjtInviteDeleteEventGuildID:
					goto handle_GuildID

				case ffjtInviteDeleteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: j.Code type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Code = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MergedPresences) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MergedPresences) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guilds":`)
	if j.Guilds != nil {
		buf.WriteString(`[`)
		for i, v := range j.Guilds {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"friends":`)
	if j.Friends != nil {
		buf.WriteString(`[`)
		for i, v := range j.Friends {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMergedPresencesbase = iota
	ffjtMergedPresencesnosuchkey

	ffjtMergedPresencesGuilds

	ffjtMergedPresencesFriends
)

var ffjKeyMergedPresencesGuilds = []byte("guilds")

var ffjKeyMergedPresencesFriends = []byte("friends")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MergedPresences) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MergedPresences) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMergedPresencesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMergedPresencesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyMergedPresencesFriends, kn) {
						currentKey = ffjtMergedPresencesFriends
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMergedPresencesGuilds, kn) {
						currentKey = ffjtMergedPresencesGuilds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMergedPresencesFriends, kn) {
					currentKey = ffjtMergedPresencesFriends
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMergedPresencesGuilds, kn) {
					currentKey = ffjtMergedPresencesGuilds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMergedPresencesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMergedPresencesGuilds:
					goto handle_Guilds

				case ffjtMergedPresencesFriends:
					goto handle_Friends

				case ffjtMergedPresencesnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Guilds:

	/* handler: j.Guilds type=[][]gateway.SupplementalPresence kind=slice quoted=false*/

	{
		/* Falling back. type=[][]gateway.SupplementalPresence kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Guilds)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Friends:

	/* handler: j.Friends type=[]gateway.SupplementalPresence kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Friends = nil
		} else {

			j.Friends = []SupplementalPresence{}

			wantVal := true

			for {

				var tmpJFriends SupplementalPresence

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFriends type=gateway.SupplementalPresence kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJFriends.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Friends = append(j.Friends, tmpJFriends)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageAckEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageAckEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"message_id":`)

	{

		obj, err = j.MessageID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageAckEventbase = iota
	ffjtMessageAckEventnosuchkey

	ffjtMessageAckEventMessageID

	ffjtMessageAckEventChannelID
)

var ffjKeyMessageAckEventMessageID = []byte("message_id")

var ffjKeyMessageAckEventChannelID = []byte("channel_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageAckEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageAckEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageAckEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageAckEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageAckEventChannelID, kn) {
						currentKey = ffjtMessageAckEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageAckEventMessageID, kn) {
						currentKey = ffjtMessageAckEventMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMessageAckEventChannelID, kn) {
					currentKey = ffjtMessageAckEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageAckEventMessageID, kn) {
					currentKey = ffjtMessageAckEventMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageAckEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageAckEventMessageID:
					goto handle_MessageID

				case ffjtMessageAckEventChannelID:
					goto handle_ChannelID

				case ffjtMessageAckEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MessageID:

	/* handler: j.MessageID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MessageID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.FormatBits2(buf, uint64(j.Type), 10, false)
	buf.WriteString(`,"flags":`)
	fflib.FormatBits2(buf, uint64(j.Flags), 10, j.Flags < 0)
	if j.TTS {
		buf.WriteString(`,"tts":true`)
	} else {
		buf.WriteString(`,"tts":false`)
	}
	if j.Pinned {
		buf.WriteString(`,"pinned":true`)
	} else {
		buf.WriteString(`,"pinned":false`)
	}
	if j.MentionEveryone {
		buf.WriteString(`,"mention_everyone":true`)
	} else {
		buf.WriteString(`,"mention_everyone":false`)
	}
	buf.WriteString(`,"mentions":`)
	if j.Mentions != nil {
		buf.WriteString(`[`)
		for i, v := range j.Mentions {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"mention_roles":`)
	if j.MentionRoleIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.MentionRoleIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.MentionChannels) != 0 {
		buf.WriteString(`"mention_channels":`)
		if j.MentionChannels != nil {
			buf.WriteString(`[`)
			for i, v := range j.MentionChannels {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"author":`)

	{

		err = j.Author.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"content":`)
	fflib.WriteJsonString(buf, string(j.Content))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"timestamp":`)

		{

			obj, err = j.Timestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"edited_timestamp":`)

		{

			obj, err = j.EditedTimestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"attachments":`)
	if j.Attachments != nil {
		buf.WriteString(`[`)
		for i, v := range j.Attachments {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"embeds":`)
	if j.Embeds != nil {
		buf.WriteString(`[`)
		for i, v := range j.Embeds {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.Reactions) != 0 {
		buf.WriteString(`"reactions":`)
		if j.Reactions != nil {
			buf.WriteString(`[`)
			for i, v := range j.Reactions {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Components) != 0 {
		buf.WriteString(`"components":`)
		if j.Components != nil {
			buf.WriteString(`[`)
			for i, v := range j.Components {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Interface types must use runtime reflection. type=discord.ContainerComponent kind=interface */
				err = buf.Encode(v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Nonce) != 0 {
		buf.WriteString(`"nonce":`)
		fflib.WriteJsonString(buf, string(j.Nonce))
		buf.WriteByte(',')
	}
	if j.WebhookID != 0 {
		buf.WriteString(`"webhook_id":`)

		{

			obj, err = j.WebhookID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Activity != nil {
		if true {
			buf.WriteString(`"activity":`)

			{

				err = j.Activity.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Application != nil {
		if true {
			buf.WriteString(`"application":`)

			{

				err = j.Application.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ApplicationID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.ApplicationID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Reference != nil {
		if true {
			buf.WriteString(`"message_reference":`)

			{

				err = j.Reference.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReferencedMessage != nil {
		if true {
			buf.WriteString(`"referenced_message":`)

			{

				err = j.ReferencedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Interaction != nil {
		if true {
			buf.WriteString(`"interaction":`)

			{

				err = j.Interaction.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Stickers) != 0 {
		buf.WriteString(`"sticker_items":`)
		if j.Stickers != nil {
			buf.WriteString(`[`)
			for i, v := range j.Stickers {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageCreateEventbase = iota
	ffjtMessageCreateEventnosuchkey

	ffjtMessageCreateEventMember

	ffjtMessageCreateEventID

	ffjtMessageCreateEventChannelID

	ffjtMessageCreateEventGuildID

	ffjtMessageCreateEventType

	ffjtMessageCreateEventFlags

	ffjtMessageCreateEventTTS

	ffjtMessageCreateEventPinned

	ffjtMessageCreateEventMentionEveryone

	ffjtMessageCreateEventMentions

	ffjtMessageCreateEventMentionRoleIDs

	ffjtMessageCreateEventMentionChannels

	ffjtMessageCreateEventAuthor

	ffjtMessageCreateEventContent

	ffjtMessageCreateEventTimestamp

	ffjtMessageCreateEventEditedTimestamp

	ffjtMessageCreateEventAttachments

	ffjtMessageCreateEventEmbeds

	ffjtMessageCreateEventReactions

	ffjtMessageCreateEventComponents

	ffjtMessageCreateEventNonce

	ffjtMessageCreateEventWebhookID

	ffjtMessageCreateEventActivity

	ffjtMessageCreateEventApplication

	ffjtMessageCreateEventApplicationID

	ffjtMessageCreateEventReference

	ffjtMessageCreateEventReferencedMessage

	ffjtMessageCreateEventInteraction

	ffjtMessageCreateEventStickers
)

var ffjKeyMessageCreateEventMember = []byte("member")

var ffjKeyMessageCreateEventID = []byte("id")

var ffjKeyMessageCreateEventChannelID = []byte("channel_id")

var ffjKeyMessageCreateEventGuildID = []byte("guild_id")

var ffjKeyMessageCreateEventType = []byte("type")

var ffjKeyMessageCreateEventFlags = []byte("flags")

var ffjKeyMessageCreateEventTTS = []byte("tts")

var ffjKeyMessageCreateEventPinned = []byte("pinned")

var ffjKeyMessageCreateEventMentionEveryone = []byte("mention_everyone")

var ffjKeyMessageCreateEventMentions = []byte("mentions")

var ffjKeyMessageCreateEventMentionRoleIDs = []byte("mention_roles")

var ffjKeyMessageCreateEventMentionChannels = []byte("mention_channels")

var ffjKeyMessageCreateEventAuthor = []byte("author")

var ffjKeyMessageCreateEventContent = []byte("content")

var ffjKeyMessageCreateEventTimestamp = []byte("timestamp")

var ffjKeyMessageCreateEventEditedTimestamp = []byte("edited_timestamp")

var ffjKeyMessageCreateEventAttachments = []byte("attachments")

var ffjKeyMessageCreateEventEmbeds = []byte("embeds")

var ffjKeyMessageCreateEventReactions = []byte("reactions")

var ffjKeyMessageCreateEventComponents = []byte("components")

var ffjKeyMessageCreateEventNonce = []byte("nonce")

var ffjKeyMessageCreateEventWebhookID = []byte("webhook_id")

var ffjKeyMessageCreateEventActivity = []byte("activity")

var ffjKeyMessageCreateEventApplication = []byte("application")

var ffjKeyMessageCreateEventApplicationID = []byte("application_id")

var ffjKeyMessageCreateEventReference = []byte("message_reference")

var ffjKeyMessageCreateEventReferencedMessage = []byte("referenced_message")

var ffjKeyMessageCreateEventInteraction = []byte("interaction")

var ffjKeyMessageCreateEventStickers = []byte("sticker_items")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageCreateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageCreateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageCreateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMessageCreateEventAuthor, kn) {
						currentKey = ffjtMessageCreateEventAuthor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventAttachments, kn) {
						currentKey = ffjtMessageCreateEventAttachments
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventActivity, kn) {
						currentKey = ffjtMessageCreateEventActivity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventApplication, kn) {
						currentKey = ffjtMessageCreateEventApplication
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventApplicationID, kn) {
						currentKey = ffjtMessageCreateEventApplicationID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMessageCreateEventChannelID, kn) {
						currentKey = ffjtMessageCreateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventContent, kn) {
						currentKey = ffjtMessageCreateEventContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventComponents, kn) {
						currentKey = ffjtMessageCreateEventComponents
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageCreateEventEditedTimestamp, kn) {
						currentKey = ffjtMessageCreateEventEditedTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventEmbeds, kn) {
						currentKey = ffjtMessageCreateEventEmbeds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMessageCreateEventFlags, kn) {
						currentKey = ffjtMessageCreateEventFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageCreateEventGuildID, kn) {
						currentKey = ffjtMessageCreateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyMessageCreateEventID, kn) {
						currentKey = ffjtMessageCreateEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventInteraction, kn) {
						currentKey = ffjtMessageCreateEventInteraction
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageCreateEventMember, kn) {
						currentKey = ffjtMessageCreateEventMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventMentionEveryone, kn) {
						currentKey = ffjtMessageCreateEventMentionEveryone
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventMentions, kn) {
						currentKey = ffjtMessageCreateEventMentions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventMentionRoleIDs, kn) {
						currentKey = ffjtMessageCreateEventMentionRoleIDs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventMentionChannels, kn) {
						currentKey = ffjtMessageCreateEventMentionChannels
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventReference, kn) {
						currentKey = ffjtMessageCreateEventReference
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMessageCreateEventNonce, kn) {
						currentKey = ffjtMessageCreateEventNonce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMessageCreateEventPinned, kn) {
						currentKey = ffjtMessageCreateEventPinned
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyMessageCreateEventReactions, kn) {
						currentKey = ffjtMessageCreateEventReactions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventReferencedMessage, kn) {
						currentKey = ffjtMessageCreateEventReferencedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMessageCreateEventStickers, kn) {
						currentKey = ffjtMessageCreateEventStickers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageCreateEventType, kn) {
						currentKey = ffjtMessageCreateEventType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventTTS, kn) {
						currentKey = ffjtMessageCreateEventTTS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCreateEventTimestamp, kn) {
						currentKey = ffjtMessageCreateEventTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyMessageCreateEventWebhookID, kn) {
						currentKey = ffjtMessageCreateEventWebhookID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventStickers, kn) {
					currentKey = ffjtMessageCreateEventStickers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventInteraction, kn) {
					currentKey = ffjtMessageCreateEventInteraction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventReferencedMessage, kn) {
					currentKey = ffjtMessageCreateEventReferencedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventReference, kn) {
					currentKey = ffjtMessageCreateEventReference
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageCreateEventApplicationID, kn) {
					currentKey = ffjtMessageCreateEventApplicationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventApplication, kn) {
					currentKey = ffjtMessageCreateEventApplication
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventActivity, kn) {
					currentKey = ffjtMessageCreateEventActivity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventWebhookID, kn) {
					currentKey = ffjtMessageCreateEventWebhookID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventNonce, kn) {
					currentKey = ffjtMessageCreateEventNonce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventComponents, kn) {
					currentKey = ffjtMessageCreateEventComponents
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventReactions, kn) {
					currentKey = ffjtMessageCreateEventReactions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventEmbeds, kn) {
					currentKey = ffjtMessageCreateEventEmbeds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventAttachments, kn) {
					currentKey = ffjtMessageCreateEventAttachments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventEditedTimestamp, kn) {
					currentKey = ffjtMessageCreateEventEditedTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventTimestamp, kn) {
					currentKey = ffjtMessageCreateEventTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventContent, kn) {
					currentKey = ffjtMessageCreateEventContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventAuthor, kn) {
					currentKey = ffjtMessageCreateEventAuthor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventMentionChannels, kn) {
					currentKey = ffjtMessageCreateEventMentionChannels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventMentionRoleIDs, kn) {
					currentKey = ffjtMessageCreateEventMentionRoleIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventMentions, kn) {
					currentKey = ffjtMessageCreateEventMentions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageCreateEventMentionEveryone, kn) {
					currentKey = ffjtMessageCreateEventMentionEveryone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventPinned, kn) {
					currentKey = ffjtMessageCreateEventPinned
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventTTS, kn) {
					currentKey = ffjtMessageCreateEventTTS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCreateEventFlags, kn) {
					currentKey = ffjtMessageCreateEventFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventType, kn) {
					currentKey = ffjtMessageCreateEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageCreateEventGuildID, kn) {
					currentKey = ffjtMessageCreateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageCreateEventChannelID, kn) {
					currentKey = ffjtMessageCreateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventID, kn) {
					currentKey = ffjtMessageCreateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCreateEventMember, kn) {
					currentKey = ffjtMessageCreateEventMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageCreateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageCreateEventMember:
					goto handle_Member

				case ffjtMessageCreateEventID:
					goto handle_ID

				case ffjtMessageCreateEventChannelID:
					goto handle_ChannelID

				case ffjtMessageCreateEventGuildID:
					goto handle_GuildID

				case ffjtMessageCreateEventType:
					goto handle_Type

				case ffjtMessageCreateEventFlags:
					goto handle_Flags

				case ffjtMessageCreateEventTTS:
					goto handle_TTS

				case ffjtMessageCreateEventPinned:
					goto handle_Pinned

				case ffjtMessageCreateEventMentionEveryone:
					goto handle_MentionEveryone

				case ffjtMessageCreateEventMentions:
					goto handle_Mentions

				case ffjtMessageCreateEventMentionRoleIDs:
					goto handle_MentionRoleIDs

				case ffjtMessageCreateEventMentionChannels:
					goto handle_MentionChannels

				case ffjtMessageCreateEventAuthor:
					goto handle_Author

				case ffjtMessageCreateEventContent:
					goto handle_Content

				case ffjtMessageCreateEventTimestamp:
					goto handle_Timestamp

				case ffjtMessageCreateEventEditedTimestamp:
					goto handle_EditedTimestamp

				case ffjtMessageCreateEventAttachments:
					goto handle_Attachments

				case ffjtMessageCreateEventEmbeds:
					goto handle_Embeds

				case ffjtMessageCreateEventReactions:
					goto handle_Reactions

				case ffjtMessageCreateEventComponents:
					goto handle_Components

				case ffjtMessageCreateEventNonce:
					goto handle_Nonce

				case ffjtMessageCreateEventWebhookID:
					goto handle_WebhookID

				case ffjtMessageCreateEventActivity:
					goto handle_Activity

				case ffjtMessageCreateEventApplication:
					goto handle_Application

				case ffjtMessageCreateEventApplicationID:
					goto handle_ApplicationID

				case ffjtMessageCreateEventReference:
					goto handle_Reference

				case ffjtMessageCreateEventReferencedMessage:
					goto handle_ReferencedMessage

				case ffjtMessageCreateEventInteraction:
					goto handle_Interaction

				case ffjtMessageCreateEventStickers:
					goto handle_Stickers

				case ffjtMessageCreateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Member:

	/* handler: j.Member type=discord.Member kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(discord.Member)
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=discord.MessageType kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MessageType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Type = discord.MessageType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flags:

	/* handler: j.Flags type=discord.MessageFlags kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MessageFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Flags = discord.MessageFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TTS:

	/* handler: j.TTS type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.TTS = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.TTS = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pinned:

	/* handler: j.Pinned type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Pinned = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Pinned = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionEveryone:

	/* handler: j.MentionEveryone type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MentionEveryone = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MentionEveryone = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mentions:

	/* handler: j.Mentions type=[]discord.GuildUser kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Mentions = nil
		} else {

			j.Mentions = []discord.GuildUser{}

			wantVal := true

			for {

				var tmpJMentions discord.GuildUser

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMentions type=discord.GuildUser kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMentions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Mentions = append(j.Mentions, tmpJMentions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionRoleIDs:

	/* handler: j.MentionRoleIDs type=[]discord.RoleID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.MentionRoleIDs = nil
		} else {

			j.MentionRoleIDs = []discord.RoleID{}

			wantVal := true

			for {

				var tmpJMentionRoleIDs discord.RoleID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMentionRoleIDs type=discord.RoleID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJMentionRoleIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.MentionRoleIDs = append(j.MentionRoleIDs, tmpJMentionRoleIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionChannels:

	/* handler: j.MentionChannels type=[]discord.ChannelMention kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.MentionChannels = nil
		} else {

			j.MentionChannels = []discord.ChannelMention{}

			wantVal := true

			for {

				var tmpJMentionChannels discord.ChannelMention

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMentionChannels type=discord.ChannelMention kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMentionChannels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.MentionChannels = append(j.MentionChannels, tmpJMentionChannels)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Author:

	/* handler: j.Author type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Author.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: j.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Timestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedTimestamp:

	/* handler: j.EditedTimestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EditedTimestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attachments:

	/* handler: j.Attachments type=[]discord.Attachment kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Attachments = nil
		} else {

			j.Attachments = []discord.Attachment{}

			wantVal := true

			for {

				var tmpJAttachments discord.Attachment

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAttachments type=discord.Attachment kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJAttachments.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Attachments = append(j.Attachments, tmpJAttachments)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Embeds:

	/* handler: j.Embeds type=[]discord.Embed kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Embeds = nil
		} else {

			j.Embeds = []discord.Embed{}

			wantVal := true

			for {

				var tmpJEmbeds discord.Embed

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmbeds type=discord.Embed kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJEmbeds.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Embeds = append(j.Embeds, tmpJEmbeds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reactions:

	/* handler: j.Reactions type=[]discord.Reaction kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Reactions = nil
		} else {

			j.Reactions = []discord.Reaction{}

			wantVal := true

			for {

				var tmpJReactions discord.Reaction

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJReactions type=discord.Reaction kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJReactions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Reactions = append(j.Reactions, tmpJReactions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Components:

	/* handler: j.Components type=discord.ContainerComponents kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Components.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nonce:

	/* handler: j.Nonce type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nonce = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebhookID:

	/* handler: j.WebhookID type=discord.WebhookID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WebhookID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activity:

	/* handler: j.Activity type=discord.MessageActivity kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Activity = nil

		} else {

			if j.Activity == nil {
				j.Activity = new(discord.MessageActivity)
			}

			err = j.Activity.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Application:

	/* handler: j.Application type=discord.MessageApplication kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Application = nil

		} else {

			if j.Application == nil {
				j.Application = new(discord.MessageApplication)
			}

			err = j.Application.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApplicationID:

	/* handler: j.ApplicationID type=discord.AppID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ApplicationID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reference:

	/* handler: j.Reference type=discord.MessageReference kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Reference = nil

		} else {

			if j.Reference == nil {
				j.Reference = new(discord.MessageReference)
			}

			err = j.Reference.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReferencedMessage:

	/* handler: j.ReferencedMessage type=discord.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReferencedMessage = nil

		} else {

			if j.ReferencedMessage == nil {
				j.ReferencedMessage = new(discord.Message)
			}

			err = j.ReferencedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Interaction:

	/* handler: j.Interaction type=discord.MessageInteraction kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Interaction = nil

		} else {

			if j.Interaction == nil {
				j.Interaction = new(discord.MessageInteraction)
			}

			err = j.Interaction.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stickers:

	/* handler: j.Stickers type=[]discord.StickerItem kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Stickers = nil
		} else {

			j.Stickers = []discord.StickerItem{}

			wantVal := true

			for {

				var tmpJStickers discord.StickerItem

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJStickers type=discord.StickerItem kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJStickers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Stickers = append(j.Stickers, tmpJStickers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageDeleteBulkEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageDeleteBulkEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "ids":`)
	if j.IDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.IDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageDeleteBulkEventbase = iota
	ffjtMessageDeleteBulkEventnosuchkey

	ffjtMessageDeleteBulkEventIDs

	ffjtMessageDeleteBulkEventChannelID

	ffjtMessageDeleteBulkEventGuildID
)

var ffjKeyMessageDeleteBulkEventIDs = []byte("ids")

var ffjKeyMessageDeleteBulkEventChannelID = []byte("channel_id")

var ffjKeyMessageDeleteBulkEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageDeleteBulkEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageDeleteBulkEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageDeleteBulkEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageDeleteBulkEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageDeleteBulkEventChannelID, kn) {
						currentKey = ffjtMessageDeleteBulkEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageDeleteBulkEventGuildID, kn) {
						currentKey = ffjtMessageDeleteBulkEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyMessageDeleteBulkEventIDs, kn) {
						currentKey = ffjtMessageDeleteBulkEventIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteBulkEventGuildID, kn) {
					currentKey = ffjtMessageDeleteBulkEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteBulkEventChannelID, kn) {
					currentKey = ffjtMessageDeleteBulkEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageDeleteBulkEventIDs, kn) {
					currentKey = ffjtMessageDeleteBulkEventIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageDeleteBulkEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageDeleteBulkEventIDs:
					goto handle_IDs

				case ffjtMessageDeleteBulkEventChannelID:
					goto handle_ChannelID

				case ffjtMessageDeleteBulkEventGuildID:
					goto handle_GuildID

				case ffjtMessageDeleteBulkEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IDs:

	/* handler: j.IDs type=[]discord.MessageID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.IDs = nil
		} else {

			j.IDs = []discord.MessageID{}

			wantVal := true

			for {

				var tmpJIDs discord.MessageID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJIDs type=discord.MessageID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.IDs = append(j.IDs, tmpJIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageDeleteEventbase = iota
	ffjtMessageDeleteEventnosuchkey

	ffjtMessageDeleteEventID

	ffjtMessageDeleteEventChannelID

	ffjtMessageDeleteEventGuildID
)

var ffjKeyMessageDeleteEventID = []byte("id")

var ffjKeyMessageDeleteEventChannelID = []byte("channel_id")

var ffjKeyMessageDeleteEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageDeleteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageDeleteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageDeleteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageDeleteEventChannelID, kn) {
						currentKey = ffjtMessageDeleteEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageDeleteEventGuildID, kn) {
						currentKey = ffjtMessageDeleteEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyMessageDeleteEventID, kn) {
						currentKey = ffjtMessageDeleteEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteEventGuildID, kn) {
					currentKey = ffjtMessageDeleteEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteEventChannelID, kn) {
					currentKey = ffjtMessageDeleteEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDeleteEventID, kn) {
					currentKey = ffjtMessageDeleteEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageDeleteEventID:
					goto handle_ID

				case ffjtMessageDeleteEventChannelID:
					goto handle_ChannelID

				case ffjtMessageDeleteEventGuildID:
					goto handle_GuildID

				case ffjtMessageDeleteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageReactionAddEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageReactionAddEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"message_id":`)

	{

		obj, err = j.MessageID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"emoji":`)

		{

			err = j.Emoji.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageReactionAddEventbase = iota
	ffjtMessageReactionAddEventnosuchkey

	ffjtMessageReactionAddEventUserID

	ffjtMessageReactionAddEventChannelID

	ffjtMessageReactionAddEventMessageID

	ffjtMessageReactionAddEventEmoji

	ffjtMessageReactionAddEventGuildID

	ffjtMessageReactionAddEventMember
)

var ffjKeyMessageReactionAddEventUserID = []byte("user_id")

var ffjKeyMessageReactionAddEventChannelID = []byte("channel_id")

var ffjKeyMessageReactionAddEventMessageID = []byte("message_id")

var ffjKeyMessageReactionAddEventEmoji = []byte("emoji")

var ffjKeyMessageReactionAddEventGuildID = []byte("guild_id")

var ffjKeyMessageReactionAddEventMember = []byte("member")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageReactionAddEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageReactionAddEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageReactionAddEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageReactionAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageReactionAddEventChannelID, kn) {
						currentKey = ffjtMessageReactionAddEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageReactionAddEventEmoji, kn) {
						currentKey = ffjtMessageReactionAddEventEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageReactionAddEventGuildID, kn) {
						currentKey = ffjtMessageReactionAddEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageReactionAddEventMessageID, kn) {
						currentKey = ffjtMessageReactionAddEventMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageReactionAddEventMember, kn) {
						currentKey = ffjtMessageReactionAddEventMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMessageReactionAddEventUserID, kn) {
						currentKey = ffjtMessageReactionAddEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageReactionAddEventMember, kn) {
					currentKey = ffjtMessageReactionAddEventMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionAddEventGuildID, kn) {
					currentKey = ffjtMessageReactionAddEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageReactionAddEventEmoji, kn) {
					currentKey = ffjtMessageReactionAddEventEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReactionAddEventMessageID, kn) {
					currentKey = ffjtMessageReactionAddEventMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionAddEventChannelID, kn) {
					currentKey = ffjtMessageReactionAddEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReactionAddEventUserID, kn) {
					currentKey = ffjtMessageReactionAddEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageReactionAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageReactionAddEventUserID:
					goto handle_UserID

				case ffjtMessageReactionAddEventChannelID:
					goto handle_ChannelID

				case ffjtMessageReactionAddEventMessageID:
					goto handle_MessageID

				case ffjtMessageReactionAddEventEmoji:
					goto handle_Emoji

				case ffjtMessageReactionAddEventGuildID:
					goto handle_GuildID

				case ffjtMessageReactionAddEventMember:
					goto handle_Member

				case ffjtMessageReactionAddEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageID:

	/* handler: j.MessageID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MessageID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emoji:

	/* handler: j.Emoji type=discord.Emoji kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Emoji.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Member:

	/* handler: j.Member type=discord.Member kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(discord.Member)
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageReactionRemoveAllEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageReactionRemoveAllEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"message_id":`)

	{

		obj, err = j.MessageID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageReactionRemoveAllEventbase = iota
	ffjtMessageReactionRemoveAllEventnosuchkey

	ffjtMessageReactionRemoveAllEventChannelID

	ffjtMessageReactionRemoveAllEventMessageID

	ffjtMessageReactionRemoveAllEventGuildID
)

var ffjKeyMessageReactionRemoveAllEventChannelID = []byte("channel_id")

var ffjKeyMessageReactionRemoveAllEventMessageID = []byte("message_id")

var ffjKeyMessageReactionRemoveAllEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageReactionRemoveAllEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageReactionRemoveAllEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageReactionRemoveAllEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageReactionRemoveAllEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageReactionRemoveAllEventChannelID, kn) {
						currentKey = ffjtMessageReactionRemoveAllEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageReactionRemoveAllEventGuildID, kn) {
						currentKey = ffjtMessageReactionRemoveAllEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageReactionRemoveAllEventMessageID, kn) {
						currentKey = ffjtMessageReactionRemoveAllEventMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionRemoveAllEventGuildID, kn) {
					currentKey = ffjtMessageReactionRemoveAllEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReactionRemoveAllEventMessageID, kn) {
					currentKey = ffjtMessageReactionRemoveAllEventMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionRemoveAllEventChannelID, kn) {
					currentKey = ffjtMessageReactionRemoveAllEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageReactionRemoveAllEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageReactionRemoveAllEventChannelID:
					goto handle_ChannelID

				case ffjtMessageReactionRemoveAllEventMessageID:
					goto handle_MessageID

				case ffjtMessageReactionRemoveAllEventGuildID:
					goto handle_GuildID

				case ffjtMessageReactionRemoveAllEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageID:

	/* handler: j.MessageID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MessageID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageReactionRemoveEmojiEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageReactionRemoveEmojiEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"message_id":`)

	{

		obj, err = j.MessageID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"emoji":`)

	{

		err = j.Emoji.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageReactionRemoveEmojiEventbase = iota
	ffjtMessageReactionRemoveEmojiEventnosuchkey

	ffjtMessageReactionRemoveEmojiEventChannelID

	ffjtMessageReactionRemoveEmojiEventMessageID

	ffjtMessageReactionRemoveEmojiEventEmoji

	ffjtMessageReactionRemoveEmojiEventGuildID
)

var ffjKeyMessageReactionRemoveEmojiEventChannelID = []byte("channel_id")

var ffjKeyMessageReactionRemoveEmojiEventMessageID = []byte("message_id")

var ffjKeyMessageReactionRemoveEmojiEventEmoji = []byte("emoji")

var ffjKeyMessageReactionRemoveEmojiEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageReactionRemoveEmojiEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageReactionRemoveEmojiEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageReactionRemoveEmojiEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageReactionRemoveEmojiEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageReactionRemoveEmojiEventChannelID, kn) {
						currentKey = ffjtMessageReactionRemoveEmojiEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageReactionRemoveEmojiEventEmoji, kn) {
						currentKey = ffjtMessageReactionRemoveEmojiEventEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageReactionRemoveEmojiEventGuildID, kn) {
						currentKey = ffjtMessageReactionRemoveEmojiEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageReactionRemoveEmojiEventMessageID, kn) {
						currentKey = ffjtMessageReactionRemoveEmojiEventMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionRemoveEmojiEventGuildID, kn) {
					currentKey = ffjtMessageReactionRemoveEmojiEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageReactionRemoveEmojiEventEmoji, kn) {
					currentKey = ffjtMessageReactionRemoveEmojiEventEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReactionRemoveEmojiEventMessageID, kn) {
					currentKey = ffjtMessageReactionRemoveEmojiEventMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionRemoveEmojiEventChannelID, kn) {
					currentKey = ffjtMessageReactionRemoveEmojiEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageReactionRemoveEmojiEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageReactionRemoveEmojiEventChannelID:
					goto handle_ChannelID

				case ffjtMessageReactionRemoveEmojiEventMessageID:
					goto handle_MessageID

				case ffjtMessageReactionRemoveEmojiEventEmoji:
					goto handle_Emoji

				case ffjtMessageReactionRemoveEmojiEventGuildID:
					goto handle_GuildID

				case ffjtMessageReactionRemoveEmojiEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageID:

	/* handler: j.MessageID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MessageID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emoji:

	/* handler: j.Emoji type=discord.Emoji kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Emoji.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageReactionRemoveEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageReactionRemoveEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"message_id":`)

	{

		obj, err = j.MessageID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"emoji":`)

	{

		err = j.Emoji.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageReactionRemoveEventbase = iota
	ffjtMessageReactionRemoveEventnosuchkey

	ffjtMessageReactionRemoveEventUserID

	ffjtMessageReactionRemoveEventChannelID

	ffjtMessageReactionRemoveEventMessageID

	ffjtMessageReactionRemoveEventEmoji

	ffjtMessageReactionRemoveEventGuildID
)

var ffjKeyMessageReactionRemoveEventUserID = []byte("user_id")

var ffjKeyMessageReactionRemoveEventChannelID = []byte("channel_id")

var ffjKeyMessageReactionRemoveEventMessageID = []byte("message_id")

var ffjKeyMessageReactionRemoveEventEmoji = []byte("emoji")

var ffjKeyMessageReactionRemoveEventGuildID = []byte("guild_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageReactionRemoveEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageReactionRemoveEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageReactionRemoveEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageReactionRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageReactionRemoveEventChannelID, kn) {
						currentKey = ffjtMessageReactionRemoveEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageReactionRemoveEventEmoji, kn) {
						currentKey = ffjtMessageReactionRemoveEventEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageReactionRemoveEventGuildID, kn) {
						currentKey = ffjtMessageReactionRemoveEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageReactionRemoveEventMessageID, kn) {
						currentKey = ffjtMessageReactionRemoveEventMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMessageReactionRemoveEventUserID, kn) {
						currentKey = ffjtMessageReactionRemoveEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionRemoveEventGuildID, kn) {
					currentKey = ffjtMessageReactionRemoveEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageReactionRemoveEventEmoji, kn) {
					currentKey = ffjtMessageReactionRemoveEventEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReactionRemoveEventMessageID, kn) {
					currentKey = ffjtMessageReactionRemoveEventMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageReactionRemoveEventChannelID, kn) {
					currentKey = ffjtMessageReactionRemoveEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReactionRemoveEventUserID, kn) {
					currentKey = ffjtMessageReactionRemoveEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageReactionRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageReactionRemoveEventUserID:
					goto handle_UserID

				case ffjtMessageReactionRemoveEventChannelID:
					goto handle_ChannelID

				case ffjtMessageReactionRemoveEventMessageID:
					goto handle_MessageID

				case ffjtMessageReactionRemoveEventEmoji:
					goto handle_Emoji

				case ffjtMessageReactionRemoveEventGuildID:
					goto handle_GuildID

				case ffjtMessageReactionRemoveEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageID:

	/* handler: j.MessageID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MessageID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emoji:

	/* handler: j.Emoji type=discord.Emoji kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Emoji.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.FormatBits2(buf, uint64(j.Type), 10, false)
	buf.WriteString(`,"flags":`)
	fflib.FormatBits2(buf, uint64(j.Flags), 10, j.Flags < 0)
	if j.TTS {
		buf.WriteString(`,"tts":true`)
	} else {
		buf.WriteString(`,"tts":false`)
	}
	if j.Pinned {
		buf.WriteString(`,"pinned":true`)
	} else {
		buf.WriteString(`,"pinned":false`)
	}
	if j.MentionEveryone {
		buf.WriteString(`,"mention_everyone":true`)
	} else {
		buf.WriteString(`,"mention_everyone":false`)
	}
	buf.WriteString(`,"mentions":`)
	if j.Mentions != nil {
		buf.WriteString(`[`)
		for i, v := range j.Mentions {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"mention_roles":`)
	if j.MentionRoleIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.MentionRoleIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.MentionChannels) != 0 {
		buf.WriteString(`"mention_channels":`)
		if j.MentionChannels != nil {
			buf.WriteString(`[`)
			for i, v := range j.MentionChannels {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"author":`)

	{

		err = j.Author.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"content":`)
	fflib.WriteJsonString(buf, string(j.Content))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"timestamp":`)

		{

			obj, err = j.Timestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"edited_timestamp":`)

		{

			obj, err = j.EditedTimestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"attachments":`)
	if j.Attachments != nil {
		buf.WriteString(`[`)
		for i, v := range j.Attachments {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"embeds":`)
	if j.Embeds != nil {
		buf.WriteString(`[`)
		for i, v := range j.Embeds {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.Reactions) != 0 {
		buf.WriteString(`"reactions":`)
		if j.Reactions != nil {
			buf.WriteString(`[`)
			for i, v := range j.Reactions {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Components) != 0 {
		buf.WriteString(`"components":`)
		if j.Components != nil {
			buf.WriteString(`[`)
			for i, v := range j.Components {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Interface types must use runtime reflection. type=discord.ContainerComponent kind=interface */
				err = buf.Encode(v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Nonce) != 0 {
		buf.WriteString(`"nonce":`)
		fflib.WriteJsonString(buf, string(j.Nonce))
		buf.WriteByte(',')
	}
	if j.WebhookID != 0 {
		buf.WriteString(`"webhook_id":`)

		{

			obj, err = j.WebhookID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Activity != nil {
		if true {
			buf.WriteString(`"activity":`)

			{

				err = j.Activity.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Application != nil {
		if true {
			buf.WriteString(`"application":`)

			{

				err = j.Application.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ApplicationID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.ApplicationID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Reference != nil {
		if true {
			buf.WriteString(`"message_reference":`)

			{

				err = j.Reference.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReferencedMessage != nil {
		if true {
			buf.WriteString(`"referenced_message":`)

			{

				err = j.ReferencedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Interaction != nil {
		if true {
			buf.WriteString(`"interaction":`)

			{

				err = j.Interaction.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Stickers) != 0 {
		buf.WriteString(`"sticker_items":`)
		if j.Stickers != nil {
			buf.WriteString(`[`)
			for i, v := range j.Stickers {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageUpdateEventbase = iota
	ffjtMessageUpdateEventnosuchkey

	ffjtMessageUpdateEventMember

	ffjtMessageUpdateEventID

	ffjtMessageUpdateEventChannelID

	ffjtMessageUpdateEventGuildID

	ffjtMessageUpdateEventType

	ffjtMessageUpdateEventFlags

	ffjtMessageUpdateEventTTS

	ffjtMessageUpdateEventPinned

	ffjtMessageUpdateEventMentionEveryone

	ffjtMessageUpdateEventMentions

	ffjtMessageUpdateEventMentionRoleIDs

	ffjtMessageUpdateEventMentionChannels

	ffjtMessageUpdateEventAuthor

	ffjtMessageUpdateEventContent

	ffjtMessageUpdateEventTimestamp

	ffjtMessageUpdateEventEditedTimestamp

	ffjtMessageUpdateEventAttachments

	ffjtMessageUpdateEventEmbeds

	ffjtMessageUpdateEventReactions

	ffjtMessageUpdateEventComponents

	ffjtMessageUpdateEventNonce

	ffjtMessageUpdateEventWebhookID

	ffjtMessageUpdateEventActivity

	ffjtMessageUpdateEventApplication

	ffjtMessageUpdateEventApplicationID

	ffjtMessageUpdateEventReference

	ffjtMessageUpdateEventReferencedMessage

	ffjtMessageUpdateEventInteraction

	ffjtMessageUpdateEventStickers
)

var ffjKeyMessageUpdateEventMember = []byte("member")

var ffjKeyMessageUpdateEventID = []byte("id")

var ffjKeyMessageUpdateEventChannelID = []byte("channel_id")

var ffjKeyMessageUpdateEventGuildID = []byte("guild_id")

var ffjKeyMessageUpdateEventType = []byte("type")

var ffjKeyMessageUpdateEventFlags = []byte("flags")

var ffjKeyMessageUpdateEventTTS = []byte("tts")

var ffjKeyMessageUpdateEventPinned = []byte("pinned")

var ffjKeyMessageUpdateEventMentionEveryone = []byte("mention_everyone")

var ffjKeyMessageUpdateEventMentions = []byte("mentions")

var ffjKeyMessageUpdateEventMentionRoleIDs = []byte("mention_roles")

var ffjKeyMessageUpdateEventMentionChannels = []byte("mention_channels")

var ffjKeyMessageUpdateEventAuthor = []byte("author")

var ffjKeyMessageUpdateEventContent = []byte("content")

var ffjKeyMessageUpdateEventTimestamp = []byte("timestamp")

var ffjKeyMessageUpdateEventEditedTimestamp = []byte("edited_timestamp")

var ffjKeyMessageUpdateEventAttachments = []byte("attachments")

var ffjKeyMessageUpdateEventEmbeds = []byte("embeds")

var ffjKeyMessageUpdateEventReactions = []byte("reactions")

var ffjKeyMessageUpdateEventComponents = []byte("components")

var ffjKeyMessageUpdateEventNonce = []byte("nonce")

var ffjKeyMessageUpdateEventWebhookID = []byte("webhook_id")

var ffjKeyMessageUpdateEventActivity = []byte("activity")

var ffjKeyMessageUpdateEventApplication = []byte("application")

var ffjKeyMessageUpdateEventApplicationID = []byte("application_id")

var ffjKeyMessageUpdateEventReference = []byte("message_reference")

var ffjKeyMessageUpdateEventReferencedMessage = []byte("referenced_message")

var ffjKeyMessageUpdateEventInteraction = []byte("interaction")

var ffjKeyMessageUpdateEventStickers = []byte("sticker_items")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMessageUpdateEventAuthor, kn) {
						currentKey = ffjtMessageUpdateEventAuthor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventAttachments, kn) {
						currentKey = ffjtMessageUpdateEventAttachments
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventActivity, kn) {
						currentKey = ffjtMessageUpdateEventActivity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventApplication, kn) {
						currentKey = ffjtMessageUpdateEventApplication
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventApplicationID, kn) {
						currentKey = ffjtMessageUpdateEventApplicationID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMessageUpdateEventChannelID, kn) {
						currentKey = ffjtMessageUpdateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventContent, kn) {
						currentKey = ffjtMessageUpdateEventContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventComponents, kn) {
						currentKey = ffjtMessageUpdateEventComponents
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageUpdateEventEditedTimestamp, kn) {
						currentKey = ffjtMessageUpdateEventEditedTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventEmbeds, kn) {
						currentKey = ffjtMessageUpdateEventEmbeds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMessageUpdateEventFlags, kn) {
						currentKey = ffjtMessageUpdateEventFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageUpdateEventGuildID, kn) {
						currentKey = ffjtMessageUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyMessageUpdateEventID, kn) {
						currentKey = ffjtMessageUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventInteraction, kn) {
						currentKey = ffjtMessageUpdateEventInteraction
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageUpdateEventMember, kn) {
						currentKey = ffjtMessageUpdateEventMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventMentionEveryone, kn) {
						currentKey = ffjtMessageUpdateEventMentionEveryone
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventMentions, kn) {
						currentKey = ffjtMessageUpdateEventMentions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventMentionRoleIDs, kn) {
						currentKey = ffjtMessageUpdateEventMentionRoleIDs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventMentionChannels, kn) {
						currentKey = ffjtMessageUpdateEventMentionChannels
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventReference, kn) {
						currentKey = ffjtMessageUpdateEventReference
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMessageUpdateEventNonce, kn) {
						currentKey = ffjtMessageUpdateEventNonce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMessageUpdateEventPinned, kn) {
						currentKey = ffjtMessageUpdateEventPinned
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyMessageUpdateEventReactions, kn) {
						currentKey = ffjtMessageUpdateEventReactions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventReferencedMessage, kn) {
						currentKey = ffjtMessageUpdateEventReferencedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMessageUpdateEventStickers, kn) {
						currentKey = ffjtMessageUpdateEventStickers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageUpdateEventType, kn) {
						currentKey = ffjtMessageUpdateEventType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventTTS, kn) {
						currentKey = ffjtMessageUpdateEventTTS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUpdateEventTimestamp, kn) {
						currentKey = ffjtMessageUpdateEventTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyMessageUpdateEventWebhookID, kn) {
						currentKey = ffjtMessageUpdateEventWebhookID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventStickers, kn) {
					currentKey = ffjtMessageUpdateEventStickers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventInteraction, kn) {
					currentKey = ffjtMessageUpdateEventInteraction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventReferencedMessage, kn) {
					currentKey = ffjtMessageUpdateEventReferencedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventReference, kn) {
					currentKey = ffjtMessageUpdateEventReference
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageUpdateEventApplicationID, kn) {
					currentKey = ffjtMessageUpdateEventApplicationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventApplication, kn) {
					currentKey = ffjtMessageUpdateEventApplication
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventActivity, kn) {
					currentKey = ffjtMessageUpdateEventActivity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventWebhookID, kn) {
					currentKey = ffjtMessageUpdateEventWebhookID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventNonce, kn) {
					currentKey = ffjtMessageUpdateEventNonce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventComponents, kn) {
					currentKey = ffjtMessageUpdateEventComponents
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventReactions, kn) {
					currentKey = ffjtMessageUpdateEventReactions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventEmbeds, kn) {
					currentKey = ffjtMessageUpdateEventEmbeds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventAttachments, kn) {
					currentKey = ffjtMessageUpdateEventAttachments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventEditedTimestamp, kn) {
					currentKey = ffjtMessageUpdateEventEditedTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventTimestamp, kn) {
					currentKey = ffjtMessageUpdateEventTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventContent, kn) {
					currentKey = ffjtMessageUpdateEventContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventAuthor, kn) {
					currentKey = ffjtMessageUpdateEventAuthor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventMentionChannels, kn) {
					currentKey = ffjtMessageUpdateEventMentionChannels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventMentionRoleIDs, kn) {
					currentKey = ffjtMessageUpdateEventMentionRoleIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventMentions, kn) {
					currentKey = ffjtMessageUpdateEventMentions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageUpdateEventMentionEveryone, kn) {
					currentKey = ffjtMessageUpdateEventMentionEveryone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventPinned, kn) {
					currentKey = ffjtMessageUpdateEventPinned
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventTTS, kn) {
					currentKey = ffjtMessageUpdateEventTTS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUpdateEventFlags, kn) {
					currentKey = ffjtMessageUpdateEventFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventType, kn) {
					currentKey = ffjtMessageUpdateEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageUpdateEventGuildID, kn) {
					currentKey = ffjtMessageUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageUpdateEventChannelID, kn) {
					currentKey = ffjtMessageUpdateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventID, kn) {
					currentKey = ffjtMessageUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageUpdateEventMember, kn) {
					currentKey = ffjtMessageUpdateEventMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageUpdateEventMember:
					goto handle_Member

				case ffjtMessageUpdateEventID:
					goto handle_ID

				case ffjtMessageUpdateEventChannelID:
					goto handle_ChannelID

				case ffjtMessageUpdateEventGuildID:
					goto handle_GuildID

				case ffjtMessageUpdateEventType:
					goto handle_Type

				case ffjtMessageUpdateEventFlags:
					goto handle_Flags

				case ffjtMessageUpdateEventTTS:
					goto handle_TTS

				case ffjtMessageUpdateEventPinned:
					goto handle_Pinned

				case ffjtMessageUpdateEventMentionEveryone:
					goto handle_MentionEveryone

				case ffjtMessageUpdateEventMentions:
					goto handle_Mentions

				case ffjtMessageUpdateEventMentionRoleIDs:
					goto handle_MentionRoleIDs

				case ffjtMessageUpdateEventMentionChannels:
					goto handle_MentionChannels

				case ffjtMessageUpdateEventAuthor:
					goto handle_Author

				case ffjtMessageUpdateEventContent:
					goto handle_Content

				case ffjtMessageUpdateEventTimestamp:
					goto handle_Timestamp

				case ffjtMessageUpdateEventEditedTimestamp:
					goto handle_EditedTimestamp

				case ffjtMessageUpdateEventAttachments:
					goto handle_Attachments

				case ffjtMessageUpdateEventEmbeds:
					goto handle_Embeds

				case ffjtMessageUpdateEventReactions:
					goto handle_Reactions

				case ffjtMessageUpdateEventComponents:
					goto handle_Components

				case ffjtMessageUpdateEventNonce:
					goto handle_Nonce

				case ffjtMessageUpdateEventWebhookID:
					goto handle_WebhookID

				case ffjtMessageUpdateEventActivity:
					goto handle_Activity

				case ffjtMessageUpdateEventApplication:
					goto handle_Application

				case ffjtMessageUpdateEventApplicationID:
					goto handle_ApplicationID

				case ffjtMessageUpdateEventReference:
					goto handle_Reference

				case ffjtMessageUpdateEventReferencedMessage:
					goto handle_ReferencedMessage

				case ffjtMessageUpdateEventInteraction:
					goto handle_Interaction

				case ffjtMessageUpdateEventStickers:
					goto handle_Stickers

				case ffjtMessageUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Member:

	/* handler: j.Member type=discord.Member kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(discord.Member)
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=discord.MessageType kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MessageType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Type = discord.MessageType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flags:

	/* handler: j.Flags type=discord.MessageFlags kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MessageFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Flags = discord.MessageFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TTS:

	/* handler: j.TTS type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.TTS = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.TTS = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pinned:

	/* handler: j.Pinned type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Pinned = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Pinned = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionEveryone:

	/* handler: j.MentionEveryone type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MentionEveryone = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MentionEveryone = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mentions:

	/* handler: j.Mentions type=[]discord.GuildUser kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Mentions = nil
		} else {

			j.Mentions = []discord.GuildUser{}

			wantVal := true

			for {

				var tmpJMentions discord.GuildUser

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMentions type=discord.GuildUser kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMentions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Mentions = append(j.Mentions, tmpJMentions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionRoleIDs:

	/* handler: j.MentionRoleIDs type=[]discord.RoleID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.MentionRoleIDs = nil
		} else {

			j.MentionRoleIDs = []discord.RoleID{}

			wantVal := true

			for {

				var tmpJMentionRoleIDs discord.RoleID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMentionRoleIDs type=discord.RoleID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJMentionRoleIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.MentionRoleIDs = append(j.MentionRoleIDs, tmpJMentionRoleIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionChannels:

	/* handler: j.MentionChannels type=[]discord.ChannelMention kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.MentionChannels = nil
		} else {

			j.MentionChannels = []discord.ChannelMention{}

			wantVal := true

			for {

				var tmpJMentionChannels discord.ChannelMention

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMentionChannels type=discord.ChannelMention kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMentionChannels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.MentionChannels = append(j.MentionChannels, tmpJMentionChannels)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Author:

	/* handler: j.Author type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Author.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: j.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Timestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedTimestamp:

	/* handler: j.EditedTimestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EditedTimestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attachments:

	/* handler: j.Attachments type=[]discord.Attachment kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Attachments = nil
		} else {

			j.Attachments = []discord.Attachment{}

			wantVal := true

			for {

				var tmpJAttachments discord.Attachment

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAttachments type=discord.Attachment kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJAttachments.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Attachments = append(j.Attachments, tmpJAttachments)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Embeds:

	/* handler: j.Embeds type=[]discord.Embed kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Embeds = nil
		} else {

			j.Embeds = []discord.Embed{}

			wantVal := true

			for {

				var tmpJEmbeds discord.Embed

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEmbeds type=discord.Embed kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJEmbeds.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Embeds = append(j.Embeds, tmpJEmbeds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reactions:

	/* handler: j.Reactions type=[]discord.Reaction kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Reactions = nil
		} else {

			j.Reactions = []discord.Reaction{}

			wantVal := true

			for {

				var tmpJReactions discord.Reaction

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJReactions type=discord.Reaction kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJReactions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Reactions = append(j.Reactions, tmpJReactions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Components:

	/* handler: j.Components type=discord.ContainerComponents kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Components.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nonce:

	/* handler: j.Nonce type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nonce = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebhookID:

	/* handler: j.WebhookID type=discord.WebhookID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WebhookID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activity:

	/* handler: j.Activity type=discord.MessageActivity kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Activity = nil

		} else {

			if j.Activity == nil {
				j.Activity = new(discord.MessageActivity)
			}

			err = j.Activity.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Application:

	/* handler: j.Application type=discord.MessageApplication kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Application = nil

		} else {

			if j.Application == nil {
				j.Application = new(discord.MessageApplication)
			}

			err = j.Application.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ApplicationID:

	/* handler: j.ApplicationID type=discord.AppID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ApplicationID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reference:

	/* handler: j.Reference type=discord.MessageReference kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Reference = nil

		} else {

			if j.Reference == nil {
				j.Reference = new(discord.MessageReference)
			}

			err = j.Reference.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReferencedMessage:

	/* handler: j.ReferencedMessage type=discord.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReferencedMessage = nil

		} else {

			if j.ReferencedMessage == nil {
				j.ReferencedMessage = new(discord.Message)
			}

			err = j.ReferencedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Interaction:

	/* handler: j.Interaction type=discord.MessageInteraction kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Interaction = nil

		} else {

			if j.Interaction == nil {
				j.Interaction = new(discord.MessageInteraction)
			}

			err = j.Interaction.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stickers:

	/* handler: j.Stickers type=[]discord.StickerItem kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Stickers = nil
		} else {

			j.Stickers = []discord.StickerItem{}

			wantVal := true

			for {

				var tmpJStickers discord.StickerItem

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJStickers type=discord.StickerItem kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJStickers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Stickers = append(j.Stickers, tmpJStickers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PresenceUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PresenceUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteString(`,"activities":`)
	if j.Activities != nil {
		buf.WriteString(`[`)
		for i, v := range j.Activities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"client_status":`)

	{

		err = j.ClientStatus.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPresenceUpdateEventbase = iota
	ffjtPresenceUpdateEventnosuchkey

	ffjtPresenceUpdateEventUser

	ffjtPresenceUpdateEventGuildID

	ffjtPresenceUpdateEventStatus

	ffjtPresenceUpdateEventActivities

	ffjtPresenceUpdateEventClientStatus
)

var ffjKeyPresenceUpdateEventUser = []byte("user")

var ffjKeyPresenceUpdateEventGuildID = []byte("guild_id")

var ffjKeyPresenceUpdateEventStatus = []byte("status")

var ffjKeyPresenceUpdateEventActivities = []byte("activities")

var ffjKeyPresenceUpdateEventClientStatus = []byte("client_status")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PresenceUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PresenceUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPresenceUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPresenceUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyPresenceUpdateEventActivities, kn) {
						currentKey = ffjtPresenceUpdateEventActivities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPresenceUpdateEventClientStatus, kn) {
						currentKey = ffjtPresenceUpdateEventClientStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyPresenceUpdateEventGuildID, kn) {
						currentKey = ffjtPresenceUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPresenceUpdateEventStatus, kn) {
						currentKey = ffjtPresenceUpdateEventStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyPresenceUpdateEventUser, kn) {
						currentKey = ffjtPresenceUpdateEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPresenceUpdateEventClientStatus, kn) {
					currentKey = ffjtPresenceUpdateEventClientStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPresenceUpdateEventActivities, kn) {
					currentKey = ffjtPresenceUpdateEventActivities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPresenceUpdateEventStatus, kn) {
					currentKey = ffjtPresenceUpdateEventStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPresenceUpdateEventGuildID, kn) {
					currentKey = ffjtPresenceUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPresenceUpdateEventUser, kn) {
					currentKey = ffjtPresenceUpdateEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPresenceUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPresenceUpdateEventUser:
					goto handle_User

				case ffjtPresenceUpdateEventGuildID:
					goto handle_GuildID

				case ffjtPresenceUpdateEventStatus:
					goto handle_Status

				case ffjtPresenceUpdateEventActivities:
					goto handle_Activities

				case ffjtPresenceUpdateEventClientStatus:
					goto handle_ClientStatus

				case ffjtPresenceUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = discord.Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activities:

	/* handler: j.Activities type=[]discord.Activity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Activities = nil
		} else {

			j.Activities = []discord.Activity{}

			wantVal := true

			for {

				var tmpJActivities discord.Activity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActivities type=discord.Activity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJActivities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Activities = append(j.Activities, tmpJActivities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClientStatus:

	/* handler: j.ClientStatus type=discord.ClientStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.ClientStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReadState) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReadState) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"last_message_id":`)

	{

		obj, err = j.LastMessageID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"last_pin_timestamp":`)

	{

		obj, err = j.LastPinTimestamp.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"mention_count":`)
	fflib.FormatBits2(buf, uint64(j.MentionCount), 10, j.MentionCount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReadStatebase = iota
	ffjtReadStatenosuchkey

	ffjtReadStateChannelID

	ffjtReadStateLastMessageID

	ffjtReadStateLastPinTimestamp

	ffjtReadStateMentionCount
)

var ffjKeyReadStateChannelID = []byte("id")

var ffjKeyReadStateLastMessageID = []byte("last_message_id")

var ffjKeyReadStateLastPinTimestamp = []byte("last_pin_timestamp")

var ffjKeyReadStateMentionCount = []byte("mention_count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReadState) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReadState) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReadStatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReadStatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyReadStateChannelID, kn) {
						currentKey = ffjtReadStateChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyReadStateLastMessageID, kn) {
						currentKey = ffjtReadStateLastMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyReadStateLastPinTimestamp, kn) {
						currentKey = ffjtReadStateLastPinTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyReadStateMentionCount, kn) {
						currentKey = ffjtReadStateMentionCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyReadStateMentionCount, kn) {
					currentKey = ffjtReadStateMentionCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadStateLastPinTimestamp, kn) {
					currentKey = ffjtReadStateLastPinTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadStateLastMessageID, kn) {
					currentKey = ffjtReadStateLastMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyReadStateChannelID, kn) {
					currentKey = ffjtReadStateChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReadStatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReadStateChannelID:
					goto handle_ChannelID

				case ffjtReadStateLastMessageID:
					goto handle_LastMessageID

				case ffjtReadStateLastPinTimestamp:
					goto handle_LastPinTimestamp

				case ffjtReadStateMentionCount:
					goto handle_MentionCount

				case ffjtReadStatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastMessageID:

	/* handler: j.LastMessageID type=discord.MessageID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LastMessageID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastPinTimestamp:

	/* handler: j.LastPinTimestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LastPinTimestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MentionCount:

	/* handler: j.MentionCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MentionCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReadyEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReadyEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"v":`)
	fflib.FormatBits2(buf, uint64(j.Version), 10, j.Version < 0)
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"session_id":`)
	fflib.WriteJsonString(buf, string(j.SessionID))
	buf.WriteString(`,"private_channels":`)
	if j.PrivateChannels != nil {
		buf.WriteString(`[`)
		for i, v := range j.PrivateChannels {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"guilds":`)
	if j.Guilds != nil {
		buf.WriteString(`[`)
		for i, v := range j.Guilds {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.Shard != nil {
		if true {
			buf.WriteString(`"shard":`)
			buf.WriteString(`[`)
			for i, v := range *j.Shard {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.FormatBits2(buf, uint64(v), 10, v < 0)
			}
			buf.WriteString(`]`)
			buf.WriteByte(',')
		}
	}
	/* Inline struct. type=struct { ID discord.AppID "json:\"id\""; Flags discord.ApplicationFlags "json:\"flags\"" } kind=struct */
	buf.WriteString(`"application":{ "id":`)

	{

		obj, err = j.Application.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"flags":`)
	fflib.FormatBits2(buf, uint64(j.Application.Flags), 10, false)
	buf.WriteByte('}')
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReadyEventExtras) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReadyEventExtras) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if j.UserSettings != nil {
		if true {
			buf.WriteString(`"user_settings":`)

			{

				err = j.UserSettings.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.ReadStates) != 0 {
		buf.WriteString(`"read_state":`)
		if j.ReadStates != nil {
			buf.WriteString(`[`)
			for i, v := range j.ReadStates {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.UserGuildSettings) != 0 {
		buf.WriteString(`"user_guild_settings":`)
		if j.UserGuildSettings != nil {
			buf.WriteString(`[`)
			for i, v := range j.UserGuildSettings {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Relationships) != 0 {
		buf.WriteString(`"relationships":`)
		if j.Relationships != nil {
			buf.WriteString(`[`)
			for i, v := range j.Relationships {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Presences) != 0 {
		buf.WriteString(`"presences":`)
		if j.Presences != nil {
			buf.WriteString(`[`)
			for i, v := range j.Presences {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Sessions) != 0 {
		buf.WriteString(`"sessions":`)
		if j.Sessions != nil {
			buf.WriteString(`[`)
			for i, v := range j.Sessions {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.SessionID) != 0 {
		buf.WriteString(`"session_id":`)
		fflib.WriteJsonString(buf, string(j.SessionID))
		buf.WriteByte(',')
	}
	if j.FriendSuggestionCount != 0 {
		buf.WriteString(`"friend_suggestion_count":`)
		fflib.FormatBits2(buf, uint64(j.FriendSuggestionCount), 10, j.FriendSuggestionCount < 0)
		buf.WriteByte(',')
	}
	if len(j.GeoOrderedRTCRegions) != 0 {
		buf.WriteString(`"geo_ordered_rtc_regions":`)
		if j.GeoOrderedRTCRegions != nil {
			buf.WriteString(`[`)
			for i, v := range j.GeoOrderedRTCRegions {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"RawEventBody":`)

	{

		obj, err = j.RawEventBody.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"ExtrasDecodeErrors":`)
	if j.ExtrasDecodeErrors != nil {
		buf.WriteString(`[`)
		for i, v := range j.ExtrasDecodeErrors {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Interface types must use runtime reflection. type=error kind=interface */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReadyEventExtrasbase = iota
	ffjtReadyEventExtrasnosuchkey

	ffjtReadyEventExtrasUserSettings

	ffjtReadyEventExtrasReadStates

	ffjtReadyEventExtrasUserGuildSettings

	ffjtReadyEventExtrasRelationships

	ffjtReadyEventExtrasPresences

	ffjtReadyEventExtrasSessions

	ffjtReadyEventExtrasSessionID

	ffjtReadyEventExtrasFriendSuggestionCount

	ffjtReadyEventExtrasGeoOrderedRTCRegions

	ffjtReadyEventExtrasRawEventBody

	ffjtReadyEventExtrasExtrasDecodeErrors
)

var ffjKeyReadyEventExtrasUserSettings = []byte("user_settings")

var ffjKeyReadyEventExtrasReadStates = []byte("read_state")

var ffjKeyReadyEventExtrasUserGuildSettings = []byte("user_guild_settings")

var ffjKeyReadyEventExtrasRelationships = []byte("relationships")

var ffjKeyReadyEventExtrasPresences = []byte("presences")

var ffjKeyReadyEventExtrasSessions = []byte("sessions")

var ffjKeyReadyEventExtrasSessionID = []byte("session_id")

var ffjKeyReadyEventExtrasFriendSuggestionCount = []byte("friend_suggestion_count")

var ffjKeyReadyEventExtrasGeoOrderedRTCRegions = []byte("geo_ordered_rtc_regions")

var ffjKeyReadyEventExtrasRawEventBody = []byte("RawEventBody")

var ffjKeyReadyEventExtrasExtrasDecodeErrors = []byte("ExtrasDecodeErrors")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReadyEventExtras) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReadyEventExtras) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReadyEventExtrasbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReadyEventExtrasnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffjKeyReadyEventExtrasExtrasDecodeErrors, kn) {
						currentKey = ffjtReadyEventExtrasExtrasDecodeErrors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffjKeyReadyEventExtrasRawEventBody, kn) {
						currentKey = ffjtReadyEventExtrasRawEventBody
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyReadyEventExtrasFriendSuggestionCount, kn) {
						currentKey = ffjtReadyEventExtrasFriendSuggestionCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyReadyEventExtrasGeoOrderedRTCRegions, kn) {
						currentKey = ffjtReadyEventExtrasGeoOrderedRTCRegions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyReadyEventExtrasPresences, kn) {
						currentKey = ffjtReadyEventExtrasPresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyReadyEventExtrasReadStates, kn) {
						currentKey = ffjtReadyEventExtrasReadStates
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyReadyEventExtrasRelationships, kn) {
						currentKey = ffjtReadyEventExtrasRelationships
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyReadyEventExtrasSessions, kn) {
						currentKey = ffjtReadyEventExtrasSessions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyReadyEventExtrasSessionID, kn) {
						currentKey = ffjtReadyEventExtrasSessionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyReadyEventExtrasUserSettings, kn) {
						currentKey = ffjtReadyEventExtrasUserSettings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyReadyEventExtrasUserGuildSettings, kn) {
						currentKey = ffjtReadyEventExtrasUserGuildSettings
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasExtrasDecodeErrors, kn) {
					currentKey = ffjtReadyEventExtrasExtrasDecodeErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyReadyEventExtrasRawEventBody, kn) {
					currentKey = ffjtReadyEventExtrasRawEventBody
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasGeoOrderedRTCRegions, kn) {
					currentKey = ffjtReadyEventExtrasGeoOrderedRTCRegions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasFriendSuggestionCount, kn) {
					currentKey = ffjtReadyEventExtrasFriendSuggestionCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasSessionID, kn) {
					currentKey = ffjtReadyEventExtrasSessionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasSessions, kn) {
					currentKey = ffjtReadyEventExtrasSessions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasPresences, kn) {
					currentKey = ffjtReadyEventExtrasPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasRelationships, kn) {
					currentKey = ffjtReadyEventExtrasRelationships
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasUserGuildSettings, kn) {
					currentKey = ffjtReadyEventExtrasUserGuildSettings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasReadStates, kn) {
					currentKey = ffjtReadyEventExtrasReadStates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadyEventExtrasUserSettings, kn) {
					currentKey = ffjtReadyEventExtrasUserSettings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReadyEventExtrasnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReadyEventExtrasUserSettings:
					goto handle_UserSettings

				case ffjtReadyEventExtrasReadStates:
					goto handle_ReadStates

				case ffjtReadyEventExtrasUserGuildSettings:
					goto handle_UserGuildSettings

				case ffjtReadyEventExtrasRelationships:
					goto handle_Relationships

				case ffjtReadyEventExtrasPresences:
					goto handle_Presences

				case ffjtReadyEventExtrasSessions:
					goto handle_Sessions

				case ffjtReadyEventExtrasSessionID:
					goto handle_SessionID

				case ffjtReadyEventExtrasFriendSuggestionCount:
					goto handle_FriendSuggestionCount

				case ffjtReadyEventExtrasGeoOrderedRTCRegions:
					goto handle_GeoOrderedRTCRegions

				case ffjtReadyEventExtrasRawEventBody:
					goto handle_RawEventBody

				case ffjtReadyEventExtrasExtrasDecodeErrors:
					goto handle_ExtrasDecodeErrors

				case ffjtReadyEventExtrasnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserSettings:

	/* handler: j.UserSettings type=gateway.UserSettings kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.UserSettings = nil

		} else {

			if j.UserSettings == nil {
				j.UserSettings = new(UserSettings)
			}

			err = j.UserSettings.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadStates:

	/* handler: j.ReadStates type=[]gateway.ReadState kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ReadStates = nil
		} else {

			j.ReadStates = []ReadState{}

			wantVal := true

			for {

				var tmpJReadStates ReadState

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJReadStates type=gateway.ReadState kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJReadStates.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ReadStates = append(j.ReadStates, tmpJReadStates)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserGuildSettings:

	/* handler: j.UserGuildSettings type=[]gateway.UserGuildSetting kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.UserGuildSettings = nil
		} else {

			j.UserGuildSettings = []UserGuildSetting{}

			wantVal := true

			for {

				var tmpJUserGuildSettings UserGuildSetting

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJUserGuildSettings type=gateway.UserGuildSetting kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJUserGuildSettings.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.UserGuildSettings = append(j.UserGuildSettings, tmpJUserGuildSettings)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Relationships:

	/* handler: j.Relationships type=[]discord.Relationship kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Relationships = nil
		} else {

			j.Relationships = []discord.Relationship{}

			wantVal := true

			for {

				var tmpJRelationships discord.Relationship

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRelationships type=discord.Relationship kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJRelationships.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Relationships = append(j.Relationships, tmpJRelationships)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Presences:

	/* handler: j.Presences type=[]discord.Presence kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Presences = nil
		} else {

			j.Presences = []discord.Presence{}

			wantVal := true

			for {

				var tmpJPresences discord.Presence

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPresences type=discord.Presence kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPresences.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Presences = append(j.Presences, tmpJPresences)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sessions:

	/* handler: j.Sessions type=[]gateway.UserSession kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Sessions = nil
		} else {

			j.Sessions = []UserSession{}

			wantVal := true

			for {

				var tmpJSessions UserSession

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSessions type=gateway.UserSession kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJSessions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Sessions = append(j.Sessions, tmpJSessions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SessionID:

	/* handler: j.SessionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SessionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FriendSuggestionCount:

	/* handler: j.FriendSuggestionCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FriendSuggestionCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GeoOrderedRTCRegions:

	/* handler: j.GeoOrderedRTCRegions type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GeoOrderedRTCRegions = nil
		} else {

			j.GeoOrderedRTCRegions = []string{}

			wantVal := true

			for {

				var tmpJGeoOrderedRTCRegions string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGeoOrderedRTCRegions type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJGeoOrderedRTCRegions = string(string(outBuf))

					}
				}

				j.GeoOrderedRTCRegions = append(j.GeoOrderedRTCRegions, tmpJGeoOrderedRTCRegions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RawEventBody:

	/* handler: j.RawEventBody type=json.Raw kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.RawEventBody.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExtrasDecodeErrors:

	/* handler: j.ExtrasDecodeErrors type=[]error kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ExtrasDecodeErrors = nil
		} else {

			j.ExtrasDecodeErrors = []error{}

			wantVal := true

			for {

				var tmpJExtrasDecodeErrors error

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJExtrasDecodeErrors type=error kind=interface quoted=false*/

				{
					/* Falling back. type=error kind=interface */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJExtrasDecodeErrors)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.ExtrasDecodeErrors = append(j.ExtrasDecodeErrors, tmpJExtrasDecodeErrors)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReadySupplementalEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReadySupplementalEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guilds":`)
	if j.Guilds != nil {
		buf.WriteString(`[`)
		for i, v := range j.Guilds {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"merged_members":`)
	if j.MergedMembers != nil {
		buf.WriteString(`[`)
		for i, v := range j.MergedMembers {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"merged_presences":`)

	{

		err = j.MergedPresences.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReadySupplementalEventbase = iota
	ffjtReadySupplementalEventnosuchkey

	ffjtReadySupplementalEventGuilds

	ffjtReadySupplementalEventMergedMembers

	ffjtReadySupplementalEventMergedPresences
)

var ffjKeyReadySupplementalEventGuilds = []byte("guilds")

var ffjKeyReadySupplementalEventMergedMembers = []byte("merged_members")

var ffjKeyReadySupplementalEventMergedPresences = []byte("merged_presences")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReadySupplementalEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReadySupplementalEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReadySupplementalEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReadySupplementalEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyReadySupplementalEventGuilds, kn) {
						currentKey = ffjtReadySupplementalEventGuilds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyReadySupplementalEventMergedMembers, kn) {
						currentKey = ffjtReadySupplementalEventMergedMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyReadySupplementalEventMergedPresences, kn) {
						currentKey = ffjtReadySupplementalEventMergedPresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyReadySupplementalEventMergedPresences, kn) {
					currentKey = ffjtReadySupplementalEventMergedPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadySupplementalEventMergedMembers, kn) {
					currentKey = ffjtReadySupplementalEventMergedMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReadySupplementalEventGuilds, kn) {
					currentKey = ffjtReadySupplementalEventGuilds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReadySupplementalEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReadySupplementalEventGuilds:
					goto handle_Guilds

				case ffjtReadySupplementalEventMergedMembers:
					goto handle_MergedMembers

				case ffjtReadySupplementalEventMergedPresences:
					goto handle_MergedPresences

				case ffjtReadySupplementalEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Guilds:

	/* handler: j.Guilds type=[]gateway.GuildCreateEvent kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Guilds = nil
		} else {

			j.Guilds = []GuildCreateEvent{}

			wantVal := true

			for {

				var tmpJGuilds GuildCreateEvent

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuilds type=gateway.GuildCreateEvent kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJGuilds.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Guilds = append(j.Guilds, tmpJGuilds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MergedMembers:

	/* handler: j.MergedMembers type=[][]gateway.SupplementalMember kind=slice quoted=false*/

	{
		/* Falling back. type=[][]gateway.SupplementalMember kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.MergedMembers)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MergedPresences:

	/* handler: j.MergedPresences type=gateway.MergedPresences kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.MergedPresences.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReconnectEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReconnectEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtReconnectEventbase = iota
	ffjtReconnectEventnosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReconnectEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReconnectEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReconnectEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReconnectEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtReconnectEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReconnectEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *RelationshipAddEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *RelationshipAddEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"type":`)
	fflib.FormatBits2(buf, uint64(j.Type), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtRelationshipAddEventbase = iota
	ffjtRelationshipAddEventnosuchkey

	ffjtRelationshipAddEventUserID

	ffjtRelationshipAddEventUser

	ffjtRelationshipAddEventType
)

var ffjKeyRelationshipAddEventUserID = []byte("id")

var ffjKeyRelationshipAddEventUser = []byte("user")

var ffjKeyRelationshipAddEventType = []byte("type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *RelationshipAddEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *RelationshipAddEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtRelationshipAddEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtRelationshipAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyRelationshipAddEventUserID, kn) {
						currentKey = ffjtRelationshipAddEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyRelationshipAddEventType, kn) {
						currentKey = ffjtRelationshipAddEventType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyRelationshipAddEventUser, kn) {
						currentKey = ffjtRelationshipAddEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyRelationshipAddEventType, kn) {
					currentKey = ffjtRelationshipAddEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRelationshipAddEventUser, kn) {
					currentKey = ffjtRelationshipAddEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRelationshipAddEventUserID, kn) {
					currentKey = ffjtRelationshipAddEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtRelationshipAddEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtRelationshipAddEventUserID:
					goto handle_UserID

				case ffjtRelationshipAddEventUser:
					goto handle_User

				case ffjtRelationshipAddEventType:
					goto handle_Type

				case ffjtRelationshipAddEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=discord.RelationshipType kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for RelationshipType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Type = discord.RelationshipType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *RelationshipRemoveEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *RelationshipRemoveEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user":`)

	{

		err = j.User.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"type":`)
	fflib.FormatBits2(buf, uint64(j.Type), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtRelationshipRemoveEventbase = iota
	ffjtRelationshipRemoveEventnosuchkey

	ffjtRelationshipRemoveEventUserID

	ffjtRelationshipRemoveEventUser

	ffjtRelationshipRemoveEventType
)

var ffjKeyRelationshipRemoveEventUserID = []byte("id")

var ffjKeyRelationshipRemoveEventUser = []byte("user")

var ffjKeyRelationshipRemoveEventType = []byte("type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *RelationshipRemoveEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *RelationshipRemoveEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtRelationshipRemoveEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtRelationshipRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyRelationshipRemoveEventUserID, kn) {
						currentKey = ffjtRelationshipRemoveEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyRelationshipRemoveEventType, kn) {
						currentKey = ffjtRelationshipRemoveEventType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyRelationshipRemoveEventUser, kn) {
						currentKey = ffjtRelationshipRemoveEventUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyRelationshipRemoveEventType, kn) {
					currentKey = ffjtRelationshipRemoveEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRelationshipRemoveEventUser, kn) {
					currentKey = ffjtRelationshipRemoveEventUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRelationshipRemoveEventUserID, kn) {
					currentKey = ffjtRelationshipRemoveEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtRelationshipRemoveEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtRelationshipRemoveEventUserID:
					goto handle_UserID

				case ffjtRelationshipRemoveEventUser:
					goto handle_User

				case ffjtRelationshipRemoveEventType:
					goto handle_Type

				case ffjtRelationshipRemoveEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=discord.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=discord.RelationshipType kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for RelationshipType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Type = discord.RelationshipType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

const (
	ffjtRequestGuildMembersCommandbase = iota
	ffjtRequestGuildMembersCommandnosuchkey

	ffjtRequestGuildMembersCommandGuildIDs

	ffjtRequestGuildMembersCommandUserIDs

	ffjtRequestGuildMembersCommandQuery

	ffjtRequestGuildMembersCommandLimit

	ffjtRequestGuildMembersCommandPresences

	ffjtRequestGuildMembersCommandNonce
)

var ffjKeyRequestGuildMembersCommandGuildIDs = []byte("guild_id")

var ffjKeyRequestGuildMembersCommandUserIDs = []byte("user_ids")

var ffjKeyRequestGuildMembersCommandQuery = []byte("query")

var ffjKeyRequestGuildMembersCommandLimit = []byte("limit")

var ffjKeyRequestGuildMembersCommandPresences = []byte("presences")

var ffjKeyRequestGuildMembersCommandNonce = []byte("nonce")

// UnmarshalJSON umarshall json - template of ffjson
func (j *RequestGuildMembersCommand) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *RequestGuildMembersCommand) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtRequestGuildMembersCommandbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtRequestGuildMembersCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyRequestGuildMembersCommandGuildIDs, kn) {
						currentKey = ffjtRequestGuildMembersCommandGuildIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyRequestGuildMembersCommandLimit, kn) {
						currentKey = ffjtRequestGuildMembersCommandLimit
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyRequestGuildMembersCommandNonce, kn) {
						currentKey = ffjtRequestGuildMembersCommandNonce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyRequestGuildMembersCommandPresences, kn) {
						currentKey = ffjtRequestGuildMembersCommandPresences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyRequestGuildMembersCommandQuery, kn) {
						currentKey = ffjtRequestGuildMembersCommandQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyRequestGuildMembersCommandUserIDs, kn) {
						currentKey = ffjtRequestGuildMembersCommandUserIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyRequestGuildMembersCommandNonce, kn) {
					currentKey = ffjtRequestGuildMembersCommandNonce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRequestGuildMembersCommandPresences, kn) {
					currentKey = ffjtRequestGuildMembersCommandPresences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRequestGuildMembersCommandLimit, kn) {
					currentKey = ffjtRequestGuildMembersCommandLimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRequestGuildMembersCommandQuery, kn) {
					currentKey = ffjtRequestGuildMembersCommandQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRequestGuildMembersCommandUserIDs, kn) {
					currentKey = ffjtRequestGuildMembersCommandUserIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRequestGuildMembersCommandGuildIDs, kn) {
					currentKey = ffjtRequestGuildMembersCommandGuildIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtRequestGuildMembersCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtRequestGuildMembersCommandGuildIDs:
					goto handle_GuildIDs

				case ffjtRequestGuildMembersCommandUserIDs:
					goto handle_UserIDs

				case ffjtRequestGuildMembersCommandQuery:
					goto handle_Query

				case ffjtRequestGuildMembersCommandLimit:
					goto handle_Limit

				case ffjtRequestGuildMembersCommandPresences:
					goto handle_Presences

				case ffjtRequestGuildMembersCommandNonce:
					goto handle_Nonce

				case ffjtRequestGuildMembersCommandnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildIDs:

	/* handler: j.GuildIDs type=[]discord.GuildID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GuildIDs = nil
		} else {

			j.GuildIDs = []discord.GuildID{}

			wantVal := true

			for {

				var tmpJGuildIDs discord.GuildID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuildIDs type=discord.GuildID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJGuildIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.GuildIDs = append(j.GuildIDs, tmpJGuildIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserIDs:

	/* handler: j.UserIDs type=[]discord.UserID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.UserIDs = nil
		} else {

			j.UserIDs = []discord.UserID{}

			wantVal := true

			for {

				var tmpJUserIDs discord.UserID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJUserIDs type=discord.UserID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJUserIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.UserIDs = append(j.UserIDs, tmpJUserIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: j.Query type=option.String kind=ptr quoted=false*/

	{

		if tok == fflib.FFTok_null {
			j.Query = nil
		} else {
			if j.Query == nil {
				j.Query = new(string)
			}

			/* handler: j.Query type=string kind=string quoted=false*/

			{

				{
					if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
					}
				}

				if tok == fflib.FFTok_null {

					j.Query = nil

				} else {

					var tval string
					outBuf := fs.Output.Bytes()

					tval = string(string(outBuf))
					j.Query = &tval

				}
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Limit:

	/* handler: j.Limit type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Limit = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Presences:

	/* handler: j.Presences type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Presences = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Presences = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nonce:

	/* handler: j.Nonce type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nonce = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResumeCommand) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResumeCommand) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"token":`)
	fflib.WriteJsonString(buf, string(j.Token))
	buf.WriteString(`,"session_id":`)
	fflib.WriteJsonString(buf, string(j.SessionID))
	buf.WriteString(`,"seq":`)
	fflib.FormatBits2(buf, uint64(j.Sequence), 10, j.Sequence < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResumeCommandbase = iota
	ffjtResumeCommandnosuchkey

	ffjtResumeCommandToken

	ffjtResumeCommandSessionID

	ffjtResumeCommandSequence
)

var ffjKeyResumeCommandToken = []byte("token")

var ffjKeyResumeCommandSessionID = []byte("session_id")

var ffjKeyResumeCommandSequence = []byte("seq")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResumeCommand) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResumeCommand) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResumeCommandbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResumeCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffjKeyResumeCommandSessionID, kn) {
						currentKey = ffjtResumeCommandSessionID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyResumeCommandSequence, kn) {
						currentKey = ffjtResumeCommandSequence
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyResumeCommandToken, kn) {
						currentKey = ffjtResumeCommandToken
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyResumeCommandSequence, kn) {
					currentKey = ffjtResumeCommandSequence
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResumeCommandSessionID, kn) {
					currentKey = ffjtResumeCommandSessionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResumeCommandToken, kn) {
					currentKey = ffjtResumeCommandToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResumeCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResumeCommandToken:
					goto handle_Token

				case ffjtResumeCommandSessionID:
					goto handle_SessionID

				case ffjtResumeCommandSequence:
					goto handle_Sequence

				case ffjtResumeCommandnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Token:

	/* handler: j.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Token = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SessionID:

	/* handler: j.SessionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SessionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sequence:

	/* handler: j.Sequence type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Sequence = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResumedEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResumedEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtResumedEventbase = iota
	ffjtResumedEventnosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResumedEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResumedEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResumedEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResumedEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtResumedEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResumedEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SupplementalMember) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SupplementalMember) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if len(j.Nick) != 0 {
		buf.WriteString(`"nick":`)
		fflib.WriteJsonString(buf, string(j.Nick))
		buf.WriteByte(',')
	}
	buf.WriteString(`"roles":`)
	if j.RoleIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.RoleIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.IsPending != false {
		if j.IsPending {
			buf.WriteString(`"pending":true`)
		} else {
			buf.WriteString(`"pending":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"hoisted_role":`)

	{

		obj, err = j.HoistedRole.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Mute {
		buf.WriteString(`,"mute":true`)
	} else {
		buf.WriteString(`,"mute":false`)
	}
	if j.Deaf {
		buf.WriteString(`,"deaf":true`)
	} else {
		buf.WriteString(`,"deaf":false`)
	}
	buf.WriteString(`,"joined_at":`)

	{

		obj, err = j.Joined.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"premium_since":`)

		{

			obj, err = j.BoostedSince.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSupplementalMemberbase = iota
	ffjtSupplementalMembernosuchkey

	ffjtSupplementalMemberUserID

	ffjtSupplementalMemberNick

	ffjtSupplementalMemberRoleIDs

	ffjtSupplementalMemberGuildID

	ffjtSupplementalMemberIsPending

	ffjtSupplementalMemberHoistedRole

	ffjtSupplementalMemberMute

	ffjtSupplementalMemberDeaf

	ffjtSupplementalMemberJoined

	ffjtSupplementalMemberBoostedSince
)

var ffjKeySupplementalMemberUserID = []byte("user_id")

var ffjKeySupplementalMemberNick = []byte("nick")

var ffjKeySupplementalMemberRoleIDs = []byte("roles")

var ffjKeySupplementalMemberGuildID = []byte("guild_id")

var ffjKeySupplementalMemberIsPending = []byte("pending")

var ffjKeySupplementalMemberHoistedRole = []byte("hoisted_role")

var ffjKeySupplementalMemberMute = []byte("mute")

var ffjKeySupplementalMemberDeaf = []byte("deaf")

var ffjKeySupplementalMemberJoined = []byte("joined_at")

var ffjKeySupplementalMemberBoostedSince = []byte("premium_since")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SupplementalMember) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SupplementalMember) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSupplementalMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSupplementalMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeySupplementalMemberDeaf, kn) {
						currentKey = ffjtSupplementalMemberDeaf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeySupplementalMemberGuildID, kn) {
						currentKey = ffjtSupplementalMemberGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeySupplementalMemberHoistedRole, kn) {
						currentKey = ffjtSupplementalMemberHoistedRole
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffjKeySupplementalMemberJoined, kn) {
						currentKey = ffjtSupplementalMemberJoined
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeySupplementalMemberMute, kn) {
						currentKey = ffjtSupplementalMemberMute
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeySupplementalMemberNick, kn) {
						currentKey = ffjtSupplementalMemberNick
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySupplementalMemberIsPending, kn) {
						currentKey = ffjtSupplementalMemberIsPending
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySupplementalMemberBoostedSince, kn) {
						currentKey = ffjtSupplementalMemberBoostedSince
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySupplementalMemberRoleIDs, kn) {
						currentKey = ffjtSupplementalMemberRoleIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeySupplementalMemberUserID, kn) {
						currentKey = ffjtSupplementalMemberUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySupplementalMemberBoostedSince, kn) {
					currentKey = ffjtSupplementalMemberBoostedSince
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySupplementalMemberJoined, kn) {
					currentKey = ffjtSupplementalMemberJoined
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySupplementalMemberDeaf, kn) {
					currentKey = ffjtSupplementalMemberDeaf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySupplementalMemberMute, kn) {
					currentKey = ffjtSupplementalMemberMute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalMemberHoistedRole, kn) {
					currentKey = ffjtSupplementalMemberHoistedRole
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySupplementalMemberIsPending, kn) {
					currentKey = ffjtSupplementalMemberIsPending
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySupplementalMemberGuildID, kn) {
					currentKey = ffjtSupplementalMemberGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalMemberRoleIDs, kn) {
					currentKey = ffjtSupplementalMemberRoleIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalMemberNick, kn) {
					currentKey = ffjtSupplementalMemberNick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalMemberUserID, kn) {
					currentKey = ffjtSupplementalMemberUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSupplementalMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSupplementalMemberUserID:
					goto handle_UserID

				case ffjtSupplementalMemberNick:
					goto handle_Nick

				case ffjtSupplementalMemberRoleIDs:
					goto handle_RoleIDs

				case ffjtSupplementalMemberGuildID:
					goto handle_GuildID

				case ffjtSupplementalMemberIsPending:
					goto handle_IsPending

				case ffjtSupplementalMemberHoistedRole:
					goto handle_HoistedRole

				case ffjtSupplementalMemberMute:
					goto handle_Mute

				case ffjtSupplementalMemberDeaf:
					goto handle_Deaf

				case ffjtSupplementalMemberJoined:
					goto handle_Joined

				case ffjtSupplementalMemberBoostedSince:
					goto handle_BoostedSince

				case ffjtSupplementalMembernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nick:

	/* handler: j.Nick type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nick = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RoleIDs:

	/* handler: j.RoleIDs type=[]discord.RoleID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RoleIDs = nil
		} else {

			j.RoleIDs = []discord.RoleID{}

			wantVal := true

			for {

				var tmpJRoleIDs discord.RoleID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoleIDs type=discord.RoleID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRoleIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RoleIDs = append(j.RoleIDs, tmpJRoleIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPending:

	/* handler: j.IsPending type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsPending = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsPending = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HoistedRole:

	/* handler: j.HoistedRole type=discord.RoleID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.HoistedRole.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mute:

	/* handler: j.Mute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deaf:

	/* handler: j.Deaf type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Deaf = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Deaf = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Joined:

	/* handler: j.Joined type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Joined.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BoostedSince:

	/* handler: j.BoostedSince type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BoostedSince.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SupplementalPresence) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SupplementalPresence) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteString(`,"activities":`)
	if j.Activities != nil {
		buf.WriteString(`[`)
		for i, v := range j.Activities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"client_status":`)

	{

		err = j.ClientStatus.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if j.LastModified != 0 {
		buf.WriteString(`"last_modified":`)
		fflib.FormatBits2(buf, uint64(j.LastModified), 10, j.LastModified < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSupplementalPresencebase = iota
	ffjtSupplementalPresencenosuchkey

	ffjtSupplementalPresenceUserID

	ffjtSupplementalPresenceStatus

	ffjtSupplementalPresenceActivities

	ffjtSupplementalPresenceClientStatus

	ffjtSupplementalPresenceLastModified
)

var ffjKeySupplementalPresenceUserID = []byte("user_id")

var ffjKeySupplementalPresenceStatus = []byte("status")

var ffjKeySupplementalPresenceActivities = []byte("activities")

var ffjKeySupplementalPresenceClientStatus = []byte("client_status")

var ffjKeySupplementalPresenceLastModified = []byte("last_modified")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SupplementalPresence) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SupplementalPresence) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSupplementalPresencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSupplementalPresencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySupplementalPresenceActivities, kn) {
						currentKey = ffjtSupplementalPresenceActivities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeySupplementalPresenceClientStatus, kn) {
						currentKey = ffjtSupplementalPresenceClientStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeySupplementalPresenceLastModified, kn) {
						currentKey = ffjtSupplementalPresenceLastModified
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeySupplementalPresenceStatus, kn) {
						currentKey = ffjtSupplementalPresenceStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeySupplementalPresenceUserID, kn) {
						currentKey = ffjtSupplementalPresenceUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySupplementalPresenceLastModified, kn) {
					currentKey = ffjtSupplementalPresenceLastModified
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalPresenceClientStatus, kn) {
					currentKey = ffjtSupplementalPresenceClientStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalPresenceActivities, kn) {
					currentKey = ffjtSupplementalPresenceActivities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalPresenceStatus, kn) {
					currentKey = ffjtSupplementalPresenceStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySupplementalPresenceUserID, kn) {
					currentKey = ffjtSupplementalPresenceUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSupplementalPresencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSupplementalPresenceUserID:
					goto handle_UserID

				case ffjtSupplementalPresenceStatus:
					goto handle_Status

				case ffjtSupplementalPresenceActivities:
					goto handle_Activities

				case ffjtSupplementalPresenceClientStatus:
					goto handle_ClientStatus

				case ffjtSupplementalPresenceLastModified:
					goto handle_LastModified

				case ffjtSupplementalPresencenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = discord.Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activities:

	/* handler: j.Activities type=[]discord.Activity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Activities = nil
		} else {

			j.Activities = []discord.Activity{}

			wantVal := true

			for {

				var tmpJActivities discord.Activity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActivities type=discord.Activity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJActivities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Activities = append(j.Activities, tmpJActivities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClientStatus:

	/* handler: j.ClientStatus type=discord.ClientStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.ClientStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModified:

	/* handler: j.LastModified type=discord.UnixMsTimestamp kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UnixMsTimestamp", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LastModified = discord.UnixMsTimestamp(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ThreadCreateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ThreadCreateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Type != 0 {
		buf.WriteString(`"type":`)
		fflib.FormatBits2(buf, uint64(j.Type), 10, false)
		buf.WriteByte(',')
	}
	if j.NSFW != false {
		if j.NSFW {
			buf.WriteString(`"nsfw":true`)
		} else {
			buf.WriteString(`"nsfw":false`)
		}
		buf.WriteByte(',')
	}
	if j.Position != 0 {
		buf.WriteString(`"position":`)
		fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
		buf.WriteByte(',')
	}
	if len(j.Overwrites) != 0 {
		buf.WriteString(`"permission_overwrites":`)
		if j.Overwrites != nil {
			buf.WriteString(`[`)
			for i, v := range j.Overwrites {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Topic) != 0 {
		buf.WriteString(`"topic":`)
		fflib.WriteJsonString(buf, string(j.Topic))
		buf.WriteByte(',')
	}
	if j.LastMessageID != 0 {
		buf.WriteString(`"last_message_id":`)

		{

			obj, err = j.LastMessageID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.VoiceBitrate != 0 {
		buf.WriteString(`"bitrate":`)
		fflib.FormatBits2(buf, uint64(j.VoiceBitrate), 10, false)
		buf.WriteByte(',')
	}
	if j.VoiceUserLimit != 0 {
		buf.WriteString(`"user_limit":`)
		fflib.FormatBits2(buf, uint64(j.VoiceUserLimit), 10, false)
		buf.WriteByte(',')
	}
	if j.Flags != 0 {
		buf.WriteString(`"flags":`)
		fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
		buf.WriteByte(',')
	}
	if j.UserRateLimit != 0 {
		buf.WriteString(`"rate_limit_per_user":`)

		{

			obj, err = j.UserRateLimit.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.DMRecipients) != 0 {
		buf.WriteString(`"recipients":`)
		if j.DMRecipients != nil {
			buf.WriteString(`[`)
			for i, v := range j.DMRecipients {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Icon) != 0 {
		buf.WriteString(`"icon":`)
		fflib.WriteJsonString(buf, string(j.Icon))
		buf.WriteByte(',')
	}
	if j.OwnerID != 0 {
		buf.WriteString(`"owner_id":`)

		{

			obj, err = j.OwnerID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ParentID != 0 {
		buf.WriteString(`"parent_id":`)

		{

			obj, err = j.ParentID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"last_pin_timestamp":`)

		{

			obj, err = j.LastPinTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.RTCRegionID) != 0 {
		buf.WriteString(`"rtc_region":`)
		fflib.WriteJsonString(buf, string(j.RTCRegionID))
		buf.WriteByte(',')
	}
	if j.VideoQualityMode != 0 {
		buf.WriteString(`"video_quality_mode":`)
		fflib.FormatBits2(buf, uint64(j.VideoQualityMode), 10, false)
		buf.WriteByte(',')
	}
	if j.MessageCount != 0 {
		buf.WriteString(`"message_count":`)
		fflib.FormatBits2(buf, uint64(j.MessageCount), 10, j.MessageCount < 0)
		buf.WriteByte(',')
	}
	if j.MemberCount != 0 {
		buf.WriteString(`"member_count":`)
		fflib.FormatBits2(buf, uint64(j.MemberCount), 10, j.MemberCount < 0)
		buf.WriteByte(',')
	}
	if j.ThreadMetadata != nil {
		if true {
			buf.WriteString(`"thread_metadata":`)

			{

				err = j.ThreadMetadata.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ThreadMember != nil {
		if true {
			buf.WriteString(`"thread_member":`)

			{

				err = j.ThreadMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultAutoArchiveDuration != 0 {
		buf.WriteString(`"default_auto_archive_duration":`)
		fflib.FormatBits2(buf, uint64(j.DefaultAutoArchiveDuration), 10, j.DefaultAutoArchiveDuration < 0)
		buf.WriteByte(',')
	}
	if j.SelfPermissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.SelfPermissions), 10, false)
		buf.WriteString(`",`)
	}
	if len(j.AvailableTags) != 0 {
		buf.WriteString(`"available_tags":`)
		if j.AvailableTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AvailableTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AppliedTags) != 0 {
		buf.WriteString(`"applied_tags":`)
		if j.AppliedTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AppliedTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DefaultReactionEmoji != nil {
		if true {
			buf.WriteString(`"default_reaction_emoji":`)

			{

				err = j.DefaultReactionEmoji.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultThreadRateLimitPerUser != 0 {
		buf.WriteString(`"default_thread_rate_limit_per_user":`)
		fflib.FormatBits2(buf, uint64(j.DefaultThreadRateLimitPerUser), 10, j.DefaultThreadRateLimitPerUser < 0)
		buf.WriteByte(',')
	}
	if j.DefaultSoftOrder != nil {
		if true {
			buf.WriteString(`"default_sort_order":`)
			fflib.FormatBits2(buf, uint64(*j.DefaultSoftOrder), 10, false)
			buf.WriteByte(',')
		}
	}
	if j.DefaultForumLayout != 0 {
		buf.WriteString(`"default_forum_layout":`)
		fflib.FormatBits2(buf, uint64(j.DefaultForumLayout), 10, false)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ThreadDeleteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ThreadDeleteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Type != 0 {
		buf.WriteString(`"type":`)
		fflib.FormatBits2(buf, uint64(j.Type), 10, false)
		buf.WriteByte(',')
	}
	if j.ParentID != 0 {
		buf.WriteString(`"parent_id":`)

		{

			obj, err = j.ParentID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtThreadDeleteEventbase = iota
	ffjtThreadDeleteEventnosuchkey

	ffjtThreadDeleteEventID

	ffjtThreadDeleteEventGuildID

	ffjtThreadDeleteEventType

	ffjtThreadDeleteEventParentID
)

var ffjKeyThreadDeleteEventID = []byte("id")

var ffjKeyThreadDeleteEventGuildID = []byte("guild_id")

var ffjKeyThreadDeleteEventType = []byte("type")

var ffjKeyThreadDeleteEventParentID = []byte("parent_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ThreadDeleteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ThreadDeleteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtThreadDeleteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtThreadDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyThreadDeleteEventGuildID, kn) {
						currentKey = ffjtThreadDeleteEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyThreadDeleteEventID, kn) {
						currentKey = ffjtThreadDeleteEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyThreadDeleteEventParentID, kn) {
						currentKey = ffjtThreadDeleteEventParentID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyThreadDeleteEventType, kn) {
						currentKey = ffjtThreadDeleteEventType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyThreadDeleteEventParentID, kn) {
					currentKey = ffjtThreadDeleteEventParentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyThreadDeleteEventType, kn) {
					currentKey = ffjtThreadDeleteEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyThreadDeleteEventGuildID, kn) {
					currentKey = ffjtThreadDeleteEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyThreadDeleteEventID, kn) {
					currentKey = ffjtThreadDeleteEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtThreadDeleteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtThreadDeleteEventID:
					goto handle_ID

				case ffjtThreadDeleteEventGuildID:
					goto handle_GuildID

				case ffjtThreadDeleteEventType:
					goto handle_Type

				case ffjtThreadDeleteEventParentID:
					goto handle_ParentID

				case ffjtThreadDeleteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=discord.ChannelType kind=uint16 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ChannelType", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 16)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Type = discord.ChannelType(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParentID:

	/* handler: j.ParentID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ParentID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ThreadListSyncEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ThreadListSyncEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if len(j.ChannelIDs) != 0 {
		buf.WriteString(`"channel_ids":`)
		if j.ChannelIDs != nil {
			buf.WriteString(`[`)
			for i, v := range j.ChannelIDs {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"threads":`)
	if j.Threads != nil {
		buf.WriteString(`[`)
		for i, v := range j.Threads {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"members":`)
	if j.Members != nil {
		buf.WriteString(`[`)
		for i, v := range j.Members {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtThreadListSyncEventbase = iota
	ffjtThreadListSyncEventnosuchkey

	ffjtThreadListSyncEventGuildID

	ffjtThreadListSyncEventChannelIDs

	ffjtThreadListSyncEventThreads

	ffjtThreadListSyncEventMembers
)

var ffjKeyThreadListSyncEventGuildID = []byte("guild_id")

var ffjKeyThreadListSyncEventChannelIDs = []byte("channel_ids")

var ffjKeyThreadListSyncEventThreads = []byte("threads")

var ffjKeyThreadListSyncEventMembers = []byte("members")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ThreadListSyncEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ThreadListSyncEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtThreadListSyncEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtThreadListSyncEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyThreadListSyncEventChannelIDs, kn) {
						currentKey = ffjtThreadListSyncEventChannelIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyThreadListSyncEventGuildID, kn) {
						currentKey = ffjtThreadListSyncEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyThreadListSyncEventMembers, kn) {
						currentKey = ffjtThreadListSyncEventMembers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyThreadListSyncEventThreads, kn) {
						currentKey = ffjtThreadListSyncEventThreads
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyThreadListSyncEventMembers, kn) {
					currentKey = ffjtThreadListSyncEventMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyThreadListSyncEventThreads, kn) {
					currentKey = ffjtThreadListSyncEventThreads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyThreadListSyncEventChannelIDs, kn) {
					currentKey = ffjtThreadListSyncEventChannelIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyThreadListSyncEventGuildID, kn) {
					currentKey = ffjtThreadListSyncEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtThreadListSyncEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtThreadListSyncEventGuildID:
					goto handle_GuildID

				case ffjtThreadListSyncEventChannelIDs:
					goto handle_ChannelIDs

				case ffjtThreadListSyncEventThreads:
					goto handle_Threads

				case ffjtThreadListSyncEventMembers:
					goto handle_Members

				case ffjtThreadListSyncEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelIDs:

	/* handler: j.ChannelIDs type=[]discord.ChannelID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ChannelIDs = nil
		} else {

			j.ChannelIDs = []discord.ChannelID{}

			wantVal := true

			for {

				var tmpJChannelIDs discord.ChannelID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChannelIDs type=discord.ChannelID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJChannelIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ChannelIDs = append(j.ChannelIDs, tmpJChannelIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Threads:

	/* handler: j.Threads type=[]discord.Channel kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Threads = nil
		} else {

			j.Threads = []discord.Channel{}

			wantVal := true

			for {

				var tmpJThreads discord.Channel

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJThreads type=discord.Channel kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJThreads.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Threads = append(j.Threads, tmpJThreads)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Members:

	/* handler: j.Members type=[]discord.ThreadMember kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Members = nil
		} else {

			j.Members = []discord.ThreadMember{}

			wantVal := true

			for {

				var tmpJMembers discord.ThreadMember

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMembers type=discord.ThreadMember kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Members = append(j.Members, tmpJMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ThreadMemberUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ThreadMemberUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if j.ID != 0 {
		buf.WriteString(`"id":`)

		{

			obj, err = j.ID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.UserID != 0 {
		buf.WriteString(`"user_id":`)

		{

			obj, err = j.UserID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Presence != nil {
		if true {
			buf.WriteString(`"presence":`)

			{

				err = j.Presence.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"join_timestamp":`)

	{

		obj, err = j.JoinTimestamp.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"flags":`)
	fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtThreadMemberUpdateEventbase = iota
	ffjtThreadMemberUpdateEventnosuchkey

	ffjtThreadMemberUpdateEventID

	ffjtThreadMemberUpdateEventUserID

	ffjtThreadMemberUpdateEventMember

	ffjtThreadMemberUpdateEventPresence

	ffjtThreadMemberUpdateEventJoinTimestamp

	ffjtThreadMemberUpdateEventFlags
)

var ffjKeyThreadMemberUpdateEventID = []byte("id")

var ffjKeyThreadMemberUpdateEventUserID = []byte("user_id")

var ffjKeyThreadMemberUpdateEventMember = []byte("member")

var ffjKeyThreadMemberUpdateEventPresence = []byte("presence")

var ffjKeyThreadMemberUpdateEventJoinTimestamp = []byte("join_timestamp")

var ffjKeyThreadMemberUpdateEventFlags = []byte("flags")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ThreadMemberUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ThreadMemberUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtThreadMemberUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtThreadMemberUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyThreadMemberUpdateEventFlags, kn) {
						currentKey = ffjtThreadMemberUpdateEventFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyThreadMemberUpdateEventID, kn) {
						currentKey = ffjtThreadMemberUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffjKeyThreadMemberUpdateEventJoinTimestamp, kn) {
						currentKey = ffjtThreadMemberUpdateEventJoinTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyThreadMemberUpdateEventMember, kn) {
						currentKey = ffjtThreadMemberUpdateEventMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyThreadMemberUpdateEventPresence, kn) {
						currentKey = ffjtThreadMemberUpdateEventPresence
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyThreadMemberUpdateEventUserID, kn) {
						currentKey = ffjtThreadMemberUpdateEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyThreadMemberUpdateEventFlags, kn) {
					currentKey = ffjtThreadMemberUpdateEventFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyThreadMemberUpdateEventJoinTimestamp, kn) {
					currentKey = ffjtThreadMemberUpdateEventJoinTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyThreadMemberUpdateEventPresence, kn) {
					currentKey = ffjtThreadMemberUpdateEventPresence
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyThreadMemberUpdateEventMember, kn) {
					currentKey = ffjtThreadMemberUpdateEventMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyThreadMemberUpdateEventUserID, kn) {
					currentKey = ffjtThreadMemberUpdateEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyThreadMemberUpdateEventID, kn) {
					currentKey = ffjtThreadMemberUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtThreadMemberUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtThreadMemberUpdateEventID:
					goto handle_ID

				case ffjtThreadMemberUpdateEventUserID:
					goto handle_UserID

				case ffjtThreadMemberUpdateEventMember:
					goto handle_Member

				case ffjtThreadMemberUpdateEventPresence:
					goto handle_Presence

				case ffjtThreadMemberUpdateEventJoinTimestamp:
					goto handle_JoinTimestamp

				case ffjtThreadMemberUpdateEventFlags:
					goto handle_Flags

				case ffjtThreadMemberUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Member:

	/* handler: j.Member type=discord.Member kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(discord.Member)
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Presence:

	/* handler: j.Presence type=discord.Presence kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Presence = nil

		} else {

			if j.Presence == nil {
				j.Presence = new(discord.Presence)
			}

			err = j.Presence.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_JoinTimestamp:

	/* handler: j.JoinTimestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.JoinTimestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flags:

	/* handler: j.Flags type=discord.ThreadMemberFlags kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ThreadMemberFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Flags = discord.ThreadMemberFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ThreadMembersUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ThreadMembersUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"member_count":`)
	fflib.FormatBits2(buf, uint64(j.MemberCount), 10, j.MemberCount < 0)
	buf.WriteByte(',')
	if len(j.AddedMembers) != 0 {
		buf.WriteString(`"added_members":`)
		if j.AddedMembers != nil {
			buf.WriteString(`[`)
			for i, v := range j.AddedMembers {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.RemovedMemberIDs) != 0 {
		buf.WriteString(`"removed_member_ids":`)
		if j.RemovedMemberIDs != nil {
			buf.WriteString(`[`)
			for i, v := range j.RemovedMemberIDs {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtThreadMembersUpdateEventbase = iota
	ffjtThreadMembersUpdateEventnosuchkey

	ffjtThreadMembersUpdateEventID

	ffjtThreadMembersUpdateEventGuildID

	ffjtThreadMembersUpdateEventMemberCount

	ffjtThreadMembersUpdateEventAddedMembers

	ffjtThreadMembersUpdateEventRemovedMemberIDs
)

var ffjKeyThreadMembersUpdateEventID = []byte("id")

var ffjKeyThreadMembersUpdateEventGuildID = []byte("guild_id")

var ffjKeyThreadMembersUpdateEventMemberCount = []byte("member_count")

var ffjKeyThreadMembersUpdateEventAddedMembers = []byte("added_members")

var ffjKeyThreadMembersUpdateEventRemovedMemberIDs = []byte("removed_member_ids")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ThreadMembersUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ThreadMembersUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtThreadMembersUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtThreadMembersUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyThreadMembersUpdateEventAddedMembers, kn) {
						currentKey = ffjtThreadMembersUpdateEventAddedMembers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyThreadMembersUpdateEventGuildID, kn) {
						currentKey = ffjtThreadMembersUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyThreadMembersUpdateEventID, kn) {
						currentKey = ffjtThreadMembersUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyThreadMembersUpdateEventMemberCount, kn) {
						currentKey = ffjtThreadMembersUpdateEventMemberCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyThreadMembersUpdateEventRemovedMemberIDs, kn) {
						currentKey = ffjtThreadMembersUpdateEventRemovedMemberIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyThreadMembersUpdateEventRemovedMemberIDs, kn) {
					currentKey = ffjtThreadMembersUpdateEventRemovedMemberIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyThreadMembersUpdateEventAddedMembers, kn) {
					currentKey = ffjtThreadMembersUpdateEventAddedMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyThreadMembersUpdateEventMemberCount, kn) {
					currentKey = ffjtThreadMembersUpdateEventMemberCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyThreadMembersUpdateEventGuildID, kn) {
					currentKey = ffjtThreadMembersUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyThreadMembersUpdateEventID, kn) {
					currentKey = ffjtThreadMembersUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtThreadMembersUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtThreadMembersUpdateEventID:
					goto handle_ID

				case ffjtThreadMembersUpdateEventGuildID:
					goto handle_GuildID

				case ffjtThreadMembersUpdateEventMemberCount:
					goto handle_MemberCount

				case ffjtThreadMembersUpdateEventAddedMembers:
					goto handle_AddedMembers

				case ffjtThreadMembersUpdateEventRemovedMemberIDs:
					goto handle_RemovedMemberIDs

				case ffjtThreadMembersUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemberCount:

	/* handler: j.MemberCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MemberCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AddedMembers:

	/* handler: j.AddedMembers type=[]discord.ThreadMember kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AddedMembers = nil
		} else {

			j.AddedMembers = []discord.ThreadMember{}

			wantVal := true

			for {

				var tmpJAddedMembers discord.ThreadMember

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAddedMembers type=discord.ThreadMember kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJAddedMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.AddedMembers = append(j.AddedMembers, tmpJAddedMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemovedMemberIDs:

	/* handler: j.RemovedMemberIDs type=[]discord.UserID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RemovedMemberIDs = nil
		} else {

			j.RemovedMemberIDs = []discord.UserID{}

			wantVal := true

			for {

				var tmpJRemovedMemberIDs discord.UserID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRemovedMemberIDs type=discord.UserID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRemovedMemberIDs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RemovedMemberIDs = append(j.RemovedMemberIDs, tmpJRemovedMemberIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ThreadUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ThreadUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Type != 0 {
		buf.WriteString(`"type":`)
		fflib.FormatBits2(buf, uint64(j.Type), 10, false)
		buf.WriteByte(',')
	}
	if j.NSFW != false {
		if j.NSFW {
			buf.WriteString(`"nsfw":true`)
		} else {
			buf.WriteString(`"nsfw":false`)
		}
		buf.WriteByte(',')
	}
	if j.Position != 0 {
		buf.WriteString(`"position":`)
		fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
		buf.WriteByte(',')
	}
	if len(j.Overwrites) != 0 {
		buf.WriteString(`"permission_overwrites":`)
		if j.Overwrites != nil {
			buf.WriteString(`[`)
			for i, v := range j.Overwrites {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Topic) != 0 {
		buf.WriteString(`"topic":`)
		fflib.WriteJsonString(buf, string(j.Topic))
		buf.WriteByte(',')
	}
	if j.LastMessageID != 0 {
		buf.WriteString(`"last_message_id":`)

		{

			obj, err = j.LastMessageID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.VoiceBitrate != 0 {
		buf.WriteString(`"bitrate":`)
		fflib.FormatBits2(buf, uint64(j.VoiceBitrate), 10, false)
		buf.WriteByte(',')
	}
	if j.VoiceUserLimit != 0 {
		buf.WriteString(`"user_limit":`)
		fflib.FormatBits2(buf, uint64(j.VoiceUserLimit), 10, false)
		buf.WriteByte(',')
	}
	if j.Flags != 0 {
		buf.WriteString(`"flags":`)
		fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
		buf.WriteByte(',')
	}
	if j.UserRateLimit != 0 {
		buf.WriteString(`"rate_limit_per_user":`)

		{

			obj, err = j.UserRateLimit.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.DMRecipients) != 0 {
		buf.WriteString(`"recipients":`)
		if j.DMRecipients != nil {
			buf.WriteString(`[`)
			for i, v := range j.DMRecipients {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Icon) != 0 {
		buf.WriteString(`"icon":`)
		fflib.WriteJsonString(buf, string(j.Icon))
		buf.WriteByte(',')
	}
	if j.OwnerID != 0 {
		buf.WriteString(`"owner_id":`)

		{

			obj, err = j.OwnerID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.AppID != 0 {
		buf.WriteString(`"application_id":`)

		{

			obj, err = j.AppID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ParentID != 0 {
		buf.WriteString(`"parent_id":`)

		{

			obj, err = j.ParentID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"last_pin_timestamp":`)

		{

			obj, err = j.LastPinTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.RTCRegionID) != 0 {
		buf.WriteString(`"rtc_region":`)
		fflib.WriteJsonString(buf, string(j.RTCRegionID))
		buf.WriteByte(',')
	}
	if j.VideoQualityMode != 0 {
		buf.WriteString(`"video_quality_mode":`)
		fflib.FormatBits2(buf, uint64(j.VideoQualityMode), 10, false)
		buf.WriteByte(',')
	}
	if j.MessageCount != 0 {
		buf.WriteString(`"message_count":`)
		fflib.FormatBits2(buf, uint64(j.MessageCount), 10, j.MessageCount < 0)
		buf.WriteByte(',')
	}
	if j.MemberCount != 0 {
		buf.WriteString(`"member_count":`)
		fflib.FormatBits2(buf, uint64(j.MemberCount), 10, j.MemberCount < 0)
		buf.WriteByte(',')
	}
	if j.ThreadMetadata != nil {
		if true {
			buf.WriteString(`"thread_metadata":`)

			{

				err = j.ThreadMetadata.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ThreadMember != nil {
		if true {
			buf.WriteString(`"thread_member":`)

			{

				err = j.ThreadMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultAutoArchiveDuration != 0 {
		buf.WriteString(`"default_auto_archive_duration":`)
		fflib.FormatBits2(buf, uint64(j.DefaultAutoArchiveDuration), 10, j.DefaultAutoArchiveDuration < 0)
		buf.WriteByte(',')
	}
	if j.SelfPermissions != 0 {
		buf.WriteString(`"permissions":"`)
		fflib.FormatBits2(buf, uint64(j.SelfPermissions), 10, false)
		buf.WriteString(`",`)
	}
	if len(j.AvailableTags) != 0 {
		buf.WriteString(`"available_tags":`)
		if j.AvailableTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AvailableTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AppliedTags) != 0 {
		buf.WriteString(`"applied_tags":`)
		if j.AppliedTags != nil {
			buf.WriteString(`[`)
			for i, v := range j.AppliedTags {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					obj, err = v.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DefaultReactionEmoji != nil {
		if true {
			buf.WriteString(`"default_reaction_emoji":`)

			{

				err = j.DefaultReactionEmoji.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DefaultThreadRateLimitPerUser != 0 {
		buf.WriteString(`"default_thread_rate_limit_per_user":`)
		fflib.FormatBits2(buf, uint64(j.DefaultThreadRateLimitPerUser), 10, j.DefaultThreadRateLimitPerUser < 0)
		buf.WriteByte(',')
	}
	if j.DefaultSoftOrder != nil {
		if true {
			buf.WriteString(`"default_sort_order":`)
			fflib.FormatBits2(buf, uint64(*j.DefaultSoftOrder), 10, false)
			buf.WriteByte(',')
		}
	}
	if j.DefaultForumLayout != 0 {
		buf.WriteString(`"default_forum_layout":`)
		fflib.FormatBits2(buf, uint64(j.DefaultForumLayout), 10, false)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *TypingStartEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *TypingStartEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"timestamp":`)
	fflib.FormatBits2(buf, uint64(j.Timestamp), 10, j.Timestamp < 0)
	buf.WriteByte(',')
	if j.GuildID != 0 {
		buf.WriteString(`"guild_id":`)

		{

			obj, err = j.GuildID.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtTypingStartEventbase = iota
	ffjtTypingStartEventnosuchkey

	ffjtTypingStartEventChannelID

	ffjtTypingStartEventUserID

	ffjtTypingStartEventTimestamp

	ffjtTypingStartEventGuildID

	ffjtTypingStartEventMember
)

var ffjKeyTypingStartEventChannelID = []byte("channel_id")

var ffjKeyTypingStartEventUserID = []byte("user_id")

var ffjKeyTypingStartEventTimestamp = []byte("timestamp")

var ffjKeyTypingStartEventGuildID = []byte("guild_id")

var ffjKeyTypingStartEventMember = []byte("member")

// UnmarshalJSON umarshall json - template of ffjson
func (j *TypingStartEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *TypingStartEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTypingStartEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTypingStartEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyTypingStartEventChannelID, kn) {
						currentKey = ffjtTypingStartEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyTypingStartEventGuildID, kn) {
						currentKey = ffjtTypingStartEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyTypingStartEventMember, kn) {
						currentKey = ffjtTypingStartEventMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyTypingStartEventTimestamp, kn) {
						currentKey = ffjtTypingStartEventTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyTypingStartEventUserID, kn) {
						currentKey = ffjtTypingStartEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyTypingStartEventMember, kn) {
					currentKey = ffjtTypingStartEventMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyTypingStartEventGuildID, kn) {
					currentKey = ffjtTypingStartEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTypingStartEventTimestamp, kn) {
					currentKey = ffjtTypingStartEventTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTypingStartEventUserID, kn) {
					currentKey = ffjtTypingStartEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyTypingStartEventChannelID, kn) {
					currentKey = ffjtTypingStartEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTypingStartEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTypingStartEventChannelID:
					goto handle_ChannelID

				case ffjtTypingStartEventUserID:
					goto handle_UserID

				case ffjtTypingStartEventTimestamp:
					goto handle_Timestamp

				case ffjtTypingStartEventGuildID:
					goto handle_GuildID

				case ffjtTypingStartEventMember:
					goto handle_Member

				case ffjtTypingStartEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=discord.UnixTimestamp kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UnixTimestamp", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Timestamp = discord.UnixTimestamp(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Member:

	/* handler: j.Member type=discord.Member kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(discord.Member)
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UpdatePresenceCommand) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UpdatePresenceCommand) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"since":`)
	fflib.FormatBits2(buf, uint64(j.Since), 10, j.Since < 0)
	buf.WriteString(`,"activities":`)
	if j.Activities != nil {
		buf.WriteString(`[`)
		for i, v := range j.Activities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.AFK {
		buf.WriteString(`,"afk":true`)
	} else {
		buf.WriteString(`,"afk":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUpdatePresenceCommandbase = iota
	ffjtUpdatePresenceCommandnosuchkey

	ffjtUpdatePresenceCommandSince

	ffjtUpdatePresenceCommandActivities

	ffjtUpdatePresenceCommandStatus

	ffjtUpdatePresenceCommandAFK
)

var ffjKeyUpdatePresenceCommandSince = []byte("since")

var ffjKeyUpdatePresenceCommandActivities = []byte("activities")

var ffjKeyUpdatePresenceCommandStatus = []byte("status")

var ffjKeyUpdatePresenceCommandAFK = []byte("afk")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UpdatePresenceCommand) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UpdatePresenceCommand) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUpdatePresenceCommandbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUpdatePresenceCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUpdatePresenceCommandActivities, kn) {
						currentKey = ffjtUpdatePresenceCommandActivities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdatePresenceCommandAFK, kn) {
						currentKey = ffjtUpdatePresenceCommandAFK
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUpdatePresenceCommandSince, kn) {
						currentKey = ffjtUpdatePresenceCommandSince
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdatePresenceCommandStatus, kn) {
						currentKey = ffjtUpdatePresenceCommandStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUpdatePresenceCommandAFK, kn) {
					currentKey = ffjtUpdatePresenceCommandAFK
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdatePresenceCommandStatus, kn) {
					currentKey = ffjtUpdatePresenceCommandStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdatePresenceCommandActivities, kn) {
					currentKey = ffjtUpdatePresenceCommandActivities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdatePresenceCommandSince, kn) {
					currentKey = ffjtUpdatePresenceCommandSince
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUpdatePresenceCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUpdatePresenceCommandSince:
					goto handle_Since

				case ffjtUpdatePresenceCommandActivities:
					goto handle_Activities

				case ffjtUpdatePresenceCommandStatus:
					goto handle_Status

				case ffjtUpdatePresenceCommandAFK:
					goto handle_AFK

				case ffjtUpdatePresenceCommandnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Since:

	/* handler: j.Since type=discord.UnixMsTimestamp kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UnixMsTimestamp", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Since = discord.UnixMsTimestamp(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activities:

	/* handler: j.Activities type=[]discord.Activity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Activities = nil
		} else {

			j.Activities = []discord.Activity{}

			wantVal := true

			for {

				var tmpJActivities discord.Activity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActivities type=discord.Activity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJActivities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Activities = append(j.Activities, tmpJActivities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = discord.Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AFK:

	/* handler: j.AFK type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AFK = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AFK = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UpdateVoiceStateCommand) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UpdateVoiceStateCommand) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.SelfMute {
		buf.WriteString(`,"self_mute":true`)
	} else {
		buf.WriteString(`,"self_mute":false`)
	}
	if j.SelfDeaf {
		buf.WriteString(`,"self_deaf":true`)
	} else {
		buf.WriteString(`,"self_deaf":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUpdateVoiceStateCommandbase = iota
	ffjtUpdateVoiceStateCommandnosuchkey

	ffjtUpdateVoiceStateCommandGuildID

	ffjtUpdateVoiceStateCommandChannelID

	ffjtUpdateVoiceStateCommandSelfMute

	ffjtUpdateVoiceStateCommandSelfDeaf
)

var ffjKeyUpdateVoiceStateCommandGuildID = []byte("guild_id")

var ffjKeyUpdateVoiceStateCommandChannelID = []byte("channel_id")

var ffjKeyUpdateVoiceStateCommandSelfMute = []byte("self_mute")

var ffjKeyUpdateVoiceStateCommandSelfDeaf = []byte("self_deaf")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UpdateVoiceStateCommand) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UpdateVoiceStateCommand) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUpdateVoiceStateCommandbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUpdateVoiceStateCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyUpdateVoiceStateCommandChannelID, kn) {
						currentKey = ffjtUpdateVoiceStateCommandChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUpdateVoiceStateCommandGuildID, kn) {
						currentKey = ffjtUpdateVoiceStateCommandGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUpdateVoiceStateCommandSelfMute, kn) {
						currentKey = ffjtUpdateVoiceStateCommandSelfMute
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateVoiceStateCommandSelfDeaf, kn) {
						currentKey = ffjtUpdateVoiceStateCommandSelfDeaf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUpdateVoiceStateCommandSelfDeaf, kn) {
					currentKey = ffjtUpdateVoiceStateCommandSelfDeaf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateVoiceStateCommandSelfMute, kn) {
					currentKey = ffjtUpdateVoiceStateCommandSelfMute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateVoiceStateCommandChannelID, kn) {
					currentKey = ffjtUpdateVoiceStateCommandChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateVoiceStateCommandGuildID, kn) {
					currentKey = ffjtUpdateVoiceStateCommandGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUpdateVoiceStateCommandnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUpdateVoiceStateCommandGuildID:
					goto handle_GuildID

				case ffjtUpdateVoiceStateCommandChannelID:
					goto handle_ChannelID

				case ffjtUpdateVoiceStateCommandSelfMute:
					goto handle_SelfMute

				case ffjtUpdateVoiceStateCommandSelfDeaf:
					goto handle_SelfDeaf

				case ffjtUpdateVoiceStateCommandnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfMute:

	/* handler: j.SelfMute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SelfMute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SelfMute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfDeaf:

	/* handler: j.SelfDeaf type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SelfDeaf = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SelfDeaf = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserChannelOverride) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserChannelOverride) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Muted {
		buf.WriteString(`{"muted":true`)
	} else {
		buf.WriteString(`{"muted":false`)
	}
	if j.MuteConfig != nil {
		buf.WriteString(`,"mute_config":`)

		{

			err = j.MuteConfig.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"mute_config":null`)
	}
	buf.WriteString(`,"message_notifications":`)
	fflib.FormatBits2(buf, uint64(j.Notifications), 10, false)
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserChannelOverridebase = iota
	ffjtUserChannelOverridenosuchkey

	ffjtUserChannelOverrideMuted

	ffjtUserChannelOverrideMuteConfig

	ffjtUserChannelOverrideNotifications

	ffjtUserChannelOverrideChannelID
)

var ffjKeyUserChannelOverrideMuted = []byte("muted")

var ffjKeyUserChannelOverrideMuteConfig = []byte("mute_config")

var ffjKeyUserChannelOverrideNotifications = []byte("message_notifications")

var ffjKeyUserChannelOverrideChannelID = []byte("channel_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserChannelOverride) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserChannelOverride) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserChannelOverridebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserChannelOverridenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyUserChannelOverrideChannelID, kn) {
						currentKey = ffjtUserChannelOverrideChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUserChannelOverrideMuted, kn) {
						currentKey = ffjtUserChannelOverrideMuted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserChannelOverrideMuteConfig, kn) {
						currentKey = ffjtUserChannelOverrideMuteConfig
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserChannelOverrideNotifications, kn) {
						currentKey = ffjtUserChannelOverrideNotifications
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyUserChannelOverrideChannelID, kn) {
					currentKey = ffjtUserChannelOverrideChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserChannelOverrideNotifications, kn) {
					currentKey = ffjtUserChannelOverrideNotifications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserChannelOverrideMuteConfig, kn) {
					currentKey = ffjtUserChannelOverrideMuteConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserChannelOverrideMuted, kn) {
					currentKey = ffjtUserChannelOverrideMuted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserChannelOverridenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserChannelOverrideMuted:
					goto handle_Muted

				case ffjtUserChannelOverrideMuteConfig:
					goto handle_MuteConfig

				case ffjtUserChannelOverrideNotifications:
					goto handle_Notifications

				case ffjtUserChannelOverrideChannelID:
					goto handle_ChannelID

				case ffjtUserChannelOverridenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Muted:

	/* handler: j.Muted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Muted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Muted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MuteConfig:

	/* handler: j.MuteConfig type=gateway.UserMuteConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MuteConfig = nil

		} else {

			if j.MuteConfig == nil {
				j.MuteConfig = new(UserMuteConfig)
			}

			err = j.MuteConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notifications:

	/* handler: j.Notifications type=gateway.UserNotification kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UserNotification", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Notifications = UserNotification(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserGuildSetting) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserGuildSetting) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.SuppressRoles {
		buf.WriteString(`,"suppress_roles":true`)
	} else {
		buf.WriteString(`,"suppress_roles":false`)
	}
	if j.SuppressEveryone {
		buf.WriteString(`,"suppress_everyone":true`)
	} else {
		buf.WriteString(`,"suppress_everyone":false`)
	}
	if j.Muted {
		buf.WriteString(`,"muted":true`)
	} else {
		buf.WriteString(`,"muted":false`)
	}
	if j.MuteConfig != nil {
		buf.WriteString(`,"mute_config":`)

		{

			err = j.MuteConfig.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"mute_config":null`)
	}
	if j.MobilePush {
		buf.WriteString(`,"mobile_push":true`)
	} else {
		buf.WriteString(`,"mobile_push":false`)
	}
	buf.WriteString(`,"message_notifications":`)
	fflib.FormatBits2(buf, uint64(j.Notifications), 10, false)
	buf.WriteString(`,"channel_overrides":`)
	if j.ChannelOverrides != nil {
		buf.WriteString(`[`)
		for i, v := range j.ChannelOverrides {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserGuildSettingbase = iota
	ffjtUserGuildSettingnosuchkey

	ffjtUserGuildSettingGuildID

	ffjtUserGuildSettingSuppressRoles

	ffjtUserGuildSettingSuppressEveryone

	ffjtUserGuildSettingMuted

	ffjtUserGuildSettingMuteConfig

	ffjtUserGuildSettingMobilePush

	ffjtUserGuildSettingNotifications

	ffjtUserGuildSettingChannelOverrides
)

var ffjKeyUserGuildSettingGuildID = []byte("guild_id")

var ffjKeyUserGuildSettingSuppressRoles = []byte("suppress_roles")

var ffjKeyUserGuildSettingSuppressEveryone = []byte("suppress_everyone")

var ffjKeyUserGuildSettingMuted = []byte("muted")

var ffjKeyUserGuildSettingMuteConfig = []byte("mute_config")

var ffjKeyUserGuildSettingMobilePush = []byte("mobile_push")

var ffjKeyUserGuildSettingNotifications = []byte("message_notifications")

var ffjKeyUserGuildSettingChannelOverrides = []byte("channel_overrides")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserGuildSetting) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserGuildSetting) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserGuildSettingbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserGuildSettingnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyUserGuildSettingChannelOverrides, kn) {
						currentKey = ffjtUserGuildSettingChannelOverrides
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUserGuildSettingGuildID, kn) {
						currentKey = ffjtUserGuildSettingGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUserGuildSettingMuted, kn) {
						currentKey = ffjtUserGuildSettingMuted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingMuteConfig, kn) {
						currentKey = ffjtUserGuildSettingMuteConfig
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingMobilePush, kn) {
						currentKey = ffjtUserGuildSettingMobilePush
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingNotifications, kn) {
						currentKey = ffjtUserGuildSettingNotifications
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserGuildSettingSuppressRoles, kn) {
						currentKey = ffjtUserGuildSettingSuppressRoles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingSuppressEveryone, kn) {
						currentKey = ffjtUserGuildSettingSuppressEveryone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingChannelOverrides, kn) {
					currentKey = ffjtUserGuildSettingChannelOverrides
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingNotifications, kn) {
					currentKey = ffjtUserGuildSettingNotifications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingMobilePush, kn) {
					currentKey = ffjtUserGuildSettingMobilePush
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserGuildSettingMuteConfig, kn) {
					currentKey = ffjtUserGuildSettingMuteConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserGuildSettingMuted, kn) {
					currentKey = ffjtUserGuildSettingMuted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingSuppressEveryone, kn) {
					currentKey = ffjtUserGuildSettingSuppressEveryone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingSuppressRoles, kn) {
					currentKey = ffjtUserGuildSettingSuppressRoles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserGuildSettingGuildID, kn) {
					currentKey = ffjtUserGuildSettingGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserGuildSettingnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserGuildSettingGuildID:
					goto handle_GuildID

				case ffjtUserGuildSettingSuppressRoles:
					goto handle_SuppressRoles

				case ffjtUserGuildSettingSuppressEveryone:
					goto handle_SuppressEveryone

				case ffjtUserGuildSettingMuted:
					goto handle_Muted

				case ffjtUserGuildSettingMuteConfig:
					goto handle_MuteConfig

				case ffjtUserGuildSettingMobilePush:
					goto handle_MobilePush

				case ffjtUserGuildSettingNotifications:
					goto handle_Notifications

				case ffjtUserGuildSettingChannelOverrides:
					goto handle_ChannelOverrides

				case ffjtUserGuildSettingnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuppressRoles:

	/* handler: j.SuppressRoles type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SuppressRoles = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SuppressRoles = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuppressEveryone:

	/* handler: j.SuppressEveryone type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SuppressEveryone = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SuppressEveryone = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Muted:

	/* handler: j.Muted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Muted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Muted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MuteConfig:

	/* handler: j.MuteConfig type=gateway.UserMuteConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MuteConfig = nil

		} else {

			if j.MuteConfig == nil {
				j.MuteConfig = new(UserMuteConfig)
			}

			err = j.MuteConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MobilePush:

	/* handler: j.MobilePush type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MobilePush = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MobilePush = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notifications:

	/* handler: j.Notifications type=gateway.UserNotification kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UserNotification", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Notifications = UserNotification(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelOverrides:

	/* handler: j.ChannelOverrides type=[]gateway.UserChannelOverride kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ChannelOverrides = nil
		} else {

			j.ChannelOverrides = []UserChannelOverride{}

			wantVal := true

			for {

				var tmpJChannelOverrides UserChannelOverride

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChannelOverrides type=gateway.UserChannelOverride kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJChannelOverrides.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ChannelOverrides = append(j.ChannelOverrides, tmpJChannelOverrides)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserGuildSettingsUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserGuildSettingsUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.SuppressRoles {
		buf.WriteString(`,"suppress_roles":true`)
	} else {
		buf.WriteString(`,"suppress_roles":false`)
	}
	if j.SuppressEveryone {
		buf.WriteString(`,"suppress_everyone":true`)
	} else {
		buf.WriteString(`,"suppress_everyone":false`)
	}
	if j.Muted {
		buf.WriteString(`,"muted":true`)
	} else {
		buf.WriteString(`,"muted":false`)
	}
	if j.MuteConfig != nil {
		buf.WriteString(`,"mute_config":`)

		{

			err = j.MuteConfig.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"mute_config":null`)
	}
	if j.MobilePush {
		buf.WriteString(`,"mobile_push":true`)
	} else {
		buf.WriteString(`,"mobile_push":false`)
	}
	buf.WriteString(`,"message_notifications":`)
	fflib.FormatBits2(buf, uint64(j.Notifications), 10, false)
	buf.WriteString(`,"channel_overrides":`)
	if j.ChannelOverrides != nil {
		buf.WriteString(`[`)
		for i, v := range j.ChannelOverrides {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserGuildSettingsUpdateEventbase = iota
	ffjtUserGuildSettingsUpdateEventnosuchkey

	ffjtUserGuildSettingsUpdateEventGuildID

	ffjtUserGuildSettingsUpdateEventSuppressRoles

	ffjtUserGuildSettingsUpdateEventSuppressEveryone

	ffjtUserGuildSettingsUpdateEventMuted

	ffjtUserGuildSettingsUpdateEventMuteConfig

	ffjtUserGuildSettingsUpdateEventMobilePush

	ffjtUserGuildSettingsUpdateEventNotifications

	ffjtUserGuildSettingsUpdateEventChannelOverrides
)

var ffjKeyUserGuildSettingsUpdateEventGuildID = []byte("guild_id")

var ffjKeyUserGuildSettingsUpdateEventSuppressRoles = []byte("suppress_roles")

var ffjKeyUserGuildSettingsUpdateEventSuppressEveryone = []byte("suppress_everyone")

var ffjKeyUserGuildSettingsUpdateEventMuted = []byte("muted")

var ffjKeyUserGuildSettingsUpdateEventMuteConfig = []byte("mute_config")

var ffjKeyUserGuildSettingsUpdateEventMobilePush = []byte("mobile_push")

var ffjKeyUserGuildSettingsUpdateEventNotifications = []byte("message_notifications")

var ffjKeyUserGuildSettingsUpdateEventChannelOverrides = []byte("channel_overrides")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserGuildSettingsUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserGuildSettingsUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserGuildSettingsUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserGuildSettingsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventChannelOverrides, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventChannelOverrides
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventGuildID, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventMuted, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventMuted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventMuteConfig, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventMuteConfig
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventMobilePush, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventMobilePush
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventNotifications, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventNotifications
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventSuppressRoles, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventSuppressRoles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserGuildSettingsUpdateEventSuppressEveryone, kn) {
						currentKey = ffjtUserGuildSettingsUpdateEventSuppressEveryone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingsUpdateEventChannelOverrides, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventChannelOverrides
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingsUpdateEventNotifications, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventNotifications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingsUpdateEventMobilePush, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventMobilePush
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserGuildSettingsUpdateEventMuteConfig, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventMuteConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserGuildSettingsUpdateEventMuted, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventMuted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingsUpdateEventSuppressEveryone, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventSuppressEveryone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserGuildSettingsUpdateEventSuppressRoles, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventSuppressRoles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserGuildSettingsUpdateEventGuildID, kn) {
					currentKey = ffjtUserGuildSettingsUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserGuildSettingsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserGuildSettingsUpdateEventGuildID:
					goto handle_GuildID

				case ffjtUserGuildSettingsUpdateEventSuppressRoles:
					goto handle_SuppressRoles

				case ffjtUserGuildSettingsUpdateEventSuppressEveryone:
					goto handle_SuppressEveryone

				case ffjtUserGuildSettingsUpdateEventMuted:
					goto handle_Muted

				case ffjtUserGuildSettingsUpdateEventMuteConfig:
					goto handle_MuteConfig

				case ffjtUserGuildSettingsUpdateEventMobilePush:
					goto handle_MobilePush

				case ffjtUserGuildSettingsUpdateEventNotifications:
					goto handle_Notifications

				case ffjtUserGuildSettingsUpdateEventChannelOverrides:
					goto handle_ChannelOverrides

				case ffjtUserGuildSettingsUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuppressRoles:

	/* handler: j.SuppressRoles type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SuppressRoles = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SuppressRoles = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuppressEveryone:

	/* handler: j.SuppressEveryone type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SuppressEveryone = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SuppressEveryone = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Muted:

	/* handler: j.Muted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Muted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Muted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MuteConfig:

	/* handler: j.MuteConfig type=gateway.UserMuteConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MuteConfig = nil

		} else {

			if j.MuteConfig == nil {
				j.MuteConfig = new(UserMuteConfig)
			}

			err = j.MuteConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MobilePush:

	/* handler: j.MobilePush type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MobilePush = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MobilePush = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notifications:

	/* handler: j.Notifications type=gateway.UserNotification kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UserNotification", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Notifications = UserNotification(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelOverrides:

	/* handler: j.ChannelOverrides type=[]gateway.UserChannelOverride kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ChannelOverrides = nil
		} else {

			j.ChannelOverrides = []UserChannelOverride{}

			wantVal := true

			for {

				var tmpJChannelOverrides UserChannelOverride

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChannelOverrides type=gateway.UserChannelOverride kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJChannelOverrides.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ChannelOverrides = append(j.ChannelOverrides, tmpJChannelOverrides)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserMuteConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserMuteConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"selected_time_window":`)
	fflib.FormatBits2(buf, uint64(j.SelectedTimeWindow), 10, j.SelectedTimeWindow < 0)
	buf.WriteString(`,"end_time":`)

	{

		obj, err = j.EndTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserMuteConfigbase = iota
	ffjtUserMuteConfignosuchkey

	ffjtUserMuteConfigSelectedTimeWindow

	ffjtUserMuteConfigEndTime
)

var ffjKeyUserMuteConfigSelectedTimeWindow = []byte("selected_time_window")

var ffjKeyUserMuteConfigEndTime = []byte("end_time")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserMuteConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserMuteConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserMuteConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserMuteConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyUserMuteConfigEndTime, kn) {
						currentKey = ffjtUserMuteConfigEndTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserMuteConfigSelectedTimeWindow, kn) {
						currentKey = ffjtUserMuteConfigSelectedTimeWindow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyUserMuteConfigEndTime, kn) {
					currentKey = ffjtUserMuteConfigEndTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserMuteConfigSelectedTimeWindow, kn) {
					currentKey = ffjtUserMuteConfigSelectedTimeWindow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserMuteConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserMuteConfigSelectedTimeWindow:
					goto handle_SelectedTimeWindow

				case ffjtUserMuteConfigEndTime:
					goto handle_EndTime

				case ffjtUserMuteConfignosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SelectedTimeWindow:

	/* handler: j.SelectedTimeWindow type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SelectedTimeWindow = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndTime:

	/* handler: j.EndTime type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EndTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserNoteUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserNoteUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"note":`)
	fflib.WriteJsonString(buf, string(j.Note))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserNoteUpdateEventbase = iota
	ffjtUserNoteUpdateEventnosuchkey

	ffjtUserNoteUpdateEventID

	ffjtUserNoteUpdateEventNote
)

var ffjKeyUserNoteUpdateEventID = []byte("id")

var ffjKeyUserNoteUpdateEventNote = []byte("note")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserNoteUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserNoteUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserNoteUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserNoteUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyUserNoteUpdateEventID, kn) {
						currentKey = ffjtUserNoteUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyUserNoteUpdateEventNote, kn) {
						currentKey = ffjtUserNoteUpdateEventNote
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserNoteUpdateEventNote, kn) {
					currentKey = ffjtUserNoteUpdateEventNote
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserNoteUpdateEventID, kn) {
					currentKey = ffjtUserNoteUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserNoteUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserNoteUpdateEventID:
					goto handle_ID

				case ffjtUserNoteUpdateEventNote:
					goto handle_Note

				case ffjtUserNoteUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Note:

	/* handler: j.Note type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Note = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserSession) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserSession) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteString(`,"session_id":`)
	fflib.WriteJsonString(buf, string(j.SessionID))
	buf.WriteString(`,"activities":`)
	if j.Activities != nil {
		buf.WriteString(`[`)
		for i, v := range j.Activities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	/* Inline struct. type=struct { Version int "json:\"version\""; OS string "json:\"os\""; Client string "json:\"client\"" } kind=struct */
	buf.WriteString(`,"client_info":{ "version":`)
	fflib.FormatBits2(buf, uint64(j.ClientInfo.Version), 10, j.ClientInfo.Version < 0)
	buf.WriteString(`,"os":`)
	fflib.WriteJsonString(buf, string(j.ClientInfo.OS))
	buf.WriteString(`,"client":`)
	fflib.WriteJsonString(buf, string(j.ClientInfo.Client))
	buf.WriteByte('}')
	buf.WriteByte(',')
	if j.Active != false {
		if j.Active {
			buf.WriteString(`"active":true`)
		} else {
			buf.WriteString(`"active":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserSessionbase = iota
	ffjtUserSessionnosuchkey

	ffjtUserSessionStatus

	ffjtUserSessionSessionID

	ffjtUserSessionActivities

	ffjtUserSessionClientInfo

	ffjtUserSessionActive
)

var ffjKeyUserSessionStatus = []byte("status")

var ffjKeyUserSessionSessionID = []byte("session_id")

var ffjKeyUserSessionActivities = []byte("activities")

var ffjKeyUserSessionClientInfo = []byte("client_info")

var ffjKeyUserSessionActive = []byte("active")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserSession) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserSession) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserSessionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserSessionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUserSessionActivities, kn) {
						currentKey = ffjtUserSessionActivities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSessionActive, kn) {
						currentKey = ffjtUserSessionActive
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyUserSessionClientInfo, kn) {
						currentKey = ffjtUserSessionClientInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserSessionStatus, kn) {
						currentKey = ffjtUserSessionStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSessionSessionID, kn) {
						currentKey = ffjtUserSessionSessionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserSessionActive, kn) {
					currentKey = ffjtUserSessionActive
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSessionClientInfo, kn) {
					currentKey = ffjtUserSessionClientInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSessionActivities, kn) {
					currentKey = ffjtUserSessionActivities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSessionSessionID, kn) {
					currentKey = ffjtUserSessionSessionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSessionStatus, kn) {
					currentKey = ffjtUserSessionStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserSessionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserSessionStatus:
					goto handle_Status

				case ffjtUserSessionSessionID:
					goto handle_SessionID

				case ffjtUserSessionActivities:
					goto handle_Activities

				case ffjtUserSessionClientInfo:
					goto handle_ClientInfo

				case ffjtUserSessionActive:
					goto handle_Active

				case ffjtUserSessionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = discord.Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SessionID:

	/* handler: j.SessionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SessionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activities:

	/* handler: j.Activities type=[]discord.Activity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Activities = nil
		} else {

			j.Activities = []discord.Activity{}

			wantVal := true

			for {

				var tmpJActivities discord.Activity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActivities type=discord.Activity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJActivities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Activities = append(j.Activities, tmpJActivities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClientInfo:

	/* handler: j.ClientInfo type=struct { Version int "json:\"version\""; OS string "json:\"os\""; Client string "json:\"client\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Version int "json:\"version\""; OS string "json:\"os\""; Client string "json:\"client\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ClientInfo)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Active:

	/* handler: j.Active type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Active = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Active = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserSettings) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserSettings) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.ShowCurrentGame {
		buf.WriteString(`{"show_current_game":true`)
	} else {
		buf.WriteString(`{"show_current_game":false`)
	}
	if j.DefaultGuildsRestricted {
		buf.WriteString(`,"default_guilds_restricted":true`)
	} else {
		buf.WriteString(`,"default_guilds_restricted":false`)
	}
	if j.InlineAttachmentMedia {
		buf.WriteString(`,"inline_attachment_media":true`)
	} else {
		buf.WriteString(`,"inline_attachment_media":false`)
	}
	if j.InlineEmbedMedia {
		buf.WriteString(`,"inline_embed_media":true`)
	} else {
		buf.WriteString(`,"inline_embed_media":false`)
	}
	if j.GIFAutoPlay {
		buf.WriteString(`,"gif_auto_play":true`)
	} else {
		buf.WriteString(`,"gif_auto_play":false`)
	}
	if j.RenderEmbeds {
		buf.WriteString(`,"render_embeds":true`)
	} else {
		buf.WriteString(`,"render_embeds":false`)
	}
	if j.RenderReactions {
		buf.WriteString(`,"render_reactions":true`)
	} else {
		buf.WriteString(`,"render_reactions":false`)
	}
	if j.AnimateEmoji {
		buf.WriteString(`,"animate_emoji":true`)
	} else {
		buf.WriteString(`,"animate_emoji":false`)
	}
	buf.WriteString(`,"animate_stickers":`)
	fflib.FormatBits2(buf, uint64(j.AnimateStickers), 10, j.AnimateStickers < 0)
	if j.EnableTTSCommand {
		buf.WriteString(`,"enable_tts_command":true`)
	} else {
		buf.WriteString(`,"enable_tts_command":false`)
	}
	if j.MessageDisplayCompact {
		buf.WriteString(`,"message_display_compact":true`)
	} else {
		buf.WriteString(`,"message_display_compact":false`)
	}
	if j.ConvertEmoticons {
		buf.WriteString(`,"convert_emoticons":true`)
	} else {
		buf.WriteString(`,"convert_emoticons":false`)
	}
	buf.WriteString(`,"explicit_content_filter":`)
	fflib.FormatBits2(buf, uint64(j.ExplicitContentFilter), 10, false)
	if j.DisableGamesTab {
		buf.WriteString(`,"disable_games_tab":true`)
	} else {
		buf.WriteString(`,"disable_games_tab":false`)
	}
	if j.DeveloperMode {
		buf.WriteString(`,"developer_mode":true`)
	} else {
		buf.WriteString(`,"developer_mode":false`)
	}
	if j.DetectPlatformAccounts {
		buf.WriteString(`,"detect_platform_accounts":true`)
	} else {
		buf.WriteString(`,"detect_platform_accounts":false`)
	}
	if j.StreamNotification {
		buf.WriteString(`,"stream_notification_enabled":true`)
	} else {
		buf.WriteString(`,"stream_notification_enabled":false`)
	}
	if j.AccessibilityDetection {
		buf.WriteString(`,"allow_accessibility_detection":true`)
	} else {
		buf.WriteString(`,"allow_accessibility_detection":false`)
	}
	if j.ContactSync {
		buf.WriteString(`,"contact_sync_enabled":true`)
	} else {
		buf.WriteString(`,"contact_sync_enabled":false`)
	}
	if j.NativePhoneIntegration {
		buf.WriteString(`,"native_phone_integration_enabled":true`)
	} else {
		buf.WriteString(`,"native_phone_integration_enabled":false`)
	}
	buf.WriteString(`,"timezone_offset":`)
	fflib.FormatBits2(buf, uint64(j.TimezoneOffset), 10, j.TimezoneOffset < 0)
	buf.WriteString(`,"locale":`)
	fflib.WriteJsonString(buf, string(j.Locale))
	buf.WriteString(`,"theme":`)
	fflib.WriteJsonString(buf, string(j.Theme))
	buf.WriteString(`,"guild_positions":`)
	if j.GuildPositions != nil {
		buf.WriteString(`[`)
		for i, v := range j.GuildPositions {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"guild_folders":`)
	if j.GuildFolders != nil {
		buf.WriteString(`[`)
		for i, v := range j.GuildFolders {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"restricted_guilds":`)
	if j.RestrictedGuilds != nil {
		buf.WriteString(`[`)
		for i, v := range j.RestrictedGuilds {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"friend_source_flags":`)

	{

		err = j.FriendSourceFlags.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.CustomStatus != nil {
		buf.WriteString(`,"custom_status":`)

		{

			err = j.CustomStatus.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"custom_status":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserSettingsbase = iota
	ffjtUserSettingsnosuchkey

	ffjtUserSettingsShowCurrentGame

	ffjtUserSettingsDefaultGuildsRestricted

	ffjtUserSettingsInlineAttachmentMedia

	ffjtUserSettingsInlineEmbedMedia

	ffjtUserSettingsGIFAutoPlay

	ffjtUserSettingsRenderEmbeds

	ffjtUserSettingsRenderReactions

	ffjtUserSettingsAnimateEmoji

	ffjtUserSettingsAnimateStickers

	ffjtUserSettingsEnableTTSCommand

	ffjtUserSettingsMessageDisplayCompact

	ffjtUserSettingsConvertEmoticons

	ffjtUserSettingsExplicitContentFilter

	ffjtUserSettingsDisableGamesTab

	ffjtUserSettingsDeveloperMode

	ffjtUserSettingsDetectPlatformAccounts

	ffjtUserSettingsStreamNotification

	ffjtUserSettingsAccessibilityDetection

	ffjtUserSettingsContactSync

	ffjtUserSettingsNativePhoneIntegration

	ffjtUserSettingsTimezoneOffset

	ffjtUserSettingsLocale

	ffjtUserSettingsTheme

	ffjtUserSettingsGuildPositions

	ffjtUserSettingsGuildFolders

	ffjtUserSettingsRestrictedGuilds

	ffjtUserSettingsFriendSourceFlags

	ffjtUserSettingsStatus

	ffjtUserSettingsCustomStatus
)

var ffjKeyUserSettingsShowCurrentGame = []byte("show_current_game")

var ffjKeyUserSettingsDefaultGuildsRestricted = []byte("default_guilds_restricted")

var ffjKeyUserSettingsInlineAttachmentMedia = []byte("inline_attachment_media")

var ffjKeyUserSettingsInlineEmbedMedia = []byte("inline_embed_media")

var ffjKeyUserSettingsGIFAutoPlay = []byte("gif_auto_play")

var ffjKeyUserSettingsRenderEmbeds = []byte("render_embeds")

var ffjKeyUserSettingsRenderReactions = []byte("render_reactions")

var ffjKeyUserSettingsAnimateEmoji = []byte("animate_emoji")

var ffjKeyUserSettingsAnimateStickers = []byte("animate_stickers")

var ffjKeyUserSettingsEnableTTSCommand = []byte("enable_tts_command")

var ffjKeyUserSettingsMessageDisplayCompact = []byte("message_display_compact")

var ffjKeyUserSettingsConvertEmoticons = []byte("convert_emoticons")

var ffjKeyUserSettingsExplicitContentFilter = []byte("explicit_content_filter")

var ffjKeyUserSettingsDisableGamesTab = []byte("disable_games_tab")

var ffjKeyUserSettingsDeveloperMode = []byte("developer_mode")

var ffjKeyUserSettingsDetectPlatformAccounts = []byte("detect_platform_accounts")

var ffjKeyUserSettingsStreamNotification = []byte("stream_notification_enabled")

var ffjKeyUserSettingsAccessibilityDetection = []byte("allow_accessibility_detection")

var ffjKeyUserSettingsContactSync = []byte("contact_sync_enabled")

var ffjKeyUserSettingsNativePhoneIntegration = []byte("native_phone_integration_enabled")

var ffjKeyUserSettingsTimezoneOffset = []byte("timezone_offset")

var ffjKeyUserSettingsLocale = []byte("locale")

var ffjKeyUserSettingsTheme = []byte("theme")

var ffjKeyUserSettingsGuildPositions = []byte("guild_positions")

var ffjKeyUserSettingsGuildFolders = []byte("guild_folders")

var ffjKeyUserSettingsRestrictedGuilds = []byte("restricted_guilds")

var ffjKeyUserSettingsFriendSourceFlags = []byte("friend_source_flags")

var ffjKeyUserSettingsStatus = []byte("status")

var ffjKeyUserSettingsCustomStatus = []byte("custom_status")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserSettings) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserSettings) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserSettingsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserSettingsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUserSettingsAnimateEmoji, kn) {
						currentKey = ffjtUserSettingsAnimateEmoji
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsAnimateStickers, kn) {
						currentKey = ffjtUserSettingsAnimateStickers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsAccessibilityDetection, kn) {
						currentKey = ffjtUserSettingsAccessibilityDetection
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyUserSettingsConvertEmoticons, kn) {
						currentKey = ffjtUserSettingsConvertEmoticons
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsContactSync, kn) {
						currentKey = ffjtUserSettingsContactSync
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsCustomStatus, kn) {
						currentKey = ffjtUserSettingsCustomStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyUserSettingsDefaultGuildsRestricted, kn) {
						currentKey = ffjtUserSettingsDefaultGuildsRestricted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsDisableGamesTab, kn) {
						currentKey = ffjtUserSettingsDisableGamesTab
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsDeveloperMode, kn) {
						currentKey = ffjtUserSettingsDeveloperMode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsDetectPlatformAccounts, kn) {
						currentKey = ffjtUserSettingsDetectPlatformAccounts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUserSettingsEnableTTSCommand, kn) {
						currentKey = ffjtUserSettingsEnableTTSCommand
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsExplicitContentFilter, kn) {
						currentKey = ffjtUserSettingsExplicitContentFilter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyUserSettingsFriendSourceFlags, kn) {
						currentKey = ffjtUserSettingsFriendSourceFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUserSettingsGIFAutoPlay, kn) {
						currentKey = ffjtUserSettingsGIFAutoPlay
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsGuildPositions, kn) {
						currentKey = ffjtUserSettingsGuildPositions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsGuildFolders, kn) {
						currentKey = ffjtUserSettingsGuildFolders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUserSettingsInlineAttachmentMedia, kn) {
						currentKey = ffjtUserSettingsInlineAttachmentMedia
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsInlineEmbedMedia, kn) {
						currentKey = ffjtUserSettingsInlineEmbedMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUserSettingsLocale, kn) {
						currentKey = ffjtUserSettingsLocale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUserSettingsMessageDisplayCompact, kn) {
						currentKey = ffjtUserSettingsMessageDisplayCompact
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyUserSettingsNativePhoneIntegration, kn) {
						currentKey = ffjtUserSettingsNativePhoneIntegration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyUserSettingsRenderEmbeds, kn) {
						currentKey = ffjtUserSettingsRenderEmbeds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsRenderReactions, kn) {
						currentKey = ffjtUserSettingsRenderReactions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsRestrictedGuilds, kn) {
						currentKey = ffjtUserSettingsRestrictedGuilds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserSettingsShowCurrentGame, kn) {
						currentKey = ffjtUserSettingsShowCurrentGame
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsStreamNotification, kn) {
						currentKey = ffjtUserSettingsStreamNotification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsStatus, kn) {
						currentKey = ffjtUserSettingsStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyUserSettingsTimezoneOffset, kn) {
						currentKey = ffjtUserSettingsTimezoneOffset
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsTheme, kn) {
						currentKey = ffjtUserSettingsTheme
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsCustomStatus, kn) {
					currentKey = ffjtUserSettingsCustomStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsStatus, kn) {
					currentKey = ffjtUserSettingsStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsFriendSourceFlags, kn) {
					currentKey = ffjtUserSettingsFriendSourceFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsRestrictedGuilds, kn) {
					currentKey = ffjtUserSettingsRestrictedGuilds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsGuildFolders, kn) {
					currentKey = ffjtUserSettingsGuildFolders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsGuildPositions, kn) {
					currentKey = ffjtUserSettingsGuildPositions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserSettingsTheme, kn) {
					currentKey = ffjtUserSettingsTheme
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserSettingsLocale, kn) {
					currentKey = ffjtUserSettingsLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsTimezoneOffset, kn) {
					currentKey = ffjtUserSettingsTimezoneOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsNativePhoneIntegration, kn) {
					currentKey = ffjtUserSettingsNativePhoneIntegration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsContactSync, kn) {
					currentKey = ffjtUserSettingsContactSync
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsAccessibilityDetection, kn) {
					currentKey = ffjtUserSettingsAccessibilityDetection
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsStreamNotification, kn) {
					currentKey = ffjtUserSettingsStreamNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsDetectPlatformAccounts, kn) {
					currentKey = ffjtUserSettingsDetectPlatformAccounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsDeveloperMode, kn) {
					currentKey = ffjtUserSettingsDeveloperMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsDisableGamesTab, kn) {
					currentKey = ffjtUserSettingsDisableGamesTab
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsExplicitContentFilter, kn) {
					currentKey = ffjtUserSettingsExplicitContentFilter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsConvertEmoticons, kn) {
					currentKey = ffjtUserSettingsConvertEmoticons
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsMessageDisplayCompact, kn) {
					currentKey = ffjtUserSettingsMessageDisplayCompact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsEnableTTSCommand, kn) {
					currentKey = ffjtUserSettingsEnableTTSCommand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsAnimateStickers, kn) {
					currentKey = ffjtUserSettingsAnimateStickers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsAnimateEmoji, kn) {
					currentKey = ffjtUserSettingsAnimateEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsRenderReactions, kn) {
					currentKey = ffjtUserSettingsRenderReactions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsRenderEmbeds, kn) {
					currentKey = ffjtUserSettingsRenderEmbeds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsGIFAutoPlay, kn) {
					currentKey = ffjtUserSettingsGIFAutoPlay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsInlineEmbedMedia, kn) {
					currentKey = ffjtUserSettingsInlineEmbedMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsInlineAttachmentMedia, kn) {
					currentKey = ffjtUserSettingsInlineAttachmentMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsDefaultGuildsRestricted, kn) {
					currentKey = ffjtUserSettingsDefaultGuildsRestricted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsShowCurrentGame, kn) {
					currentKey = ffjtUserSettingsShowCurrentGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserSettingsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserSettingsShowCurrentGame:
					goto handle_ShowCurrentGame

				case ffjtUserSettingsDefaultGuildsRestricted:
					goto handle_DefaultGuildsRestricted

				case ffjtUserSettingsInlineAttachmentMedia:
					goto handle_InlineAttachmentMedia

				case ffjtUserSettingsInlineEmbedMedia:
					goto handle_InlineEmbedMedia

				case ffjtUserSettingsGIFAutoPlay:
					goto handle_GIFAutoPlay

				case ffjtUserSettingsRenderEmbeds:
					goto handle_RenderEmbeds

				case ffjtUserSettingsRenderReactions:
					goto handle_RenderReactions

				case ffjtUserSettingsAnimateEmoji:
					goto handle_AnimateEmoji

				case ffjtUserSettingsAnimateStickers:
					goto handle_AnimateStickers

				case ffjtUserSettingsEnableTTSCommand:
					goto handle_EnableTTSCommand

				case ffjtUserSettingsMessageDisplayCompact:
					goto handle_MessageDisplayCompact

				case ffjtUserSettingsConvertEmoticons:
					goto handle_ConvertEmoticons

				case ffjtUserSettingsExplicitContentFilter:
					goto handle_ExplicitContentFilter

				case ffjtUserSettingsDisableGamesTab:
					goto handle_DisableGamesTab

				case ffjtUserSettingsDeveloperMode:
					goto handle_DeveloperMode

				case ffjtUserSettingsDetectPlatformAccounts:
					goto handle_DetectPlatformAccounts

				case ffjtUserSettingsStreamNotification:
					goto handle_StreamNotification

				case ffjtUserSettingsAccessibilityDetection:
					goto handle_AccessibilityDetection

				case ffjtUserSettingsContactSync:
					goto handle_ContactSync

				case ffjtUserSettingsNativePhoneIntegration:
					goto handle_NativePhoneIntegration

				case ffjtUserSettingsTimezoneOffset:
					goto handle_TimezoneOffset

				case ffjtUserSettingsLocale:
					goto handle_Locale

				case ffjtUserSettingsTheme:
					goto handle_Theme

				case ffjtUserSettingsGuildPositions:
					goto handle_GuildPositions

				case ffjtUserSettingsGuildFolders:
					goto handle_GuildFolders

				case ffjtUserSettingsRestrictedGuilds:
					goto handle_RestrictedGuilds

				case ffjtUserSettingsFriendSourceFlags:
					goto handle_FriendSourceFlags

				case ffjtUserSettingsStatus:
					goto handle_Status

				case ffjtUserSettingsCustomStatus:
					goto handle_CustomStatus

				case ffjtUserSettingsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ShowCurrentGame:

	/* handler: j.ShowCurrentGame type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ShowCurrentGame = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ShowCurrentGame = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DefaultGuildsRestricted:

	/* handler: j.DefaultGuildsRestricted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DefaultGuildsRestricted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DefaultGuildsRestricted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineAttachmentMedia:

	/* handler: j.InlineAttachmentMedia type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.InlineAttachmentMedia = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.InlineAttachmentMedia = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineEmbedMedia:

	/* handler: j.InlineEmbedMedia type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.InlineEmbedMedia = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.InlineEmbedMedia = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GIFAutoPlay:

	/* handler: j.GIFAutoPlay type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.GIFAutoPlay = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.GIFAutoPlay = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RenderEmbeds:

	/* handler: j.RenderEmbeds type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RenderEmbeds = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RenderEmbeds = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RenderReactions:

	/* handler: j.RenderReactions type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RenderReactions = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RenderReactions = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnimateEmoji:

	/* handler: j.AnimateEmoji type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AnimateEmoji = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AnimateEmoji = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnimateStickers:

	/* handler: j.AnimateStickers type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AnimateStickers = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EnableTTSCommand:

	/* handler: j.EnableTTSCommand type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.EnableTTSCommand = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.EnableTTSCommand = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageDisplayCompact:

	/* handler: j.MessageDisplayCompact type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MessageDisplayCompact = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MessageDisplayCompact = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConvertEmoticons:

	/* handler: j.ConvertEmoticons type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ConvertEmoticons = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ConvertEmoticons = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExplicitContentFilter:

	/* handler: j.ExplicitContentFilter type=uint8 kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExplicitContentFilter = uint8(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableGamesTab:

	/* handler: j.DisableGamesTab type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableGamesTab = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableGamesTab = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeveloperMode:

	/* handler: j.DeveloperMode type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DeveloperMode = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DeveloperMode = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DetectPlatformAccounts:

	/* handler: j.DetectPlatformAccounts type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DetectPlatformAccounts = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DetectPlatformAccounts = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreamNotification:

	/* handler: j.StreamNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.StreamNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.StreamNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccessibilityDetection:

	/* handler: j.AccessibilityDetection type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AccessibilityDetection = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AccessibilityDetection = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContactSync:

	/* handler: j.ContactSync type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ContactSync = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ContactSync = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NativePhoneIntegration:

	/* handler: j.NativePhoneIntegration type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NativePhoneIntegration = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NativePhoneIntegration = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimezoneOffset:

	/* handler: j.TimezoneOffset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TimezoneOffset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Locale:

	/* handler: j.Locale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Locale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Theme:

	/* handler: j.Theme type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Theme = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildPositions:

	/* handler: j.GuildPositions type=[]discord.GuildID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GuildPositions = nil
		} else {

			j.GuildPositions = []discord.GuildID{}

			wantVal := true

			for {

				var tmpJGuildPositions discord.GuildID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuildPositions type=discord.GuildID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJGuildPositions.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.GuildPositions = append(j.GuildPositions, tmpJGuildPositions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildFolders:

	/* handler: j.GuildFolders type=[]gateway.GuildFolder kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GuildFolders = nil
		} else {

			j.GuildFolders = []GuildFolder{}

			wantVal := true

			for {

				var tmpJGuildFolders GuildFolder

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuildFolders type=gateway.GuildFolder kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJGuildFolders.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.GuildFolders = append(j.GuildFolders, tmpJGuildFolders)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RestrictedGuilds:

	/* handler: j.RestrictedGuilds type=[]discord.GuildID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RestrictedGuilds = nil
		} else {

			j.RestrictedGuilds = []discord.GuildID{}

			wantVal := true

			for {

				var tmpJRestrictedGuilds discord.GuildID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRestrictedGuilds type=discord.GuildID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRestrictedGuilds.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RestrictedGuilds = append(j.RestrictedGuilds, tmpJRestrictedGuilds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FriendSourceFlags:

	/* handler: j.FriendSourceFlags type=gateway.FriendSourceFlags kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.FriendSourceFlags.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = discord.Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomStatus:

	/* handler: j.CustomStatus type=gateway.CustomUserStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CustomStatus = nil

		} else {

			if j.CustomStatus == nil {
				j.CustomStatus = new(CustomUserStatus)
			}

			err = j.CustomStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserSettingsUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserSettingsUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.ShowCurrentGame {
		buf.WriteString(`{"show_current_game":true`)
	} else {
		buf.WriteString(`{"show_current_game":false`)
	}
	if j.DefaultGuildsRestricted {
		buf.WriteString(`,"default_guilds_restricted":true`)
	} else {
		buf.WriteString(`,"default_guilds_restricted":false`)
	}
	if j.InlineAttachmentMedia {
		buf.WriteString(`,"inline_attachment_media":true`)
	} else {
		buf.WriteString(`,"inline_attachment_media":false`)
	}
	if j.InlineEmbedMedia {
		buf.WriteString(`,"inline_embed_media":true`)
	} else {
		buf.WriteString(`,"inline_embed_media":false`)
	}
	if j.GIFAutoPlay {
		buf.WriteString(`,"gif_auto_play":true`)
	} else {
		buf.WriteString(`,"gif_auto_play":false`)
	}
	if j.RenderEmbeds {
		buf.WriteString(`,"render_embeds":true`)
	} else {
		buf.WriteString(`,"render_embeds":false`)
	}
	if j.RenderReactions {
		buf.WriteString(`,"render_reactions":true`)
	} else {
		buf.WriteString(`,"render_reactions":false`)
	}
	if j.AnimateEmoji {
		buf.WriteString(`,"animate_emoji":true`)
	} else {
		buf.WriteString(`,"animate_emoji":false`)
	}
	buf.WriteString(`,"animate_stickers":`)
	fflib.FormatBits2(buf, uint64(j.AnimateStickers), 10, j.AnimateStickers < 0)
	if j.EnableTTSCommand {
		buf.WriteString(`,"enable_tts_command":true`)
	} else {
		buf.WriteString(`,"enable_tts_command":false`)
	}
	if j.MessageDisplayCompact {
		buf.WriteString(`,"message_display_compact":true`)
	} else {
		buf.WriteString(`,"message_display_compact":false`)
	}
	if j.ConvertEmoticons {
		buf.WriteString(`,"convert_emoticons":true`)
	} else {
		buf.WriteString(`,"convert_emoticons":false`)
	}
	buf.WriteString(`,"explicit_content_filter":`)
	fflib.FormatBits2(buf, uint64(j.ExplicitContentFilter), 10, false)
	if j.DisableGamesTab {
		buf.WriteString(`,"disable_games_tab":true`)
	} else {
		buf.WriteString(`,"disable_games_tab":false`)
	}
	if j.DeveloperMode {
		buf.WriteString(`,"developer_mode":true`)
	} else {
		buf.WriteString(`,"developer_mode":false`)
	}
	if j.DetectPlatformAccounts {
		buf.WriteString(`,"detect_platform_accounts":true`)
	} else {
		buf.WriteString(`,"detect_platform_accounts":false`)
	}
	if j.StreamNotification {
		buf.WriteString(`,"stream_notification_enabled":true`)
	} else {
		buf.WriteString(`,"stream_notification_enabled":false`)
	}
	if j.AccessibilityDetection {
		buf.WriteString(`,"allow_accessibility_detection":true`)
	} else {
		buf.WriteString(`,"allow_accessibility_detection":false`)
	}
	if j.ContactSync {
		buf.WriteString(`,"contact_sync_enabled":true`)
	} else {
		buf.WriteString(`,"contact_sync_enabled":false`)
	}
	if j.NativePhoneIntegration {
		buf.WriteString(`,"native_phone_integration_enabled":true`)
	} else {
		buf.WriteString(`,"native_phone_integration_enabled":false`)
	}
	buf.WriteString(`,"timezone_offset":`)
	fflib.FormatBits2(buf, uint64(j.TimezoneOffset), 10, j.TimezoneOffset < 0)
	buf.WriteString(`,"locale":`)
	fflib.WriteJsonString(buf, string(j.Locale))
	buf.WriteString(`,"theme":`)
	fflib.WriteJsonString(buf, string(j.Theme))
	buf.WriteString(`,"guild_positions":`)
	if j.GuildPositions != nil {
		buf.WriteString(`[`)
		for i, v := range j.GuildPositions {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"guild_folders":`)
	if j.GuildFolders != nil {
		buf.WriteString(`[`)
		for i, v := range j.GuildFolders {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"restricted_guilds":`)
	if j.RestrictedGuilds != nil {
		buf.WriteString(`[`)
		for i, v := range j.RestrictedGuilds {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"friend_source_flags":`)

	{

		err = j.FriendSourceFlags.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.CustomStatus != nil {
		buf.WriteString(`,"custom_status":`)

		{

			err = j.CustomStatus.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"custom_status":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserSettingsUpdateEventbase = iota
	ffjtUserSettingsUpdateEventnosuchkey

	ffjtUserSettingsUpdateEventShowCurrentGame

	ffjtUserSettingsUpdateEventDefaultGuildsRestricted

	ffjtUserSettingsUpdateEventInlineAttachmentMedia

	ffjtUserSettingsUpdateEventInlineEmbedMedia

	ffjtUserSettingsUpdateEventGIFAutoPlay

	ffjtUserSettingsUpdateEventRenderEmbeds

	ffjtUserSettingsUpdateEventRenderReactions

	ffjtUserSettingsUpdateEventAnimateEmoji

	ffjtUserSettingsUpdateEventAnimateStickers

	ffjtUserSettingsUpdateEventEnableTTSCommand

	ffjtUserSettingsUpdateEventMessageDisplayCompact

	ffjtUserSettingsUpdateEventConvertEmoticons

	ffjtUserSettingsUpdateEventExplicitContentFilter

	ffjtUserSettingsUpdateEventDisableGamesTab

	ffjtUserSettingsUpdateEventDeveloperMode

	ffjtUserSettingsUpdateEventDetectPlatformAccounts

	ffjtUserSettingsUpdateEventStreamNotification

	ffjtUserSettingsUpdateEventAccessibilityDetection

	ffjtUserSettingsUpdateEventContactSync

	ffjtUserSettingsUpdateEventNativePhoneIntegration

	ffjtUserSettingsUpdateEventTimezoneOffset

	ffjtUserSettingsUpdateEventLocale

	ffjtUserSettingsUpdateEventTheme

	ffjtUserSettingsUpdateEventGuildPositions

	ffjtUserSettingsUpdateEventGuildFolders

	ffjtUserSettingsUpdateEventRestrictedGuilds

	ffjtUserSettingsUpdateEventFriendSourceFlags

	ffjtUserSettingsUpdateEventStatus

	ffjtUserSettingsUpdateEventCustomStatus
)

var ffjKeyUserSettingsUpdateEventShowCurrentGame = []byte("show_current_game")

var ffjKeyUserSettingsUpdateEventDefaultGuildsRestricted = []byte("default_guilds_restricted")

var ffjKeyUserSettingsUpdateEventInlineAttachmentMedia = []byte("inline_attachment_media")

var ffjKeyUserSettingsUpdateEventInlineEmbedMedia = []byte("inline_embed_media")

var ffjKeyUserSettingsUpdateEventGIFAutoPlay = []byte("gif_auto_play")

var ffjKeyUserSettingsUpdateEventRenderEmbeds = []byte("render_embeds")

var ffjKeyUserSettingsUpdateEventRenderReactions = []byte("render_reactions")

var ffjKeyUserSettingsUpdateEventAnimateEmoji = []byte("animate_emoji")

var ffjKeyUserSettingsUpdateEventAnimateStickers = []byte("animate_stickers")

var ffjKeyUserSettingsUpdateEventEnableTTSCommand = []byte("enable_tts_command")

var ffjKeyUserSettingsUpdateEventMessageDisplayCompact = []byte("message_display_compact")

var ffjKeyUserSettingsUpdateEventConvertEmoticons = []byte("convert_emoticons")

var ffjKeyUserSettingsUpdateEventExplicitContentFilter = []byte("explicit_content_filter")

var ffjKeyUserSettingsUpdateEventDisableGamesTab = []byte("disable_games_tab")

var ffjKeyUserSettingsUpdateEventDeveloperMode = []byte("developer_mode")

var ffjKeyUserSettingsUpdateEventDetectPlatformAccounts = []byte("detect_platform_accounts")

var ffjKeyUserSettingsUpdateEventStreamNotification = []byte("stream_notification_enabled")

var ffjKeyUserSettingsUpdateEventAccessibilityDetection = []byte("allow_accessibility_detection")

var ffjKeyUserSettingsUpdateEventContactSync = []byte("contact_sync_enabled")

var ffjKeyUserSettingsUpdateEventNativePhoneIntegration = []byte("native_phone_integration_enabled")

var ffjKeyUserSettingsUpdateEventTimezoneOffset = []byte("timezone_offset")

var ffjKeyUserSettingsUpdateEventLocale = []byte("locale")

var ffjKeyUserSettingsUpdateEventTheme = []byte("theme")

var ffjKeyUserSettingsUpdateEventGuildPositions = []byte("guild_positions")

var ffjKeyUserSettingsUpdateEventGuildFolders = []byte("guild_folders")

var ffjKeyUserSettingsUpdateEventRestrictedGuilds = []byte("restricted_guilds")

var ffjKeyUserSettingsUpdateEventFriendSourceFlags = []byte("friend_source_flags")

var ffjKeyUserSettingsUpdateEventStatus = []byte("status")

var ffjKeyUserSettingsUpdateEventCustomStatus = []byte("custom_status")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserSettingsUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserSettingsUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserSettingsUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserSettingsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventAnimateEmoji, kn) {
						currentKey = ffjtUserSettingsUpdateEventAnimateEmoji
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventAnimateStickers, kn) {
						currentKey = ffjtUserSettingsUpdateEventAnimateStickers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventAccessibilityDetection, kn) {
						currentKey = ffjtUserSettingsUpdateEventAccessibilityDetection
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventConvertEmoticons, kn) {
						currentKey = ffjtUserSettingsUpdateEventConvertEmoticons
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventContactSync, kn) {
						currentKey = ffjtUserSettingsUpdateEventContactSync
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventCustomStatus, kn) {
						currentKey = ffjtUserSettingsUpdateEventCustomStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventDefaultGuildsRestricted, kn) {
						currentKey = ffjtUserSettingsUpdateEventDefaultGuildsRestricted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventDisableGamesTab, kn) {
						currentKey = ffjtUserSettingsUpdateEventDisableGamesTab
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventDeveloperMode, kn) {
						currentKey = ffjtUserSettingsUpdateEventDeveloperMode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventDetectPlatformAccounts, kn) {
						currentKey = ffjtUserSettingsUpdateEventDetectPlatformAccounts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventEnableTTSCommand, kn) {
						currentKey = ffjtUserSettingsUpdateEventEnableTTSCommand
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventExplicitContentFilter, kn) {
						currentKey = ffjtUserSettingsUpdateEventExplicitContentFilter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventFriendSourceFlags, kn) {
						currentKey = ffjtUserSettingsUpdateEventFriendSourceFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventGIFAutoPlay, kn) {
						currentKey = ffjtUserSettingsUpdateEventGIFAutoPlay
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventGuildPositions, kn) {
						currentKey = ffjtUserSettingsUpdateEventGuildPositions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventGuildFolders, kn) {
						currentKey = ffjtUserSettingsUpdateEventGuildFolders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventInlineAttachmentMedia, kn) {
						currentKey = ffjtUserSettingsUpdateEventInlineAttachmentMedia
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventInlineEmbedMedia, kn) {
						currentKey = ffjtUserSettingsUpdateEventInlineEmbedMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventLocale, kn) {
						currentKey = ffjtUserSettingsUpdateEventLocale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventMessageDisplayCompact, kn) {
						currentKey = ffjtUserSettingsUpdateEventMessageDisplayCompact
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventNativePhoneIntegration, kn) {
						currentKey = ffjtUserSettingsUpdateEventNativePhoneIntegration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventRenderEmbeds, kn) {
						currentKey = ffjtUserSettingsUpdateEventRenderEmbeds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventRenderReactions, kn) {
						currentKey = ffjtUserSettingsUpdateEventRenderReactions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventRestrictedGuilds, kn) {
						currentKey = ffjtUserSettingsUpdateEventRestrictedGuilds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventShowCurrentGame, kn) {
						currentKey = ffjtUserSettingsUpdateEventShowCurrentGame
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventStreamNotification, kn) {
						currentKey = ffjtUserSettingsUpdateEventStreamNotification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventStatus, kn) {
						currentKey = ffjtUserSettingsUpdateEventStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyUserSettingsUpdateEventTimezoneOffset, kn) {
						currentKey = ffjtUserSettingsUpdateEventTimezoneOffset
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserSettingsUpdateEventTheme, kn) {
						currentKey = ffjtUserSettingsUpdateEventTheme
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventCustomStatus, kn) {
					currentKey = ffjtUserSettingsUpdateEventCustomStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventStatus, kn) {
					currentKey = ffjtUserSettingsUpdateEventStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventFriendSourceFlags, kn) {
					currentKey = ffjtUserSettingsUpdateEventFriendSourceFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventRestrictedGuilds, kn) {
					currentKey = ffjtUserSettingsUpdateEventRestrictedGuilds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventGuildFolders, kn) {
					currentKey = ffjtUserSettingsUpdateEventGuildFolders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventGuildPositions, kn) {
					currentKey = ffjtUserSettingsUpdateEventGuildPositions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserSettingsUpdateEventTheme, kn) {
					currentKey = ffjtUserSettingsUpdateEventTheme
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserSettingsUpdateEventLocale, kn) {
					currentKey = ffjtUserSettingsUpdateEventLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventTimezoneOffset, kn) {
					currentKey = ffjtUserSettingsUpdateEventTimezoneOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventNativePhoneIntegration, kn) {
					currentKey = ffjtUserSettingsUpdateEventNativePhoneIntegration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventContactSync, kn) {
					currentKey = ffjtUserSettingsUpdateEventContactSync
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventAccessibilityDetection, kn) {
					currentKey = ffjtUserSettingsUpdateEventAccessibilityDetection
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventStreamNotification, kn) {
					currentKey = ffjtUserSettingsUpdateEventStreamNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventDetectPlatformAccounts, kn) {
					currentKey = ffjtUserSettingsUpdateEventDetectPlatformAccounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventDeveloperMode, kn) {
					currentKey = ffjtUserSettingsUpdateEventDeveloperMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventDisableGamesTab, kn) {
					currentKey = ffjtUserSettingsUpdateEventDisableGamesTab
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventExplicitContentFilter, kn) {
					currentKey = ffjtUserSettingsUpdateEventExplicitContentFilter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventConvertEmoticons, kn) {
					currentKey = ffjtUserSettingsUpdateEventConvertEmoticons
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventMessageDisplayCompact, kn) {
					currentKey = ffjtUserSettingsUpdateEventMessageDisplayCompact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventEnableTTSCommand, kn) {
					currentKey = ffjtUserSettingsUpdateEventEnableTTSCommand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventAnimateStickers, kn) {
					currentKey = ffjtUserSettingsUpdateEventAnimateStickers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventAnimateEmoji, kn) {
					currentKey = ffjtUserSettingsUpdateEventAnimateEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventRenderReactions, kn) {
					currentKey = ffjtUserSettingsUpdateEventRenderReactions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventRenderEmbeds, kn) {
					currentKey = ffjtUserSettingsUpdateEventRenderEmbeds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventGIFAutoPlay, kn) {
					currentKey = ffjtUserSettingsUpdateEventGIFAutoPlay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventInlineEmbedMedia, kn) {
					currentKey = ffjtUserSettingsUpdateEventInlineEmbedMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserSettingsUpdateEventInlineAttachmentMedia, kn) {
					currentKey = ffjtUserSettingsUpdateEventInlineAttachmentMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventDefaultGuildsRestricted, kn) {
					currentKey = ffjtUserSettingsUpdateEventDefaultGuildsRestricted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserSettingsUpdateEventShowCurrentGame, kn) {
					currentKey = ffjtUserSettingsUpdateEventShowCurrentGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserSettingsUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserSettingsUpdateEventShowCurrentGame:
					goto handle_ShowCurrentGame

				case ffjtUserSettingsUpdateEventDefaultGuildsRestricted:
					goto handle_DefaultGuildsRestricted

				case ffjtUserSettingsUpdateEventInlineAttachmentMedia:
					goto handle_InlineAttachmentMedia

				case ffjtUserSettingsUpdateEventInlineEmbedMedia:
					goto handle_InlineEmbedMedia

				case ffjtUserSettingsUpdateEventGIFAutoPlay:
					goto handle_GIFAutoPlay

				case ffjtUserSettingsUpdateEventRenderEmbeds:
					goto handle_RenderEmbeds

				case ffjtUserSettingsUpdateEventRenderReactions:
					goto handle_RenderReactions

				case ffjtUserSettingsUpdateEventAnimateEmoji:
					goto handle_AnimateEmoji

				case ffjtUserSettingsUpdateEventAnimateStickers:
					goto handle_AnimateStickers

				case ffjtUserSettingsUpdateEventEnableTTSCommand:
					goto handle_EnableTTSCommand

				case ffjtUserSettingsUpdateEventMessageDisplayCompact:
					goto handle_MessageDisplayCompact

				case ffjtUserSettingsUpdateEventConvertEmoticons:
					goto handle_ConvertEmoticons

				case ffjtUserSettingsUpdateEventExplicitContentFilter:
					goto handle_ExplicitContentFilter

				case ffjtUserSettingsUpdateEventDisableGamesTab:
					goto handle_DisableGamesTab

				case ffjtUserSettingsUpdateEventDeveloperMode:
					goto handle_DeveloperMode

				case ffjtUserSettingsUpdateEventDetectPlatformAccounts:
					goto handle_DetectPlatformAccounts

				case ffjtUserSettingsUpdateEventStreamNotification:
					goto handle_StreamNotification

				case ffjtUserSettingsUpdateEventAccessibilityDetection:
					goto handle_AccessibilityDetection

				case ffjtUserSettingsUpdateEventContactSync:
					goto handle_ContactSync

				case ffjtUserSettingsUpdateEventNativePhoneIntegration:
					goto handle_NativePhoneIntegration

				case ffjtUserSettingsUpdateEventTimezoneOffset:
					goto handle_TimezoneOffset

				case ffjtUserSettingsUpdateEventLocale:
					goto handle_Locale

				case ffjtUserSettingsUpdateEventTheme:
					goto handle_Theme

				case ffjtUserSettingsUpdateEventGuildPositions:
					goto handle_GuildPositions

				case ffjtUserSettingsUpdateEventGuildFolders:
					goto handle_GuildFolders

				case ffjtUserSettingsUpdateEventRestrictedGuilds:
					goto handle_RestrictedGuilds

				case ffjtUserSettingsUpdateEventFriendSourceFlags:
					goto handle_FriendSourceFlags

				case ffjtUserSettingsUpdateEventStatus:
					goto handle_Status

				case ffjtUserSettingsUpdateEventCustomStatus:
					goto handle_CustomStatus

				case ffjtUserSettingsUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ShowCurrentGame:

	/* handler: j.ShowCurrentGame type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ShowCurrentGame = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ShowCurrentGame = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DefaultGuildsRestricted:

	/* handler: j.DefaultGuildsRestricted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DefaultGuildsRestricted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DefaultGuildsRestricted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineAttachmentMedia:

	/* handler: j.InlineAttachmentMedia type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.InlineAttachmentMedia = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.InlineAttachmentMedia = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineEmbedMedia:

	/* handler: j.InlineEmbedMedia type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.InlineEmbedMedia = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.InlineEmbedMedia = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GIFAutoPlay:

	/* handler: j.GIFAutoPlay type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.GIFAutoPlay = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.GIFAutoPlay = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RenderEmbeds:

	/* handler: j.RenderEmbeds type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RenderEmbeds = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RenderEmbeds = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RenderReactions:

	/* handler: j.RenderReactions type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RenderReactions = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RenderReactions = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnimateEmoji:

	/* handler: j.AnimateEmoji type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AnimateEmoji = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AnimateEmoji = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnimateStickers:

	/* handler: j.AnimateStickers type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AnimateStickers = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EnableTTSCommand:

	/* handler: j.EnableTTSCommand type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.EnableTTSCommand = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.EnableTTSCommand = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageDisplayCompact:

	/* handler: j.MessageDisplayCompact type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MessageDisplayCompact = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MessageDisplayCompact = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConvertEmoticons:

	/* handler: j.ConvertEmoticons type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ConvertEmoticons = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ConvertEmoticons = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExplicitContentFilter:

	/* handler: j.ExplicitContentFilter type=uint8 kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExplicitContentFilter = uint8(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableGamesTab:

	/* handler: j.DisableGamesTab type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableGamesTab = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableGamesTab = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeveloperMode:

	/* handler: j.DeveloperMode type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DeveloperMode = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DeveloperMode = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DetectPlatformAccounts:

	/* handler: j.DetectPlatformAccounts type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DetectPlatformAccounts = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DetectPlatformAccounts = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreamNotification:

	/* handler: j.StreamNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.StreamNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.StreamNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccessibilityDetection:

	/* handler: j.AccessibilityDetection type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AccessibilityDetection = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AccessibilityDetection = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContactSync:

	/* handler: j.ContactSync type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ContactSync = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ContactSync = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NativePhoneIntegration:

	/* handler: j.NativePhoneIntegration type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NativePhoneIntegration = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NativePhoneIntegration = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimezoneOffset:

	/* handler: j.TimezoneOffset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TimezoneOffset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Locale:

	/* handler: j.Locale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Locale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Theme:

	/* handler: j.Theme type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Theme = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildPositions:

	/* handler: j.GuildPositions type=[]discord.GuildID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GuildPositions = nil
		} else {

			j.GuildPositions = []discord.GuildID{}

			wantVal := true

			for {

				var tmpJGuildPositions discord.GuildID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuildPositions type=discord.GuildID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJGuildPositions.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.GuildPositions = append(j.GuildPositions, tmpJGuildPositions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildFolders:

	/* handler: j.GuildFolders type=[]gateway.GuildFolder kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GuildFolders = nil
		} else {

			j.GuildFolders = []GuildFolder{}

			wantVal := true

			for {

				var tmpJGuildFolders GuildFolder

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGuildFolders type=gateway.GuildFolder kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJGuildFolders.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.GuildFolders = append(j.GuildFolders, tmpJGuildFolders)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RestrictedGuilds:

	/* handler: j.RestrictedGuilds type=[]discord.GuildID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RestrictedGuilds = nil
		} else {

			j.RestrictedGuilds = []discord.GuildID{}

			wantVal := true

			for {

				var tmpJRestrictedGuilds discord.GuildID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRestrictedGuilds type=discord.GuildID kind=uint64 quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRestrictedGuilds.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.RestrictedGuilds = append(j.RestrictedGuilds, tmpJRestrictedGuilds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FriendSourceFlags:

	/* handler: j.FriendSourceFlags type=gateway.FriendSourceFlags kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.FriendSourceFlags.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=discord.Status kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Status", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = discord.Status(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomStatus:

	/* handler: j.CustomStatus type=gateway.CustomUserStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CustomStatus = nil

		} else {

			if j.CustomStatus == nil {
				j.CustomStatus = new(CustomUserStatus)
			}

			err = j.CustomStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(j.Username))
	buf.WriteString(`,"discriminator":`)
	fflib.WriteJsonString(buf, string(j.Discriminator))
	buf.WriteString(`,"avatar":`)
	fflib.WriteJsonString(buf, string(j.Avatar))
	buf.WriteString(`,"global_name":`)
	fflib.WriteJsonString(buf, string(j.DisplayName))
	buf.WriteByte(',')
	if j.Bot != false {
		if j.Bot {
			buf.WriteString(`"bot":true`)
		} else {
			buf.WriteString(`"bot":false`)
		}
		buf.WriteByte(',')
	}
	if j.MFA != false {
		if j.MFA {
			buf.WriteString(`"mfa_enabled":true`)
		} else {
			buf.WriteString(`"mfa_enabled":false`)
		}
		buf.WriteByte(',')
	}
	if j.Nitro != 0 {
		buf.WriteString(`"premium_type":`)
		fflib.FormatBits2(buf, uint64(j.Nitro), 10, false)
		buf.WriteByte(',')
	}
	if j.Flags != 0 {
		buf.WriteString(`"flags":`)
		fflib.FormatBits2(buf, uint64(j.Flags), 10, false)
		buf.WriteByte(',')
	}
	if j.PublicFlags != 0 {
		buf.WriteString(`"public_flags":`)
		fflib.FormatBits2(buf, uint64(j.PublicFlags), 10, false)
		buf.WriteByte(',')
	}
	if j.DiscordSystem != false {
		if j.DiscordSystem {
			buf.WriteString(`"system":true`)
		} else {
			buf.WriteString(`"system":false`)
		}
		buf.WriteByte(',')
	}
	if j.EmailVerified != false {
		if j.EmailVerified {
			buf.WriteString(`"verified":true`)
		} else {
			buf.WriteString(`"verified":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Locale) != 0 {
		buf.WriteString(`"locale":`)
		fflib.WriteJsonString(buf, string(j.Locale))
		buf.WriteByte(',')
	}
	if len(j.Email) != 0 {
		buf.WriteString(`"email":`)
		fflib.WriteJsonString(buf, string(j.Email))
		buf.WriteByte(',')
	}
	if len(j.Banner) != 0 {
		buf.WriteString(`"banner":`)
		fflib.WriteJsonString(buf, string(j.Banner))
		buf.WriteByte(',')
	}
	if j.Accent != 0 {
		buf.WriteString(`"accent_color":`)

		{

			obj, err = j.Accent.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserUpdateEventbase = iota
	ffjtUserUpdateEventnosuchkey

	ffjtUserUpdateEventID

	ffjtUserUpdateEventUsername

	ffjtUserUpdateEventDiscriminator

	ffjtUserUpdateEventAvatar

	ffjtUserUpdateEventDisplayName

	ffjtUserUpdateEventBot

	ffjtUserUpdateEventMFA

	ffjtUserUpdateEventNitro

	ffjtUserUpdateEventFlags

	ffjtUserUpdateEventPublicFlags

	ffjtUserUpdateEventDiscordSystem

	ffjtUserUpdateEventEmailVerified

	ffjtUserUpdateEventLocale

	ffjtUserUpdateEventEmail

	ffjtUserUpdateEventBanner

	ffjtUserUpdateEventAccent
)

var ffjKeyUserUpdateEventID = []byte("id")

var ffjKeyUserUpdateEventUsername = []byte("username")

var ffjKeyUserUpdateEventDiscriminator = []byte("discriminator")

var ffjKeyUserUpdateEventAvatar = []byte("avatar")

var ffjKeyUserUpdateEventDisplayName = []byte("global_name")

var ffjKeyUserUpdateEventBot = []byte("bot")

var ffjKeyUserUpdateEventMFA = []byte("mfa_enabled")

var ffjKeyUserUpdateEventNitro = []byte("premium_type")

var ffjKeyUserUpdateEventFlags = []byte("flags")

var ffjKeyUserUpdateEventPublicFlags = []byte("public_flags")

var ffjKeyUserUpdateEventDiscordSystem = []byte("system")

var ffjKeyUserUpdateEventEmailVerified = []byte("verified")

var ffjKeyUserUpdateEventLocale = []byte("locale")

var ffjKeyUserUpdateEventEmail = []byte("email")

var ffjKeyUserUpdateEventBanner = []byte("banner")

var ffjKeyUserUpdateEventAccent = []byte("accent_color")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUserUpdateEventAvatar, kn) {
						currentKey = ffjtUserUpdateEventAvatar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserUpdateEventAccent, kn) {
						currentKey = ffjtUserUpdateEventAccent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyUserUpdateEventBot, kn) {
						currentKey = ffjtUserUpdateEventBot
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserUpdateEventBanner, kn) {
						currentKey = ffjtUserUpdateEventBanner
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyUserUpdateEventDiscriminator, kn) {
						currentKey = ffjtUserUpdateEventDiscriminator
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUserUpdateEventEmail, kn) {
						currentKey = ffjtUserUpdateEventEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyUserUpdateEventFlags, kn) {
						currentKey = ffjtUserUpdateEventFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUserUpdateEventDisplayName, kn) {
						currentKey = ffjtUserUpdateEventDisplayName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUserUpdateEventID, kn) {
						currentKey = ffjtUserUpdateEventID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUserUpdateEventLocale, kn) {
						currentKey = ffjtUserUpdateEventLocale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUserUpdateEventMFA, kn) {
						currentKey = ffjtUserUpdateEventMFA
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyUserUpdateEventNitro, kn) {
						currentKey = ffjtUserUpdateEventNitro
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserUpdateEventPublicFlags, kn) {
						currentKey = ffjtUserUpdateEventPublicFlags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserUpdateEventDiscordSystem, kn) {
						currentKey = ffjtUserUpdateEventDiscordSystem
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyUserUpdateEventUsername, kn) {
						currentKey = ffjtUserUpdateEventUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyUserUpdateEventEmailVerified, kn) {
						currentKey = ffjtUserUpdateEventEmailVerified
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyUserUpdateEventAccent, kn) {
					currentKey = ffjtUserUpdateEventAccent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventBanner, kn) {
					currentKey = ffjtUserUpdateEventBanner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventEmail, kn) {
					currentKey = ffjtUserUpdateEventEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventLocale, kn) {
					currentKey = ffjtUserUpdateEventLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventEmailVerified, kn) {
					currentKey = ffjtUserUpdateEventEmailVerified
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUpdateEventDiscordSystem, kn) {
					currentKey = ffjtUserUpdateEventDiscordSystem
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUpdateEventPublicFlags, kn) {
					currentKey = ffjtUserUpdateEventPublicFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUpdateEventFlags, kn) {
					currentKey = ffjtUserUpdateEventFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserUpdateEventNitro, kn) {
					currentKey = ffjtUserUpdateEventNitro
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserUpdateEventMFA, kn) {
					currentKey = ffjtUserUpdateEventMFA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventBot, kn) {
					currentKey = ffjtUserUpdateEventBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserUpdateEventDisplayName, kn) {
					currentKey = ffjtUserUpdateEventDisplayName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventAvatar, kn) {
					currentKey = ffjtUserUpdateEventAvatar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUpdateEventDiscriminator, kn) {
					currentKey = ffjtUserUpdateEventDiscriminator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUpdateEventUsername, kn) {
					currentKey = ffjtUserUpdateEventUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserUpdateEventID, kn) {
					currentKey = ffjtUserUpdateEventID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserUpdateEventID:
					goto handle_ID

				case ffjtUserUpdateEventUsername:
					goto handle_Username

				case ffjtUserUpdateEventDiscriminator:
					goto handle_Discriminator

				case ffjtUserUpdateEventAvatar:
					goto handle_Avatar

				case ffjtUserUpdateEventDisplayName:
					goto handle_DisplayName

				case ffjtUserUpdateEventBot:
					goto handle_Bot

				case ffjtUserUpdateEventMFA:
					goto handle_MFA

				case ffjtUserUpdateEventNitro:
					goto handle_Nitro

				case ffjtUserUpdateEventFlags:
					goto handle_Flags

				case ffjtUserUpdateEventPublicFlags:
					goto handle_PublicFlags

				case ffjtUserUpdateEventDiscordSystem:
					goto handle_DiscordSystem

				case ffjtUserUpdateEventEmailVerified:
					goto handle_EmailVerified

				case ffjtUserUpdateEventLocale:
					goto handle_Locale

				case ffjtUserUpdateEventEmail:
					goto handle_Email

				case ffjtUserUpdateEventBanner:
					goto handle_Banner

				case ffjtUserUpdateEventAccent:
					goto handle_Accent

				case ffjtUserUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: j.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Discriminator:

	/* handler: j.Discriminator type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Discriminator = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Avatar:

	/* handler: j.Avatar type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Avatar = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisplayName:

	/* handler: j.DisplayName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DisplayName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bot:

	/* handler: j.Bot type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Bot = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Bot = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MFA:

	/* handler: j.MFA type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.MFA = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.MFA = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nitro:

	/* handler: j.Nitro type=discord.UserNitro kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UserNitro", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Nitro = discord.UserNitro(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flags:

	/* handler: j.Flags type=discord.UserFlags kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UserFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Flags = discord.UserFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PublicFlags:

	/* handler: j.PublicFlags type=discord.UserFlags kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UserFlags", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PublicFlags = discord.UserFlags(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiscordSystem:

	/* handler: j.DiscordSystem type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DiscordSystem = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DiscordSystem = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmailVerified:

	/* handler: j.EmailVerified type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.EmailVerified = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.EmailVerified = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Locale:

	/* handler: j.Locale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Locale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Banner:

	/* handler: j.Banner type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Banner = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Accent:

	/* handler: j.Accent type=discord.Color kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Accent.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VoiceServerUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VoiceServerUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"token":`)
	fflib.WriteJsonString(buf, string(j.Token))
	buf.WriteString(`,"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"endpoint":`)
	fflib.WriteJsonString(buf, string(j.Endpoint))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVoiceServerUpdateEventbase = iota
	ffjtVoiceServerUpdateEventnosuchkey

	ffjtVoiceServerUpdateEventToken

	ffjtVoiceServerUpdateEventGuildID

	ffjtVoiceServerUpdateEventEndpoint
)

var ffjKeyVoiceServerUpdateEventToken = []byte("token")

var ffjKeyVoiceServerUpdateEventGuildID = []byte("guild_id")

var ffjKeyVoiceServerUpdateEventEndpoint = []byte("endpoint")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VoiceServerUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VoiceServerUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVoiceServerUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVoiceServerUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyVoiceServerUpdateEventEndpoint, kn) {
						currentKey = ffjtVoiceServerUpdateEventEndpoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyVoiceServerUpdateEventGuildID, kn) {
						currentKey = ffjtVoiceServerUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVoiceServerUpdateEventToken, kn) {
						currentKey = ffjtVoiceServerUpdateEventToken
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceServerUpdateEventEndpoint, kn) {
					currentKey = ffjtVoiceServerUpdateEventEndpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceServerUpdateEventGuildID, kn) {
					currentKey = ffjtVoiceServerUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceServerUpdateEventToken, kn) {
					currentKey = ffjtVoiceServerUpdateEventToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVoiceServerUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVoiceServerUpdateEventToken:
					goto handle_Token

				case ffjtVoiceServerUpdateEventGuildID:
					goto handle_GuildID

				case ffjtVoiceServerUpdateEventEndpoint:
					goto handle_Endpoint

				case ffjtVoiceServerUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Token:

	/* handler: j.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Token = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Endpoint:

	/* handler: j.Endpoint type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Endpoint = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VoiceStateUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VoiceStateUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"user_id":`)

	{

		obj, err = j.UserID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if j.Member != nil {
		if true {
			buf.WriteString(`"member":`)

			{

				err = j.Member.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"session_id":`)
	fflib.WriteJsonString(buf, string(j.SessionID))
	if j.Deaf {
		buf.WriteString(`,"deaf":true`)
	} else {
		buf.WriteString(`,"deaf":false`)
	}
	if j.Mute {
		buf.WriteString(`,"mute":true`)
	} else {
		buf.WriteString(`,"mute":false`)
	}
	if j.SelfDeaf {
		buf.WriteString(`,"self_deaf":true`)
	} else {
		buf.WriteString(`,"self_deaf":false`)
	}
	if j.SelfMute {
		buf.WriteString(`,"self_mute":true`)
	} else {
		buf.WriteString(`,"self_mute":false`)
	}
	buf.WriteByte(',')
	if j.SelfStream != false {
		if j.SelfStream {
			buf.WriteString(`"self_stream":true`)
		} else {
			buf.WriteString(`"self_stream":false`)
		}
		buf.WriteByte(',')
	}
	if j.SelfVideo != false {
		if j.SelfVideo {
			buf.WriteString(`"self_video":true`)
		} else {
			buf.WriteString(`"self_video":false`)
		}
		buf.WriteByte(',')
	}
	if j.Suppress {
		buf.WriteString(`"suppress":true`)
	} else {
		buf.WriteString(`"suppress":false`)
	}
	if j.RequestToSpeakTimestamp != nil {
		buf.WriteString(`,"request_to_speak_timestamp":`)

		{

			obj, err = j.RequestToSpeakTimestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
	} else {
		buf.WriteString(`,"request_to_speak_timestamp":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVoiceStateUpdateEventbase = iota
	ffjtVoiceStateUpdateEventnosuchkey

	ffjtVoiceStateUpdateEventGuildID

	ffjtVoiceStateUpdateEventChannelID

	ffjtVoiceStateUpdateEventUserID

	ffjtVoiceStateUpdateEventMember

	ffjtVoiceStateUpdateEventSessionID

	ffjtVoiceStateUpdateEventDeaf

	ffjtVoiceStateUpdateEventMute

	ffjtVoiceStateUpdateEventSelfDeaf

	ffjtVoiceStateUpdateEventSelfMute

	ffjtVoiceStateUpdateEventSelfStream

	ffjtVoiceStateUpdateEventSelfVideo

	ffjtVoiceStateUpdateEventSuppress

	ffjtVoiceStateUpdateEventRequestToSpeakTimestamp
)

var ffjKeyVoiceStateUpdateEventGuildID = []byte("guild_id")

var ffjKeyVoiceStateUpdateEventChannelID = []byte("channel_id")

var ffjKeyVoiceStateUpdateEventUserID = []byte("user_id")

var ffjKeyVoiceStateUpdateEventMember = []byte("member")

var ffjKeyVoiceStateUpdateEventSessionID = []byte("session_id")

var ffjKeyVoiceStateUpdateEventDeaf = []byte("deaf")

var ffjKeyVoiceStateUpdateEventMute = []byte("mute")

var ffjKeyVoiceStateUpdateEventSelfDeaf = []byte("self_deaf")

var ffjKeyVoiceStateUpdateEventSelfMute = []byte("self_mute")

var ffjKeyVoiceStateUpdateEventSelfStream = []byte("self_stream")

var ffjKeyVoiceStateUpdateEventSelfVideo = []byte("self_video")

var ffjKeyVoiceStateUpdateEventSuppress = []byte("suppress")

var ffjKeyVoiceStateUpdateEventRequestToSpeakTimestamp = []byte("request_to_speak_timestamp")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VoiceStateUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VoiceStateUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVoiceStateUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVoiceStateUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventChannelID, kn) {
						currentKey = ffjtVoiceStateUpdateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventDeaf, kn) {
						currentKey = ffjtVoiceStateUpdateEventDeaf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventGuildID, kn) {
						currentKey = ffjtVoiceStateUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventMember, kn) {
						currentKey = ffjtVoiceStateUpdateEventMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceStateUpdateEventMute, kn) {
						currentKey = ffjtVoiceStateUpdateEventMute
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventRequestToSpeakTimestamp, kn) {
						currentKey = ffjtVoiceStateUpdateEventRequestToSpeakTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventSessionID, kn) {
						currentKey = ffjtVoiceStateUpdateEventSessionID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceStateUpdateEventSelfDeaf, kn) {
						currentKey = ffjtVoiceStateUpdateEventSelfDeaf
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceStateUpdateEventSelfMute, kn) {
						currentKey = ffjtVoiceStateUpdateEventSelfMute
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceStateUpdateEventSelfStream, kn) {
						currentKey = ffjtVoiceStateUpdateEventSelfStream
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceStateUpdateEventSelfVideo, kn) {
						currentKey = ffjtVoiceStateUpdateEventSelfVideo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceStateUpdateEventSuppress, kn) {
						currentKey = ffjtVoiceStateUpdateEventSuppress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyVoiceStateUpdateEventUserID, kn) {
						currentKey = ffjtVoiceStateUpdateEventUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventRequestToSpeakTimestamp, kn) {
					currentKey = ffjtVoiceStateUpdateEventRequestToSpeakTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventSuppress, kn) {
					currentKey = ffjtVoiceStateUpdateEventSuppress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventSelfVideo, kn) {
					currentKey = ffjtVoiceStateUpdateEventSelfVideo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventSelfStream, kn) {
					currentKey = ffjtVoiceStateUpdateEventSelfStream
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventSelfMute, kn) {
					currentKey = ffjtVoiceStateUpdateEventSelfMute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventSelfDeaf, kn) {
					currentKey = ffjtVoiceStateUpdateEventSelfDeaf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceStateUpdateEventMute, kn) {
					currentKey = ffjtVoiceStateUpdateEventMute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceStateUpdateEventDeaf, kn) {
					currentKey = ffjtVoiceStateUpdateEventDeaf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventSessionID, kn) {
					currentKey = ffjtVoiceStateUpdateEventSessionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceStateUpdateEventMember, kn) {
					currentKey = ffjtVoiceStateUpdateEventMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVoiceStateUpdateEventUserID, kn) {
					currentKey = ffjtVoiceStateUpdateEventUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceStateUpdateEventChannelID, kn) {
					currentKey = ffjtVoiceStateUpdateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceStateUpdateEventGuildID, kn) {
					currentKey = ffjtVoiceStateUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVoiceStateUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVoiceStateUpdateEventGuildID:
					goto handle_GuildID

				case ffjtVoiceStateUpdateEventChannelID:
					goto handle_ChannelID

				case ffjtVoiceStateUpdateEventUserID:
					goto handle_UserID

				case ffjtVoiceStateUpdateEventMember:
					goto handle_Member

				case ffjtVoiceStateUpdateEventSessionID:
					goto handle_SessionID

				case ffjtVoiceStateUpdateEventDeaf:
					goto handle_Deaf

				case ffjtVoiceStateUpdateEventMute:
					goto handle_Mute

				case ffjtVoiceStateUpdateEventSelfDeaf:
					goto handle_SelfDeaf

				case ffjtVoiceStateUpdateEventSelfMute:
					goto handle_SelfMute

				case ffjtVoiceStateUpdateEventSelfStream:
					goto handle_SelfStream

				case ffjtVoiceStateUpdateEventSelfVideo:
					goto handle_SelfVideo

				case ffjtVoiceStateUpdateEventSuppress:
					goto handle_Suppress

				case ffjtVoiceStateUpdateEventRequestToSpeakTimestamp:
					goto handle_RequestToSpeakTimestamp

				case ffjtVoiceStateUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=discord.UserID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UserID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Member:

	/* handler: j.Member type=discord.Member kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Member = nil

		} else {

			if j.Member == nil {
				j.Member = new(discord.Member)
			}

			err = j.Member.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SessionID:

	/* handler: j.SessionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SessionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deaf:

	/* handler: j.Deaf type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Deaf = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Deaf = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mute:

	/* handler: j.Mute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfDeaf:

	/* handler: j.SelfDeaf type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SelfDeaf = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SelfDeaf = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfMute:

	/* handler: j.SelfMute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SelfMute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SelfMute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfStream:

	/* handler: j.SelfStream type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SelfStream = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SelfStream = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfVideo:

	/* handler: j.SelfVideo type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SelfVideo = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SelfVideo = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Suppress:

	/* handler: j.Suppress type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Suppress = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Suppress = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestToSpeakTimestamp:

	/* handler: j.RequestToSpeakTimestamp type=discord.Timestamp kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.RequestToSpeakTimestamp = nil

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			if j.RequestToSpeakTimestamp == nil {
				j.RequestToSpeakTimestamp = new(discord.Timestamp)
			}

			err = j.RequestToSpeakTimestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *WebhooksUpdateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *WebhooksUpdateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"guild_id":`)

	{

		obj, err = j.GuildID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"channel_id":`)

	{

		obj, err = j.ChannelID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtWebhooksUpdateEventbase = iota
	ffjtWebhooksUpdateEventnosuchkey

	ffjtWebhooksUpdateEventGuildID

	ffjtWebhooksUpdateEventChannelID
)

var ffjKeyWebhooksUpdateEventGuildID = []byte("guild_id")

var ffjKeyWebhooksUpdateEventChannelID = []byte("channel_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *WebhooksUpdateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *WebhooksUpdateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtWebhooksUpdateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtWebhooksUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyWebhooksUpdateEventChannelID, kn) {
						currentKey = ffjtWebhooksUpdateEventChannelID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyWebhooksUpdateEventGuildID, kn) {
						currentKey = ffjtWebhooksUpdateEventGuildID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyWebhooksUpdateEventChannelID, kn) {
					currentKey = ffjtWebhooksUpdateEventChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyWebhooksUpdateEventGuildID, kn) {
					currentKey = ffjtWebhooksUpdateEventGuildID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtWebhooksUpdateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtWebhooksUpdateEventGuildID:
					goto handle_GuildID

				case ffjtWebhooksUpdateEventChannelID:
					goto handle_ChannelID

				case ffjtWebhooksUpdateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GuildID:

	/* handler: j.GuildID type=discord.GuildID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.GuildID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=discord.ChannelID kind=uint64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ChannelID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
